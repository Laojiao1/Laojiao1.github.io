<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【计算机视觉】YOLOv3 模型</title>
    <link href="/2025/01/14/DeepLearning/YOLOv3/"/>
    <url>/2025/01/14/DeepLearning/YOLOv3/</url>
    
    <content type="html"><![CDATA[<h1>【计算机视觉】YOLOv3 模型</h1><h2 id="一、前言">一、前言</h2><p>YOLOv3模型相较之前复杂了许多，可以通过<strong>改变模型结构来权衡速度和精度</strong>，而且保留了很多v2和v1的特性，建议在看此篇文章之前，先对YOLO算法做一下简单了解：<a href="https://laojiao1.github.io/2025/01/13/DeepLearning/YOLO/">YOLO算法简述</a></p><p>我们先看一下计算机是如何确定一张图中物体所在位置的：</p><p><img src="/img/DeepLearning/YOLOv3/image-20250114122206591.png" alt=""></p><p>那YOLOv3是如何确定这四个参数呢？</p><p>当一张图被传入到YOLOv3的网络中时，首先会被调成416×416的大小，为了防止失真，在图像的边缘加上灰度条，之后它会将图片分为13×13，26×26，52×52的网格。由于图像在多次卷积压缩后，小物体的特征容易消失，所以52×52的网格用于检测小物体，13×13的物体用来检测大物体。</p><p>由于猫是一个比较大的物体，所以它由13×13的网格检测，每个网格点负责其右下角区域的检测，如果物体的中心点落在这个区域，这个物体的位置就由这个网格点确定。</p><p><img src="/img/DeepLearning/YOLOv3/image-20250114122213873.png" alt=""></p><p><strong>总结而言</strong>：YOLOv3把一张图片分成不同的网络，每个网络点负责一个区域的识别，只要物体的中心点落在这个区域，这个物体就由这个网格点来确定。</p><h2 id="二、YOLOv3-网络结构解析">二、YOLOv3 网络结构解析</h2><p><img src="/img/DeepLearning/YOLOv3/image-20250114122220211.png" alt=""></p><p>可以看到：整个YOLOv3结构里面，<strong>没有池化层和全连接层</strong>，网络的下采样是通过设置卷积的stride=2来达到的，每当通过这个卷积层之后图像的尺寸就会减小到一半。残差模块中的1×，2×，8×，8× 等表示残差模块的个数。</p><p>此外，YOLOv3所使用的主干特征提取网络为Darknet53，它具有两个重要特点：</p><ol><li><strong>使用了残差网络 Residual</strong>：网络越深，梯度消失的现象就越来越明显，网络的训练效果也不会很好。残差神经网络就是为了在加深网络的情况下，来解决梯度消失的问题。残差结构可以不通过卷积，直接从前面一个特征层映射到后面的特征层（跳跃连接），缓解了在深度神经网络中增加深度带来的梯度消失问题，容易优化。</li><li>Darknet53的<strong>每一个DarknetConv2D后面都紧跟Batch Normalization标准化与Leaky ReLU部分</strong>。普通的ReLU是将所有的负值都设为零——可能会导致神经元死亡问题；而Leaky ReLU则是给所有负值赋予一个非零斜率——在负值区域保留了一定的梯度信息，可以缓解神经元死亡的问题，使网络更易于训练。</li></ol><p>整个主干代码如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><br><span class="hljs-keyword">from</span> keras.initializers <span class="hljs-keyword">import</span> random_normal<br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> (Add, BatchNormalization, Conv2D, LeakyReLU,<br>                          ZeroPadding2D)<br><span class="hljs-keyword">from</span> keras.regularizers <span class="hljs-keyword">import</span> l2<br><span class="hljs-keyword">from</span> utils.utils <span class="hljs-keyword">import</span> compose<br><br><br><span class="hljs-comment">#---------------------------------------------------#</span><br><span class="hljs-comment">#   单次卷积</span><br><span class="hljs-comment">#   DarknetConv2D</span><br><span class="hljs-comment">#---------------------------------------------------#</span><br><span class="hljs-meta">@wraps(<span class="hljs-params">Conv2D</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">DarknetConv2D</span>(<span class="hljs-params">*args, **kwargs</span>):<br>    darknet_conv_kwargs = &#123;<span class="hljs-string">&#x27;kernel_initializer&#x27;</span> : random_normal(stddev=<span class="hljs-number">0.02</span>), <span class="hljs-string">&#x27;kernel_regularizer&#x27;</span>: l2(<span class="hljs-number">5e-4</span>)&#125;<br>    darknet_conv_kwargs[<span class="hljs-string">&#x27;padding&#x27;</span>] = <span class="hljs-string">&#x27;valid&#x27;</span> <span class="hljs-keyword">if</span> kwargs.get(<span class="hljs-string">&#x27;strides&#x27;</span>)==(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;same&#x27;</span><br>    darknet_conv_kwargs.update(kwargs)<br>    <span class="hljs-keyword">return</span> Conv2D(*args, **darknet_conv_kwargs)<br><br><span class="hljs-comment">#---------------------------------------------------#</span><br><span class="hljs-comment">#   卷积块 -&gt; 卷积 + 标准化 + 激活函数</span><br><span class="hljs-comment">#   DarknetConv2D + BatchNormalization + LeakyReLU</span><br><span class="hljs-comment">#---------------------------------------------------#</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">DarknetConv2D_BN_Leaky</span>(<span class="hljs-params">*args, **kwargs</span>):<br>    no_bias_kwargs = &#123;<span class="hljs-string">&#x27;use_bias&#x27;</span>: <span class="hljs-literal">False</span>&#125;<br>    no_bias_kwargs.update(kwargs)<br>    <span class="hljs-keyword">return</span> compose( <br>        DarknetConv2D(*args, **no_bias_kwargs),<br>        BatchNormalization(),<br>        LeakyReLU(alpha=<span class="hljs-number">0.1</span>))<br><br><span class="hljs-comment">#---------------------------------------------------------------------#</span><br><span class="hljs-comment">#   残差结构</span><br><span class="hljs-comment">#   首先利用ZeroPadding2D和一个步长为2x2的卷积块进行高和宽的压缩</span><br><span class="hljs-comment">#   然后对num_blocks进行循环，循环内部是残差结构。</span><br><span class="hljs-comment">#---------------------------------------------------------------------#</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">resblock_body</span>(<span class="hljs-params">x, num_filters, num_blocks</span>):<br>    x = ZeroPadding2D(((<span class="hljs-number">1</span>,<span class="hljs-number">0</span>),(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)))(x)<br>    x = DarknetConv2D_BN_Leaky(num_filters, (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>), strides=(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>))(x)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_blocks):<br>        y = DarknetConv2D_BN_Leaky(num_filters//<span class="hljs-number">2</span>, (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))(x)<br>        y = DarknetConv2D_BN_Leaky(num_filters, (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>))(y)<br>        x = Add()([x,y])<br>    <span class="hljs-keyword">return</span> x<br><br><span class="hljs-comment">#---------------------------------------------------#</span><br><span class="hljs-comment">#   darknet53 的主体部分</span><br><span class="hljs-comment">#   输入为一张416x416x3的图片</span><br><span class="hljs-comment">#   输出为三个有效特征层</span><br><span class="hljs-comment">#---------------------------------------------------#</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">darknet_body</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-comment"># 416,416,3 -&gt; 416,416,32</span><br>    x = DarknetConv2D_BN_Leaky(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>))(x)<br>    <span class="hljs-comment"># 416,416,32 -&gt; 208,208,64</span><br>    x = resblock_body(x, <span class="hljs-number">64</span>, <span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 208,208,64 -&gt; 104,104,128</span><br>    x = resblock_body(x, <span class="hljs-number">128</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># 104,104,128 -&gt; 52,52,256</span><br>    x = resblock_body(x, <span class="hljs-number">256</span>, <span class="hljs-number">8</span>)<br>    feat1 = x<br>    <span class="hljs-comment"># 52,52,256 -&gt; 26,26,512</span><br>    x = resblock_body(x, <span class="hljs-number">512</span>, <span class="hljs-number">8</span>)<br>    feat2 = x<br>    <span class="hljs-comment"># 26,26,512 -&gt; 13,13,1024</span><br>    x = resblock_body(x, <span class="hljs-number">1024</span>, <span class="hljs-number">4</span>)<br>    feat3 = x<br>    <span class="hljs-keyword">return</span> feat1, feat2, feat3<br></code></pre></td></tr></table></figure><h2 id="三、概念引入">三、概念引入</h2><p><strong>在下一步讲解流程原理之前，先来了解一下一些基本概念：</strong></p><p><strong>1. x_offset 和 y_offset</strong></p><ul><li><strong>x_offset</strong>: 表示网格左上角相对于 x 轴的偏移量。</li><li><strong>y_offset</strong>: 表示网格左上角相对于 y 轴的偏移量。</li></ul><p><strong>2. 上采样（UpSampling）</strong><br>上采样是<strong>将图像放大以提高分辨率的过程</strong>，也称为图像插值（interpolating）。它的主要作用包括：</p><ul><li>放大原图像，使其适配更高分辨率的显示设备</li><li>在深度学习中，恢复图像的空间细节以便与低分辨率特征图融合</li></ul><p>与之相对的下采样（subsampled）是通过缩小图像尺寸实现以下目的：</p><ul><li>减小图像以适配显示区域的大小</li><li>用于生成图像的缩略图或降低分辨率以提取特征</li></ul><p><strong>3. 先验框（Anchor Box）</strong></p><p>先验框是为常见目标<strong>预定义</strong>的一组宽高比例的框。在目标检测中，它的作用是<strong>辅助预测边界框</strong>的参数（如 x_offset, y_offset, h, 和 w）<br>例如：</p><ul><li><p>在 coco 数据集中，输出的维度为 (13,13, (80+5)*3)，其中 <code>3</code> 表示每个网格预测 3 个先验框，每个框有 85 个参数（80 个类别概率 + 5 个框参数）</p></li><li><p>下图中蓝色框即为先验框，代表建议的目标位置范围。它通过预设的宽高比帮助检测器聚焦于目标区域，提高预测框和真实框的 IOU（交并比）。黄色框是最终显示的真实边界框，红色框为预测的目标中心点</p><p><img src="/img/DeepLearning/YOLOv3/image-20250114142321097.png" alt=""></p></li></ul><p><strong>4. 置信度（Confidence）</strong></p><p>置信度表示预测的<strong>先验框与真实框（Ground Truth Box）的 IOU 值</strong>，即预测框中存在目标的概率 Pr(Object)<br>例如：</p><ul><li>在人脸识别任务中，如果框中包含人脸，则置信度会越高；反之，如果框中是背景或者其他不相关对象（如树、房子），则置信度接近 0</li><li>置信度的高低直接决定了目标检测框是否有效，是目标检测中非常重要的参数</li></ul><p><strong>5. 交并比（IoU）</strong></p><p>在检测任务中使用交并比（Intersection of Union，IoU）作为衡量<strong>锚框与真实框之间重合度关系</strong>的指标。计算公式如下：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnspacing="1em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>I</mi><mi>o</mi><mi>U</mi><mo>=</mo><mfrac><mrow><mi>A</mi><mo>∩</mo><mi>B</mi></mrow><mrow><mi>A</mi><mo>∪</mo><mi>B</mi></mrow></mfrac></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{equation}IoU = \frac{A \cap B}{A \cup B}\end{equation}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.0463em;vertical-align:-0.7732em;"></span><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2732em;"><span style="top:-3.2732em;"><span class="pstrut" style="height:3.3603em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7732em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2732em;"><span style="top:-3.2732em;"><span class="pstrut" style="height:3.3603em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7732em;"><span></span></span></span></span></span></span></span></span></p><p><img src="/img/DeepLearning/YOLOv3/image-20250114141915280.png" alt=""></p><h2 id="四、YOLOv3-检测流程原理">四、YOLOv3 检测流程原理</h2><h3 id="1-从特征中获取预测结果">1. 从特征中获取预测结果</h3><p>在特征利用部分，YoloV3提取<strong>多特征层进行目标检测</strong>，一共<strong>提取三个特征层</strong>，分别位于<strong>中间层 (52,52,256)，中下层(26,26,512)，底层(13,13,1024)</strong>。这些特征层随后将通过上采样操作与其他特征层堆叠（Concat）进行融合。</p><p><img src="/img/DeepLearning/YOLOv3/image-20250114122241319.png" alt=""></p><p><strong>底层 (13,13,1024) 的处理：</strong></p><ul><li>从底层特征层 13×13×1024 开始，首先对其进行 <strong>5 次卷积操作</strong>，进一步提取特征</li><li>卷积操作后的特征分为两部分：<ol><li><strong>一部分输出预测结果</strong>，经过两个卷积层（Conv2D 3×3 和 Conv2D 1×1）调整通道数，最终生成特征层 13×13×75，作为该尺度的目标检测输出</li><li><strong>另一部分用于上采样</strong>，通过上采样（UpSampling2D）操作生成特征层 26×26×256</li></ol></li></ul><p><strong>中下层特征层 (26,26,512) 的处理：</strong></p><ul><li>上采样后的特征层 26×26×256 与来自 Darknet53 的中下层特征层 26×26×512 进行拼接（Concat），得到融合特征层 26×26×768</li><li>拼接后的特征层经过 5 次卷积操作处理，分为两部分：<ol><li><strong>一部分输出预测结果</strong>，通过（Conv2D 3×3 和 Conv2D 1×1）调整通道数，生成特征层 26×26×75</li><li><strong>另一部分用于上采样</strong>，通过上采样操作生成特征层 52×52×128</li></ol></li></ul><p><strong>中间层特征层 (52,52,256) 的处理</strong></p><ul><li>上采样后的特征层 52×52×128 与来自 Darknet53 的中间层特征层 52×52×256 进行拼接（Concat），得到融合特征层 52×52×384</li><li>拼接后的特征层经过 <strong>5 次卷积操作</strong> 处理，最后通过（Conv2D 3×3 和 Conv2D 1×1）调整通道数，生成特征层 52×52×75，作为最终的目标检测输出</li></ul><p><strong>最后生成的3个预测结果：</strong></p><ul><li><strong>52×52×75 特征层</strong>：检测小物体</li><li><strong>26×26×75 特征层</strong>：检测中等物体</li><li><strong>13×13×75特征层</strong>：检测大物体</li></ul><h3 id="2-预测结果的解码">2. 预测结果的解码</h3><p>YOLOv3 网络中的预测结果并不能直接用于定位目标框，因为网络输出的是<strong>相对于特征层或先验框的一些偏移量或归一化值，而不是目标的实际位置信息</strong>。因此还需要通过解码，将网络输出从特征空间转化为输入图像空间中的实际坐标。</p><p>yolov3的预测原理是分别将整幅图分为13x13、26x26、52x52 的网格（实际上有点像三个等分的网格），然后从每个网格中心建立多个<strong>先验框</strong>，典型值是一个特征点三个先验框，这些框是网络<strong>预先设定好的框</strong>，网络的预测结果会判断这些框内是否包含物体，以及这个物体的种类。</p><p>每个边界框的中心点坐标均为相对于其对应的单元格（grid cell）左上点坐标的偏移，其计算公式如下：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>b</mi><mi>x</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>c</mi><mi>x</mi></msub></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>b</mi><mi>y</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>σ</mi><mo stretchy="false">(</mo><msub><mi>t</mi><mi>y</mi></msub><mo stretchy="false">)</mo><mo>+</mo><msub><mi>c</mi><mi>y</mi></msub></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>b</mi><mi>w</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>p</mi><mi>w</mi></msub><mo>⋅</mo><msup><mi>e</mi><msub><mi>t</mi><mi>w</mi></msub></msup></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mi>b</mi><mi>h</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>p</mi><mi>h</mi></msub><mo>⋅</mo><msup><mi>e</mi><msub><mi>t</mi><mi>h</mi></msub></msup></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align}b_x &amp; = \sigma(t_x) + c_x \\b_y &amp; = \sigma(t_y) + c_y \\b_w &amp; = p_w \cdot e^{t_w} \\b_h &amp; = p_h \cdot e^{t_h} \\\end{align}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.0071em;vertical-align:-2.7536em;"></span><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.2536em;"><span style="top:-5.4136em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.9136em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-0.9064em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.7536em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.2536em;"><span style="top:-5.4136em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.9136em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8436em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-0.9064em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8436em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.7536em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.2536em;"><span style="top:-5.2571em;"><span class="pstrut" style="height:2.8436em;"></span><span class="eqn-num"></span></span><span style="top:-3.7571em;"><span class="pstrut" style="height:2.8436em;"></span><span class="eqn-num"></span></span><span style="top:-2.2536em;"><span class="pstrut" style="height:2.8436em;"></span><span class="eqn-num"></span></span><span style="top:-0.75em;"><span class="pstrut" style="height:2.8436em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.7536em;"><span></span></span></span></span></span></span></span></span></p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>c</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>c</mi><mi>y</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(c_x, c_y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>：该点所在网格的左上角距离最左上角相差的格子数</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>b</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>b</mi><mi>h</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(b_x, b_y, b_w, b_h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>：最后显示的边界框的坐标及其宽高</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>t</mi><mi>x</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>y</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>h</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(t_x, t_y, t_w, t_h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>：目标中心点相对于该点所在的单元格中左上角的偏移量及其预测边框的宽和高</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>p</mi><mi>w</mi></msub><mo separator="true">,</mo><msub><mi>p</mi><mi>h</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(p_w, p_h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>：先验框的边长</li><li>σ：激活函数，YOLOv3里用的是sigmoid函数，范围在[0,1]之间。这里用sigmoid取代之前版本的softmax，原因是softmax会扩大最大类别概率值而抑制其他类别概率值</li></ul><p>图解如下：</p><p><img src="/img/DeepLearning/YOLOv3/image-20250114135954456.png" alt=""></p><h3 id="3-非极大值抑制（NMS）">3. 非极大值抑制（NMS）</h3><p>这一步就是对最终的预测结果进行<strong>得分排序与非极大抑制筛选</strong>。</p><p>非极大值抑制（NMS）的具体流程如下：</p><ol><li><strong>根据置信度排序</strong>：将所有边界框按照置信度得分从高到低排序。</li><li><strong>选择最高置信度框</strong>：取置信度最高的边界框，加入最终的输出结果列表，并将其从候选边界框列表中移除。</li><li><strong>计算边界框面积</strong>：对剩余候选边界框计算其面积，用于后续 IoU 的计算。</li><li><strong>计算 IoU</strong>：计算当前选中的最高置信度框与其他候选框之间的 IoU 值。</li><li><strong>剔除高 IoU 框</strong>：将 IoU 大于指定阈值的候选框从列表中移除（认为是重复框）。</li><li><strong>重复以上步骤</strong>：继续从剩余的候选框中选择置信度最高的框，并重复上述过程，直到候选框列表为空。</li><li><strong>输出结果</strong>：返回最终保留的边界框列表作为检测结果。</li></ol><p>例如：</p><ul><li>阈值为0.6</li></ul><p><img src="/img/DeepLearning/YOLOv3/image-20250114140436498.png" alt=""></p><ul><li>阈值为0.5</li></ul><p><img src="/img/DeepLearning/YOLOv3/image-20250114140924931.png" alt=""></p><ul><li>阈值为0.4</li></ul><p><img src="/img/DeepLearning/YOLOv3/image-20250114140636578.png" alt=""></p><h2 id="参考文献">参考文献</h2><ul><li><a href="https://blog.csdn.net/weixin_39615182/article/details/109752498">https://blog.csdn.net/weixin_39615182/article/details/109752498</a></li><li><a href="https://blog.csdn.net/weixin_44791964/article/details/103276106">https://blog.csdn.net/weixin_44791964/article/details/103276106</a></li><li><a href="https://www.bilibili.com/video/BV1XJ411D7wF?vd_source=2b06cc402150237b16279df9e94ff252&amp;spm_id_from=333.788.videopod.episodes">https://www.bilibili.com/video/BV1XJ411D7wF?vd_source=2b06cc402150237b16279df9e94ff252&amp;spm_id_from=333.788.videopod.episodes</a></li><li><a href="https://www.jianshu.com/p/d452b5615850">https://www.jianshu.com/p/d452b5615850</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>DeepLearning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepLearning</tag>
      
      <tag>OpenCV</tag>
      
      <tag>目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机视觉】YOLO 算法简述</title>
    <link href="/2025/01/13/DeepLearning/YOLO/"/>
    <url>/2025/01/13/DeepLearning/YOLO/</url>
    
    <content type="html"><![CDATA[<h1>YOLO 算法</h1><p>在正式介绍YOLO之前，先看一张图：</p><p><img src="/img/DeepLearning/YOLO/image-20250113153024148.png" alt="各类目标检测算法对比图"></p><p>可以看出YOLO的最大特点是速度快。<strong>YOLO在精度上仍然落后于目前最先进的检测系统。虽然它可以快速识别图像中的目标，但它在定位某些物体尤其是小的物体上精度不高。论文中做了精度／时间的权衡。</strong></p><p><img src="/img/DeepLearning/YOLO/image-20250113153042383.png" alt="算法发展过程"></p><p>YOLO算法系列的演变过程：<code>YOLO -&gt; YOLO9000 -&gt; YOLOv2 -&gt; YOLOv3</code></p><h2 id="YOLO介绍">YOLO介绍</h2><p>YOLO（You Only Look Once）是一种端到端的目标检测方法。以前的目标检测方法利用分类器来执行检测。与先前的方案不同，yolo网络<strong>使用单个神经网络，在一次评估中直接从完整图像上预测边界框和类别概率。由于整个检测流程仅用一个网络，所以可以直接对检测性能进行端到端的优化。</strong></p><p><img src="/img/DeepLearning/YOLO/image-20250113153127742.png" alt=""></p><h3 id="1-YOLO模型结构">1. YOLO模型结构</h3><p>YOLO 是一个简单直观的目标检测系统，其检测过程可以概括为以下三步：</p><ol><li><strong>图像预处理</strong><br>将输入图像缩放至固定大小 448×448，方便模型处理，同时确保输入维度一致。</li><li><strong>特征提取与预测</strong><br>利用卷积神经网络（CNN）对缩放后的图像进行处理，生成预测结果，包括目标的类别、置信度以及边界框位置。</li><li><strong>结果后处理</strong><br>根据模型输出的置信度对检测结果进行筛选，过滤掉低置信度的框，并通过非极大值抑制（NMS）去除重复框，最终得到精确的检测结果。</li></ol><p>网络结构如下：</p><p><img src="/img/DeepLearning/YOLO/image-20250113153355885.png" alt="YOLO网络结构图"></p><p>Yolo的网络架构受GoogleNet的启发，使用网络有24个卷积层，后面是2个全连接层。</p><h3 id="2-统一检测过程">2. 统一检测过程</h3><p>（1）原始图片resize到448x448，经过网络的处理之后，将图片输出成了一个7 x 7 x 30的结构</p><ul><li><strong>下面进行一个简单的过程解释：</strong></li></ul><p>系统将输入图像分成 n×n 的网格。如果目标的中心落入某个网格单元中，那么该网格单元就负责检测该目标。</p><p><img src="/img/DeepLearning/YOLO/image-20250113153911265.png" alt="yolo检测小狗"></p><p>接下来以下图为例，默认7 x 7个单元格，这里用3 x 3的单元格图演示</p><p><img src="/img/DeepLearning/YOLO/image-20250113153957203.png" alt=""></p><p>（2）在每个网格单元格中都会预测B个边界框，一般是两个，每一个边界框会预测一个置信度表示该边界框中是否包含目标。</p><p><img src="/img/DeepLearning/YOLO/image-20250113154031523.png" alt=""></p><p>（3）接下来对这些边界框进行NMS筛选（置信度以及IoU），删去重叠度较高的预测框，获取最优的检测结果。</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/img/DeepLearning/YOLO/image-20250113154049190.png" alt=""></div><div class="group-image-wrap"><img src="/img/DeepLearning/YOLO/image-20250113154201321.png" alt=""></div></div></div><h3 id="3-单元格（grid-cell）">3. 单元格（grid cell）</h3><p>上面第二步是理解YOLO网络的关键。YOLO 的输出是一个大小为 <strong>7 × 7 × 30</strong> 的特征图。这意味着输入图像被分成了 <strong>7 × 7 = 49 个网格单元格</strong>，每个单元格会预测若干个边界框以及相关的置信度分数和类别概率。</p><h4 id="置信度与边界框">置信度与边界框</h4><p>7 x 7 = 49 个像素值，可以理解成49个单元格，每个单元格可以代表原图的一个方块。单元格需要做的两件事：</p><ol><li><strong>预测边界框（bbox）</strong><ul><li>每个单元格预测 2 个边界框，每个边界框包含 5 个预测值：<ul><li>(𝑥, 𝑦)：边界框中心点的相对坐标（相对于当前单元格）。</li><li>(𝑤, ℎ)：边界框的宽度和高度（相对于整张图像）。</li><li>置信度 c：预测框是否包含目标的概率，并结合 IOU 表示框的准确性。</li></ul></li></ul></li><li><strong>预测类别概率</strong><ul><li>每个单元格会预测 <strong>20 个类别的概率</strong>，即目标属于某一类别的可能性（假设数据集中有 20 个类别）。</li></ul></li></ol><h4 id="输出特征图结构">输出特征图结构</h4><p>特征图的最后一维（30）可以拆解为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>30</mn><mo>=</mo><mn>2</mn><mo>×</mo><mo stretchy="false">(</mo><mn>4</mn><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">30 = 2 ×(4+1)+20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">30</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span></span></p><ul><li><strong>4 + 1</strong>：每个边界框的 4 个位置坐标(𝑥, 𝑦, 𝑤, ℎ) 和 1 个置信度。</li><li><strong>2</strong>：每个单元格预测 2 个边界框。</li><li><strong>20</strong>：每个单元格对应的类别概率分布。</li></ul><h4 id="总预测量">总预测量</h4><ul><li><strong>7 x 7(49 个单元格)</strong> × <strong>2 个边界框</strong> = <strong>98 个预测框</strong>。</li><li>每个框结合类别概率，可以进一步计算类别特定的置信度，用于后续的目标检测结果筛选。</li></ul><h3 id="4-网络输出筛选（置信度比较）">4. 网络输出筛选（置信度比较）</h3><p><strong>一个网格单元预测两个边界框（Bbox），但在训练时，每个目标只分配一个 Bbox 专门负责（即一个目标对应一个 Bbox）</strong>。为了确定每个位置预测的两个 Bbox 中哪个更适合作为目标框，采用以下筛选策略：</p><ul><li><strong>通过置信度大小比较</strong></li></ul><p><img src="/img/DeepLearning/YOLO/image-20250113154929770.png" alt=""></p><ul><li><p><strong>评估标准</strong></p><ul><li><p>每个边界框都对应一个置信度</p></li><li><p>这些置信度分数反映了该模型对那个框内是否包含目标的信心程度，以及它对自己的预测的准确度的估量。</p></li><li><p>公式定义：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>P</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mtext>Object</mtext><mo stretchy="false">)</mo><mo>⋅</mo><msubsup><mtext>IOU</mtext><mtext>truth</mtext><mtext>pred</mtext></msubsup></mrow><annotation encoding="application/x-tex">P_r(\text{Object}) \cdot \text{IOU}_{\text{truth}}^{\text{pred}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord">Object</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2683em;vertical-align:-0.3013em;"></span><span class="mord"><span class="mord text"><span class="mord">IOU</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.967em;"><span style="top:-2.3987em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">truth</span></span></span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">pred</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3013em;"><span></span></span></span></span></span></span></span></span></span></span></p><ul><li>如果单元格里面没有Object，则置信度（confidence）为 <strong>0</strong>。</li><li>如果单元格中有目标，则置信度（confidence score）等于上述公式的值</li></ul></li></ul></li></ul><p>注：<strong>如何判断一个单元格（grid cell）中是否包含object？</strong></p><p>当图像中某个目标（Object）的真实框（Ground Truth）中心点落在某个单元格的范围内时，就判定该单元格包含该目标。</p><h4 id="预测位置">预测位置</h4><p>每个边界框（Bbox）包含 5 个预测值：(𝑥, 𝑦, 𝑤, ℎ, 𝑐𝑜𝑛𝑓𝑖𝑑𝑒𝑛𝑐𝑒)</p><ol><li><strong>中心点坐标 (𝑥, 𝑦)</strong><ul><li>表示边界框中心点相对于所属网格单元（Grid Cell）左上角的偏移值。</li><li>注：每个网格单元的左上角被设为原点 (0,0)，右下角设为 (1,1)，因此 (x,y) 的取值范围一定在 <strong>(0, 1)</strong> 之间。</li></ul></li><li><strong>宽度和高度 (𝑤, ℎ)</strong><ul><li>表示边界框的宽度和高度相对于整张图片的比例：<ul><li>𝑤 = 预测框宽度图片宽度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><mfrac><mtext>预测框宽度</mtext><mtext>图片宽度</mtext></mfrac></mrow><annotation encoding="application/x-tex">w = \frac{\text{预测框宽度}}{\text{图片宽度}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">图片宽度</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">预测框宽度</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li>ℎ = 预测框高度图片高度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mfrac><mtext>预测框高度</mtext><mtext>图片高度</mtext></mfrac></mrow><annotation encoding="application/x-tex">h = \frac{\text{预测框高度}}{\text{图片高度}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">图片高度</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">预测框高度</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul></li><li>通过标准化处理，(𝑤, ℎ) 的取值范围也在 <strong>(0, 1)</strong> 之间。</li></ul></li><li><strong>置信度（confidence）</strong><ul><li>置信度表示预测框中是否存在目标以及边界框与目标匹配的程度（IOU）。</li><li>它综合了两部分信息（即在上文中提到的<strong>评估标准</strong>）：<ul><li>当前网格单元中是否存在目标的概率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mtext>Object</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(\text{Object})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord text"><span class="mord">Object</span></span><span class="mclose">)</span></span></span></span> 。</li><li>边界框的准确性，即预测框与真实框的重叠程度（IOU）。</li></ul></li></ul></li></ol><p><strong>为什么这样去做？</strong></p><p>预测中采用相对于网格单元位置的位置坐标，这使得真实值的界限在0到1之间，参数化更容易学习，从而使网络更加稳定。</p><hr><p><em>需要注意的一个问题：关于 yolo 的预测的 bbox 中心坐标是相对于 grid cell 左上角的偏移值, 不是直接预测而是预测偏移值。</em></p><p><em>但预测的 (x, y)可能为负数, 这样 (x, y) 就不在该 cell 中了——yolo v2 通过 (sigmoid(x), sigmoid(y)) 来解决这个问题.</em></p><h3 id="5-测试">5. 测试</h3><p>YOLO 的设计理念是让网络从全局视角预测目标，因此yolo 预测的是单元格的类别条件概率，而不是单独优化每个框的类别概率。单元格的类别条件概率可以理解为：</p><ul><li><strong>条件</strong>：在当前单元格中检测到物体。</li><li><strong>结果</strong>：该物体属于某个类别。</li></ul><p>因此，条件概率与预测框无直接关联，而是作为单元格整体预测的结果。这种设计减少了复杂性，并通过网络学习到更高效的特征分布。</p><p>最终测试的时候，条件类概率和<strong>每个框的预测的置信度值相乘得到每个框特定类别的置信度分数</strong>。这些分数体现了该类出现在框中的概率以及预测框拟合目标的程度。</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>P</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mtext>Class</mtext><mi mathvariant="normal">∣</mi><mtext>Object</mtext><mo stretchy="false">)</mo><mo>⋅</mo><msub><mi>P</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mtext>Object</mtext><mo stretchy="false">)</mo><mo>⋅</mo><msubsup><mtext>IOU</mtext><mtext>truth</mtext><mtext>pred</mtext></msubsup><mo>=</mo><msub><mi>P</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mtext>Class</mtext><mo stretchy="false">)</mo><mo>⋅</mo><msubsup><mtext>IOU</mtext><mtext>truth</mtext><mtext>pred</mtext></msubsup></mrow><annotation encoding="application/x-tex">P_r(\text{Class} | \text{Object}) \cdot P_r(\text{Object}) \cdot \text{IOU}_{\text{truth}}^{\text{pred}} = P_r(\text{Class}) \cdot \text{IOU}_{\text{truth}}^{\text{pred}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord">Class</span></span><span class="mord">∣</span><span class="mord text"><span class="mord">Object</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord">Object</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2683em;vertical-align:-0.3013em;"></span><span class="mord"><span class="mord text"><span class="mord">IOU</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.967em;"><span style="top:-2.3987em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">truth</span></span></span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">pred</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3013em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord">Class</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2683em;vertical-align:-0.3013em;"></span><span class="mord"><span class="mord text"><span class="mord">IOU</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.967em;"><span style="top:-2.3987em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">truth</span></span></span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">pred</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3013em;"><span></span></span></span></span></span></span></span></span></span></span></p><ul><li><strong>左侧</strong>表示：类别的条件概率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mtext>Class</mtext><mi mathvariant="normal">∣</mi><mtext>Object</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_r(\text{Class} | \text{Object})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord">Class</span></span><span class="mord">∣</span><span class="mord text"><span class="mord">Object</span></span><span class="mclose">)</span></span></span></span> 乘以单元格中存在物体的概率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mtext>Object</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_r(\text{Object})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord">Object</span></span><span class="mclose">)</span></span></span></span>，再结合边界框的准确性（IOU）。</li><li><strong>右侧</strong>是对左侧的简化结果：直接表示为类别概率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mtext>Class</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_r(\text{Class})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord">Class</span></span><span class="mclose">)</span></span></span></span> 和 IOU 的乘积。</li></ul><p><strong>个人理解：<strong>这个公式的乘积同时编码了</strong>预测框属于某类别的概率</strong>和<strong>预测框定位的准确性（IOU）</strong>。在后续处理中，可以根据计算得到的这些分数设置阈值，滤除低得分的预测框，然后对剩余的预测框应用 <strong>NMS（非极大值抑制）</strong>，去除重复框，最终保留下置信度高且定位准确的预测框，作为检测结果。</p><p><img src="/img/DeepLearning/YOLO/image-20250113161306397.png" alt=""></p><h2 id="总结">总结</h2><h3 id="优点">优点</h3><ol><li><strong>速度极快</strong><br>YOLO 将目标检测视为一个回归问题，大大简化了流程，避免了复杂的多阶段处理。在测试时，YOLO 只需对输入图像运行一次神经网络即可生成预测结果。在 Titan X GPU 上，基础版本的 YOLO 在不进行批处理的情况下，能够以 <strong>每秒 45 帧</strong> 的速度运行，具备实时处理能力。</li><li><strong>全局推断</strong><br>与基于滑动窗口或候选框的技术不同，YOLO 在训练和推断时都会考虑整个图像的上下文信息。这种全局视角使 YOLO 隐式学习到了类别之间的上下文关系和外观特征。因此，与 Fast R-CNN 相比，YOLO 在背景误检目标的情况下减少了一半的错误。</li><li><strong>泛化能力强</strong><br>YOLO 能够学习到目标的通用特征表征。例如，将在自然图像上训练的模型迁移到艺术图像上进行测试时，YOLO 的性能显著优于 DPM 和 R-CNN 等顶级检测方法。得益于其良好的泛化能力，YOLO 在面对新领域或意外输入时更稳定，发生故障的可能性更低。</li></ol><hr><h3 id="缺点">缺点</h3><ol><li><strong>准确率有所折扣</strong><br>虽然 YOLO 的速度快，但相比某些两阶段检测器（如 Faster R-CNN），其检测精度可能稍低，特别是在需要高精度检测的场景中。</li><li><strong>密集目标检测能力不足</strong><br>对于相互靠得很近的目标（如目标的中心点落在同一个网格单元内），YOLO 的检测效果较差，因为每个网格单元只能预测一个目标。这在处理包含大量目标的场景（如鸟群或畜群）时尤为明显——一个网格中可能包含多个目标，但 YOLO 只能检测出其中一个。</li></ol><h2 id="参考文献">参考文献</h2><ul><li><a href="https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Redmon_You_Only_Look_CVPR_2016_paper.pdf">https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Redmon_You_Only_Look_CVPR_2016_paper.pdf</a></li><li><a href="https://openaccess.thecvf.com/content_cvpr_2017/papers/Redmon_YOLO9000_Better_Faster_CVPR_2017_paper.pdf">https://openaccess.thecvf.com/content_cvpr_2017/papers/Redmon_YOLO9000_Better_Faster_CVPR_2017_paper.pdf</a></li><li><a href="https://zhuanlan.zhihu.com/p/564708049">https://zhuanlan.zhihu.com/p/564708049</a></li><li><a href="https://blog.csdn.net/DFCED/article/details/105157452">https://blog.csdn.net/DFCED/article/details/105157452</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>DeepLearning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepLearning</tag>
      
      <tag>OpenCV</tag>
      
      <tag>目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷】樱花——混合背包</title>
    <link href="/2025/01/12/OJ/BagDP/P1833/"/>
    <url>/2025/01/12/OJ/BagDP/P1833/</url>
    
    <content type="html"><![CDATA[<h1>樱花（混合背包）</h1><p><a href="https://www.luogu.com.cn/problem/P1833">题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">200</span>;<br><span class="hljs-type">int</span> t[maxn], c[maxn], p[maxn], f[maxn];<br><span class="hljs-type">int</span> a, b;<br><span class="hljs-type">char</span> ch;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> pre[<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span>; i++) &#123;<br>        cin &gt;&gt; a &gt;&gt; ch &gt;&gt; b;<br>        pre[cnt] = a*<span class="hljs-number">60</span>+b;<br>        cnt++;<br>    &#125;<br>    <span class="hljs-type">int</span> time = pre[<span class="hljs-number">2</span>] - pre[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// cout &lt;&lt; time &lt;&lt; endl;</span><br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; t[i] &gt;&gt; c[i] &gt;&gt; p[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">//混合背包</span><br>        <span class="hljs-keyword">if</span>(p[i] == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//完全背包</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = t[i] ; j &lt;= time ; j ++)<br>            f[j] = <span class="hljs-built_in">max</span>(f[j] , f[j-t[i]] + c[i]) ;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//01背包和多重背包</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= p[i] ; j ++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = time; l &gt;= t[i] ; l--) &#123;<br>        f[l] = <span class="hljs-built_in">max</span>(f[l], f[l-t[i]]+c[i]);<br>        &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[time];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
      <category>BagDP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷】滑雪——记忆化搜索</title>
    <link href="/2025/01/12/OJ/BagDP/P1434/"/>
    <url>/2025/01/12/OJ/BagDP/P1434/</url>
    
    <content type="html"><![CDATA[<h1>滑雪（记忆化搜索）</h1><p><a href="https://www.luogu.com.cn/problem/P1434">题目链接</a></p><h3 id="本题关键字：记忆化搜索。">本题关键字：记忆化搜索。</h3><p><strong>首先，这题为什么会想到记忆化？(知道的人直接跳过)</strong></p><p>在dfs每种情况是，可能这个点之前已经搜过了，没必要再去搜索了，因此不如存储记住，就没必要再去dfs了。</p><hr><p>本题的主要思路：</p><p><strong>1.先去想dfs怎么做：</strong></p><p>这题每个点出发有可能，所以我们每个点都要开始dfs，最后取他们的最大值。</p><p>dfs部分和类似的迷宫差不多,用两个数组表示4个方向：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dx</span>[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br><span class="hljs-attribute">dy</span>[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><p>改变方向直接xx=x+dx[i] , yy=y+dy[i]</p><p>接下来判断这个方向是否在地图范围内，即</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts">if(xx&gt;<span class="hljs-number">0</span>&amp;<span class="hljs-variable">&amp;xx</span><span class="hljs-params">&lt;=R&amp;<span class="hljs-variable">&amp;yy</span>&gt;</span><span class="hljs-number">0</span>&amp;<span class="hljs-variable">&amp;yy</span><span class="hljs-params">&lt;=C)</span><br></code></pre></td></tr></table></figure><p>当然还要判断这个点是否能滑到，也就是高度要前一个低：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">if(<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[xx]</span><span class="hljs-selector-attr">[yy]</span>&lt;<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[x]</span><span class="hljs-selector-attr">[y]</span>)//<span class="hljs-selector-tag">a</span>为高度<br></code></pre></td></tr></table></figure><p>很明显，因为低的不可能滑向高的，所以我们不需要再开一个数组去记录这个点是否走过。</p><p>接下来，就要往四个方向搜索，取四个方向中距离最长的，然后+1，这就是这个点的结果了。</p><p><strong>2.记忆化搜索怎么写</strong></p><p>很显然，直接dfs会TLE。那么就需要记忆化来优化。</p><p>用s[i][j]表示从(i,j)点出发能走的最长距离。</p><p>每次搜索一次记忆一次即可。</p><p>下面给刚接触不怎么明白的人举例：(已经理解的人跳过)</p><p>由于样例不好讲我自己举例子：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>先去找(1,1)的最长距离，很明显为1</p><p>接着找(1,2)的最长距离，很明显为1</p><p>接着找(1,3)的最长距离，为2((1,3)-&gt;(1,2))</p><p>然后找(2,1)的最长距离，为2((2,1)-&gt;(1,1))</p><p>然后是(2,2)的最长距离，如果没有记忆化，那么搜索过程为：(2,2)-&gt;(2,1)-&gt;(1,1)</p><p>但是（2,1）之前已经搜过了，再去搜就是浪费时间，之前搜索已经知道(2,1)的值为2，那么搜索过程就是缩短为：(2,2)-&gt;(2,1),即为3</p><p><strong>附上代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">101</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> a[maxn][maxn], s[maxn][maxn];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(s[x][y]) <span class="hljs-keyword">return</span> s[x][y];  <span class="hljs-comment">//记忆化搜索</span><br>    s[x][y] = <span class="hljs-number">1</span>; <span class="hljs-comment">//题目答案是有包含这个点的</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        <span class="hljs-type">int</span> xx = dx[i] + x;<br>        <span class="hljs-type">int</span> yy = dy[i] + y; <span class="hljs-comment">//四个方向</span><br>        <span class="hljs-keyword">if</span>(xx &gt; <span class="hljs-number">0</span> &amp;&amp; yy &gt; <span class="hljs-number">0</span> &amp;&amp; xx &lt;= n &amp;&amp; yy &lt;= m &amp;&amp; a[x][y] &gt; a[xx][yy]) &#123;<br>            <span class="hljs-built_in">dfs</span>(xx, yy);<br>            s[x][y] = <span class="hljs-built_in">max</span>(s[x][y], s[xx][yy]<span class="hljs-number">+1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s[x][y];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            cin &gt;&gt; a[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">//找从每个出发的最长距离</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">dfs</span>(i, j)); <span class="hljs-comment">//取最大值</span><br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
      <category>BagDP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷】5倍经验日——01背包变形</title>
    <link href="/2025/01/12/OJ/BagDP/P1082/"/>
    <url>/2025/01/12/OJ/BagDP/P1082/</url>
    
    <content type="html"><![CDATA[<h1>5倍经验日（01背包变形）</h1><p><a href="https://www.luogu.com.cn/problem/P1802">题目链接</a></p><p><strong>思路：</strong></p><p>​当i &gt;= use时，可以选择打败或者不打败</p><p>​f [i] = max( f [i] + lose, f [i-use] + win )。</p><p>​当i &lt; use时，无法战胜对方。</p><p>​f [i] += lose</p><p>​至于数据范围，最后输出时强制转换一下就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1100</span>;<br><span class="hljs-type">int</span> win[maxn], lose[maxn], use[maxn], f[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, x;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;x);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, lose+i, win+i, use+i);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = x; l &gt;= use[i]; l--)<br>            f[l] = <span class="hljs-built_in">max</span>(f[l]+lose[i], f[l-use[i]]+win[i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = use[i]<span class="hljs-number">-1</span>; l &gt;= <span class="hljs-number">0</span>; l--) &#123;<br>            f[l] += lose[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, <span class="hljs-number">5</span>*f[x]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
      <category>BagDP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷】采药——背包dp</title>
    <link href="/2025/01/12/OJ/BagDP/P1048/"/>
    <url>/2025/01/12/OJ/BagDP/P1048/</url>
    
    <content type="html"><![CDATA[<h1>采药（背包dp）</h1><p><a href="https://www.luogu.com.cn/problem/P1048">题目链接</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> T, M;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1001</span>;<br><span class="hljs-type">int</span> t[maxn], m[maxn];<br><span class="hljs-type">int</span> f[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; T &gt;&gt; M;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= M; i++) &#123;<br>        cin &gt;&gt; t[i] &gt;&gt; m[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= M; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = T; l &gt;= t[i]; l--) &#123;<br>        <span class="hljs-keyword">if</span>(f[l-t[i]] + m[i] &gt; f[l])<br>        f[l] = f[l-t[i]] + m[i]; <span class="hljs-comment">//状态方程</span><br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[T];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
      <category>BagDP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷】挖地雷——DP顺推</title>
    <link href="/2025/01/12/OJ/BagDP/P2196/"/>
    <url>/2025/01/12/OJ/BagDP/P2196/</url>
    
    <content type="html"><![CDATA[<h1>挖地雷</h1><p><a href="https://www.luogu.com.cn/problem/P2196">题目链接</a></p><p>定义状态 <code>f[i]</code> 为以第 <code>i</code> 个节点结束的最大值，则：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><mo>+</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f[i] = max{f[j]} + a[i] (g[j][i] = 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><p>最后用一个 <code>pre[i]</code> 数组存储前驱节点，递归输出即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, t, ans;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">201</span>;<br><span class="hljs-type">int</span> a[maxn];<br><span class="hljs-type">int</span> mp[maxn][maxn];<br><span class="hljs-type">int</span> f[maxn], pre[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(pre[x] == <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; x;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">print</span>(pre[x]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin &gt;&gt; x;<br>            <span class="hljs-keyword">if</span>(x == <span class="hljs-number">1</span>) <br>                mp[i][j] = x;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span>(mp[j][i] &amp;&amp; f[j] &gt; f[i]) &#123;<br>                f[i] = f[j];<br>                pre[i] = j;<br>            &#125;<br>        &#125;<br>        f[i] += a[i];<br>        <span class="hljs-keyword">if</span>(f[i] &gt; ans) &#123;<br>            ans = f[i];<br>            t = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">print</span>(t);<br>    cout &lt;&lt; endl;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
      <category>BagDP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机视觉】多目标追踪——SORT &amp; DeepSORT</title>
    <link href="/2025/01/12/DeepLearning/Sort_DeepSort/"/>
    <url>/2025/01/12/DeepLearning/Sort_DeepSort/</url>
    
    <content type="html"><![CDATA[<h1>SORT &amp; DeepSORT</h1><h2 id="一、SORT-介绍">一、SORT 介绍</h2><p>SORT（Simple Online and Realtime Tracking）是一种轻量级的多目标追踪算法，旨在在实时视频流中高效追踪多个目标。它基于两大核心技术：</p><ol><li><a href="https://laojiao1.github.io/2025/01/09/DeepLearning/kalman/">卡尔曼滤波器</a>：用于对每个目标的状态（位置和速度）进行估计和预测，以应对目标的移动。</li><li><a href="https://laojiao1.github.io/2025/01/10/DeepLearning/Hungarian/">匈牙利算法</a>：用于解决目标匹配问题，即在每一帧图像中，确定哪些检测框与上一帧的目标进行匹配。</li></ol><p>SORT 算法的核心思想是通过结合<strong>目标检测</strong>和<strong>运动预测</strong>来实现<strong>多目标追踪</strong>。首先，利用目标检测器（如Faster R-CNN）在每一帧图像中检测目标的边界框。接下来，通过卡尔曼滤波器对目标的运动进行建模和预测。卡尔曼滤波器结合当前目标状态和运动模型，预测目标在下一帧中的位置和速度。为了在不同帧之间建立目标的关联，SORT引入了基于<strong>匈牙利算法</strong>的数据关联方法。该方法通过最小化代价（如IOU距离）来匹配当前帧中的目标与先前帧中的已跟踪目标，从而确保每个目标的身份和轨迹得到正确追踪。</p><h2 id="二、SORT-目标追踪算法">二、SORT 目标追踪算法</h2><h3 id="1-SORT-初始框">1. SORT 初始框</h3><p>在单目标跟踪中，初始框通常是由人工手动框定的。而在多目标跟踪中，初始框是通过目标检测器自动生成的，避免了人工初始化的过程。SORT算法基于这种目标检测机制，利用<strong>Faster R-CNN</strong>作为检测器。Faster R-CNN是一个端到端的两阶段检测框架：第一阶段负责提取图像特征并生成候选区域，第二阶段则在这些候选区域中对目标进行分类和边界框回归。</p><p><img src="/img/DeepLearning/Sort_DeepSort/c1097403f1aa5f102addd3898b556d1.png" alt="Faster R-CNN网络"></p><p>该框架的一个重要优势是，在两个阶段之间共享参数，从而提高了检测效率。此外，由于其网络架构可以灵活地替换和调整，Faster R-CNN能够快速测试不同设计，优化检测性能。通过结合Faster R-CNN，SORT能够实现高效的目标检测和准确的目标跟踪。</p><h3 id="2-SORT-工作流程">2. SORT 工作流程</h3><p>SORT的工作流程是：首先，使用卡尔曼滤波器对目标进行预测；然后，通过匈牙利算法进行数据关联，将预测结果与当前帧中的检测结果匹配；最后，对未匹配的目标进行处理（通常是新目标的加入或丢失目标的删除）。</p><p><strong>关键步骤：<strong>轨迹卡尔曼滤波</strong>预测</strong>→ 使用<strong>匈牙利算法</strong>将预测后的tracks和当前帧中的detecions进行匹配（<strong>IOU匹配</strong>） → 卡尔曼滤波<strong>更新</strong></p><p><img src="/img/DeepLearning/Sort_DeepSort/image-20200430001731416.png" alt="SORT工作流程"></p><ul><li><strong>卡尔曼滤波</strong>包括两个步骤：<strong>预测</strong>和<strong>更新</strong>。在SORT中，通过引入线性速度模型，卡尔曼滤波用于对目标的位置进行<strong>预测</strong>，即先估计目标的未来位置，然后再进行目标匹配。运动模型提供了目标位置的预测信息，用于帮助追踪过程中更准确地估计物体的运动轨迹。</li><li><strong>匈牙利算法</strong>用于解决<strong>分配问题</strong>，其核心是通过计算每对目标框之间的<strong>IOU</strong>（Intersection over Union）值来构建一个代价矩阵。IOU越大，表示两个目标框之间的重合度越高，匹配的可能性越大。当IOU低于一个设定阈值（通常为0.3）时，认为这两个框不属于同一个目标，从而避免错误匹配。</li></ul><h3 id="3-SORT的运动模型">3. SORT的运动模型</h3><p>SORT算法通过为每个目标定义一个对象模型，将目标的身份和运动状态从当前帧传播到下一帧。为了简化计算，SORT使用了一个线性恒速模型来近似每个目标的帧间位移，这个模型假设目标在每帧之间的位移是恒定的，与其他物体和摄像机的运动无关。</p><p>目标的完整状态向量为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">x</mi><mo>=</mo><mo stretchy="false">[</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>s</mi><mo separator="true">,</mo><mi>r</mi><mo separator="true">,</mo><mover accent="true"><mi>u</mi><mo>˙</mo></mover><mo separator="true">,</mo><mover accent="true"><mi>v</mi><mo>˙</mo></mover><mo separator="true">,</mo><mover accent="true"><mi>s</mi><mo>˙</mo></mover><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathbf{x} = [u, v, s, r, \dot{u}, \dot{v}, \dot{s}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">u</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">˙</span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">˙</span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">s</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.0833em;"><span class="mord">˙</span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span></p><p>其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>：目标中心位置的坐标（通常为 x 和 y）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>：目标的尺度（通常是目标框的面积）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>：目标的纵横比（aspect ratio）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>u</mi><mo>˙</mo></mover></mrow><annotation encoding="application/x-tex">\dot{u}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">u</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">˙</span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>v</mi><mo>˙</mo></mover></mrow><annotation encoding="application/x-tex">\dot{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">˙</span></span></span></span></span></span></span></span></span></span>：目标在 u 和 v 方向上的速度。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>s</mi><mo>˙</mo></mover></mrow><annotation encoding="application/x-tex">\dot{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">s</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.0833em;"><span class="mord">˙</span></span></span></span></span></span></span></span></span></span>：目标尺度的变化速率。</li></ul><p>SORT算法具有较低的计算复杂度，适合实时追踪，但由于它仅基于目标的运动信息（位置和速度），对目标间的遮挡、外观变化、长时间丢失等情况的鲁棒性较差。</p><p>为了提升跟踪的精度和鲁棒性，<strong>DeepSORT</strong> 应运而生——通过结合深度学习特征和传统的运动预测模型，DeepSORT不仅能够有效解决目标间的相似性判别问题，还能显著增强目标在长时间遮挡或交叉运动中的追踪稳定性。</p><h2 id="三、DeepSORT">三、DeepSORT</h2><h3 id="1-DeepSORT-介绍">1. DeepSORT 介绍</h3><p><strong>DeepSORT</strong>（Deep Learning-based SORT）是基于SORT（Simple Online and Realtime Tracking）算法的改进版，整体框架延续了 SORT 的核心思路，仍然采用了 <strong>卡尔曼滤波</strong> 和 <strong>匈牙利算法</strong> 进行目标的运动预测和数据关联。然而，DeepSORT 在此基础上引入了一个关键改进：<strong>鉴别网络（Deep Association Metric）</strong>，用于增强目标之间的匹配精度。</p><h3 id="2-DeepSORT-算法">2. DeepSORT 算法</h3><h4 id="DeepSORT-关键工作流程">- DeepSORT 关键工作流程</h4><ol><li><p><strong>轨迹卡尔曼滤波预测</strong>：</p><ul><li>对于每个已追踪的目标，卡尔曼滤波器会基于目标的当前位置和速度，预测目标在当前帧中的位置。这一过程是根据目标的运动模型（例如线性恒速模型）进行的，主要用于估计目标在下一帧的可能位置。</li></ul></li><li><p><strong>使用匈牙利算法进行匹配</strong>：</p><ul><li><p>匈牙利算法用于解决目标匹配问题，将</p><p>预测后的目标轨迹tracked targets）与 当前帧中的检测框（detections）进行匹配。这里的匹配通常通过两种方式进行：</p><ul><li><strong>级联匹配</strong>（Cascade Matching）：首先进行粗匹配，然后逐步精细化，确保每个目标的匹配都是最合适的。</li><li><strong>IOU匹配</strong>（Intersection over Union matching）：通过计算目标边界框与检测框之间的 <strong>IOU</strong> 值，匹配预测轨迹和当前帧中的检测目标。IOU值较高的目标会被认为是同一个目标，从而进行匹配。</li></ul></li></ul></li><li><p><strong>卡尔曼滤波更新</strong>：</p><ul><li>在目标匹配后，卡尔曼滤波器会根据匹配结果对目标的状态进行 <strong>更新</strong>。这一步会根据实际检测到的目标位置来修正预测轨迹，从而提高追踪的准确性。</li></ul></li></ol><p>流程图如下：</p><p><img src="/img/DeepLearning/Sort_DeepSort/image-20200430003426746.png" alt="DeepSort工作流程"></p><h4 id="级联匹配流程">- 级联匹配流程</h4><p>这个流程是DeepSORT多目标跟踪算法中确保目标准确匹配的重要步骤</p><ol><li><p><strong>距离计算</strong>：</p><ul><li><p>使用 <strong>马氏距离（Mahalanobis Distance, d1）</strong> 和 <strong>余弦距离（Cosine Distance, d2）</strong>，通过线性加权方式生成 <strong>代价矩阵（Cost Matrix）</strong>：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo>=</mo><mi>λ</mi><msub><mi>d</mi><mn>1</mn></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>λ</mi><mo stretchy="false">)</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C= \lambda d_1 + (1 - \lambda) d_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">λ</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p></li><li><p><strong>马氏距离</strong> 表示运动模型的匹配程度，衡量预测轨迹与检测框之间的一致性</p></li><li><p><strong>余弦距离</strong> 衡量外观特征的相似性，判断目标外观的一致性</p></li></ul></li><li><p><strong>门限限制（Gate Matrix）</strong>：</p><ul><li>引入一个 <strong>门限（gating_threshold）</strong> 来过滤掉不可能的匹配结果，生成 <strong>Gate Matrix</strong>，将代价矩阵中超过最大距离（<strong>max_distance</strong>）的匹配关系剔除，减少误匹配</li></ul></li><li><p><strong>匈牙利算法（Hungarian Algorithm）进行分配</strong>：</p><ul><li>根据生成的代价矩阵，使用 <strong>匈牙利算法</strong> 在当前帧中的检测结果和轨迹之间进行匹配</li></ul></li><li><p><strong>级联匹配</strong>：</p><ul><li>以目标轨迹的 <strong>age（年龄）</strong> 为顺序，优先匹配 <strong>missing age = 0</strong>（即刚更新过的轨迹）对应的检测框，确保更新最频繁的目标优先匹配</li><li>如果有轨迹未匹配成功，其 <strong>missing age</strong> 加1，继续尝试匹配，直到达到最大允许丢失帧数（<strong>max_age</strong>）</li><li>重复该过程直至所有检测和轨迹匹配完成</li></ul></li><li><p><strong>输出结果</strong>：</p><ul><li>返回已匹配的轨迹集合和未匹配的检测集合，用于更新目标状态或初始化新的目标轨迹</li></ul></li></ol><p>流程图如下：</p><p><img src="/img/DeepLearning/Sort_DeepSort/image-20200430004523485.png" alt="级联匹配"></p><h2 id="四、代码实现">四、代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># SORT多目标追踪</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sort</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, max_age = <span class="hljs-number">1</span>, min_hits = <span class="hljs-number">3</span></span>):<br>        <span class="hljs-comment"># 最大跟踪次数</span><br>        <span class="hljs-variable language_">self</span>.max_age = max_age<br>        <span class="hljs-comment"># 最小命中次数</span><br>        <span class="hljs-variable language_">self</span>.min_hits = min_hits<br>        <span class="hljs-comment"># 跟踪框</span><br>        <span class="hljs-variable language_">self</span>.trackers = []<br>        <span class="hljs-comment"># 帧数</span><br>        <span class="hljs-variable language_">self</span>.frame_count = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self, dets</span>):<br>        <span class="hljs-comment"># 记录状态异常的跟踪器索引</span><br>        <span class="hljs-variable language_">self</span>.frame_count = <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 根据当前所有的卡尔曼跟踪器个数（即上一帧中跟踪的目标个数）创建二维数组</span><br>        <span class="hljs-comment"># 存储器跟踪预测treks</span><br>        treks = np.zeros((<span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.trackers), <span class="hljs-number">5</span>))<br>        to_del = [] <span class="hljs-comment"># 要删除的目标框</span><br>        ret = [] <span class="hljs-comment"># 存储要返回的追踪目标框</span><br>        <span class="hljs-comment"># 循环遍历卡尔曼滤波器t产生的对应目标的跟踪框</span><br>        <span class="hljs-keyword">for</span> t, trk <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(treks):<br>            <span class="hljs-comment"># 更新跟踪器的状态</span><br>            pos = <span class="hljs-variable language_">self</span>.trackers[t].predict()[<span class="hljs-number">0</span>]<br>            trk[:] = [pos[<span class="hljs-number">0</span>], pos[<span class="hljs-number">1</span>], pos[<span class="hljs-number">2</span>], pos[<span class="hljs-number">3</span>], <span class="hljs-number">0</span>]<br>            <span class="hljs-comment"># 若跟踪器的跟踪次数大于最大跟踪次数，则删除</span><br>            <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">any</span>(np.isnan(pos)):<br>                to_del.append(t)<br>        <span class="hljs-comment"># 删除跟踪器</span><br>        treks = np.ma.compress_rows(np.ma.masked_invalid(treks))<br>        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(to_del):<br>            <span class="hljs-variable language_">self</span>.trackers.pop(t)<br>        <span class="hljs-comment"># 检测框数</span><br>        matched, unmatched_dets, unmatched_trks = associate_detections_to_trackers(dets, treks)<br><br>        <span class="hljs-comment"># 更新跟踪器状态</span><br>        <span class="hljs-keyword">for</span> t, trk <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-variable language_">self</span>.trackers):<br>            <span class="hljs-keyword">if</span> t <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> unmatched_trks:<br>                d = matched[np.where(matched[:, <span class="hljs-number">1</span>] == t)[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>]<br>                trk.update(dets[d, :][<span class="hljs-number">0</span>])<br><br>        <span class="hljs-comment"># 新的跟踪器</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> unmatched_dets:<br>            trk = KalmanBoxTracker(dets[i, :])<br>            <span class="hljs-variable language_">self</span>.trackers.append(trk)<br><br>        i = <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.trackers)<br>        <span class="hljs-keyword">for</span> trk <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(<span class="hljs-variable language_">self</span>.trackers):<br>            d = trk.get_state()[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">if</span> (trk.time_since_update &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">and</span> (trk.hit_streak &gt;= <span class="hljs-variable language_">self</span>.min_hits <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span>.frame_count &lt;= <span class="hljs-variable language_">self</span>.min_hits):<br>                ret.append(np.concatenate((d, [trk.<span class="hljs-built_in">id</span>+<span class="hljs-number">1</span>])).reshape(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>))<br>            i -= <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 跟踪失败或离开画面的目标从卡尔曼跟踪器中删除</span><br>            <span class="hljs-keyword">if</span> trk.time_since_update &gt; <span class="hljs-variable language_">self</span>.max_age:<br>                <span class="hljs-variable language_">self</span>.trackers.pop(i)<br><br>        <span class="hljs-comment"># 返回当前画面中所有目标的box与id</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ret) &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> np.concatenate(ret)<br>        <span class="hljs-keyword">return</span> np.empty((<span class="hljs-number">0</span>, <span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><h2 id="五、总结">五、总结</h2><h3 id="1-SORT算法">1. <strong>SORT算法</strong></h3><p>SORT（Simple Online and Realtime Tracking）是一种轻量级且高效的多目标跟踪算法，它依赖于强大的目标检测器（如Faster R-CNN）提供检测框，通过结合 <strong>卡尔曼滤波</strong> 和 <strong>匈牙利算法</strong> 实现目标的实时跟踪。</p><ul><li><strong>卡尔曼滤波</strong>：用于预测目标在下一帧的位置，通过运动模型更新目标状态。</li><li><strong>匈牙利算法</strong>：解决目标匹配问题，将检测框和预测轨迹进行关联。</li></ul><p>虽然SORT算法简单高效，但在目标遮挡、密集场景以及外观相似的目标之间容易出现错误匹配。</p><h3 id="2-DeepSORT算法">2. <strong>DeepSORT算法</strong></h3><p>DeepSORT是SORT算法的改进版本，在保持高效性的同时，提升了多目标跟踪的准确性和鲁棒性。主要改进包括：</p><ol><li><strong>增加了级联匹配</strong>：通过优先匹配更新频繁的轨迹（即轨迹“年龄”较小的目标），减少了误匹配和目标丢失。</li><li><strong>引入目标确认机制</strong>：增加了“确认状态”（Confirmed Tracks）的概念，只有经过多帧匹配的目标才会被确认，从而避免短时噪声目标干扰。</li><li><strong>深度外观特征的融合</strong>：引入深度学习提取的外观特征（Deep Association Metric），结合马氏距离和余弦距离来优化匹配过程，大幅提高了在目标遮挡或外观相似情况下的跟踪效果。</li></ol><ul><li><strong>卡尔曼滤波 + 匈牙利算法</strong>：依然是跟踪的基础框架，用于处理运动状态的预测和检测框的匹配。</li></ul><h3 id="参考文献">参考文献</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/59148865">https://zhuanlan.zhihu.com/p/59148865</a></li><li><a href="https://zhuanlan.zhihu.com/p/646154999">https://zhuanlan.zhihu.com/p/646154999</a></li><li><a href="https://blog.csdn.net/zimiao552147572/article/details/106009021">https://blog.csdn.net/zimiao552147572/article/details/106009021</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>DeepLearning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepLearning</tag>
      
      <tag>OpenCV</tag>
      
      <tag>目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】AES-数据库加密算法</title>
    <link href="/2025/01/11/algorithm/SqlEncryption/"/>
    <url>/2025/01/11/algorithm/SqlEncryption/</url>
    
    <content type="html"><![CDATA[<h1>数据库信息加密</h1><p>​为了保障三方用户的个人隐私，防止信息泄露，我们采用了高级加密标准（AES，Advanced Encryption Standard）为最常见的对称加密算法，并利用java自带软件包javax.crypto 对数据库中的信息进行加密。该加密算法的具体流程如下：</p><p><img src="/img/algorithm/SqlEncryption/image-20250111204228629.png" alt="AES加密流程"></p><h2 id="一，AES的数据结构">一，AES的数据结构</h2><p>​加密解密算法的输入是一个128位分组。这些分组被描述成4×4的字节方阵，这个分组被复制到state数组中，并在加密和解密的每一阶段都被修改。在字节方阵中，每一格都是一个字，包含了4字节。在矩阵中字是按列排序的。</p><p><img src="/img/algorithm/SqlEncryption/image-20250111204236830.png" alt="AES的数据结构"></p><h2 id="二，AES加密过程：">二，AES加密过程：</h2><p>​我们采用明文长度固定128位，密钥长度128位。首先将前端传输过来的字符串信息转换成byte位（明文），将该明文转换为一个4×4的矩阵，和给定初始的子密钥进行异或得到变换矩阵。接着将该变换矩阵进行字节代换，行移位，列混合，轮密钥加，如此循环9次后跳出，在第10次循环（即最后一次循环中）只进行字节代换，行移位，轮密钥加得到最终矩阵，该矩阵即为密文。</p><p><img src="/img/algorithm/SqlEncryption/image-20250111204241908.png" alt="AES加密过程"></p><h2 id="三，加密的详细结构">三，加密的详细结构</h2><h3 id="1-字节代换（SubBytes）">1.字节代换（SubBytes）</h3><p>通过S-BOX查表进行字节的代换。</p><p><img src="https://pic1.zhimg.com/80/v2-e160744c78b680b008c165cb78841858_1440w.webp" alt="S-BOX表"></p><p>​加密图示：</p><p><img src="https://pic1.zhimg.com/80/v2-83b41eb29d3e797bafdc4d669365bf5c_1440w.webp" alt="加密图示"></p><h3 id="2-行移位（ShiftRows）">2.行移位（ShiftRows）</h3><p><img src="/img/algorithm/SqlEncryption/image-20250111204259284.png" alt="行移位"></p><h3 id="3-列混合（MixColumns）">3.列混合（MixColumns）</h3><p>​列混合变换是通过矩阵相乘来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图的公式所示：</p><p><img src="/img/algorithm/SqlEncryption/image-20250111204303699.png" alt="列混合"></p><p>​状态矩阵中的第j列(0 ≤j≤3)的列混合可以表示为下图所示：</p><p><img src="/img/algorithm/SqlEncryption/image-20250111204308063.png" alt="状态矩阵的第j列"></p><p>​注意：矩阵元素的乘法和加法都是定义在基于GF(2^8)上的二元运算，并不是通常意义上的乘法和加法。具体运算规则为：</p><p><img src="/img/algorithm/SqlEncryption/image-20250111204314508.png" alt="具体运算规则"></p><h3 id="4-轮密钥加（AddRoundKey）">4.轮密钥加（AddRoundKey）</h3><p>​轮密钥加是将128位轮密钥同状态矩阵中的数据进行逐位异或操作。</p><p>​例如：对于该密钥矩阵和状态矩阵进行操作</p><p><img src="/img/algorithm/SqlEncryption/1.png" alt="轮密钥加"></p><p>​由于会进行10轮循环，因此密钥需要进行扩展。</p><p>​<strong>密钥扩展过程：</strong></p><p>​设要求的列为Wi。</p><p>​考虑在求Wi时根据i是否为4的倍数：</p><ol><li><p>若i不是4的倍数，那么第i列由如下等式确定：<strong>W[i] = W[i-4] ⊕ W[i-1]</strong></p></li><li><p>如果i是4的倍数，那么第i列由如下等式确定：<strong>W[i] = W[i-4] ⊕ T(W[i-1])</strong></p></li></ol><p>​<strong>T函数的求解：</strong></p><ul><li><p><strong>字循环</strong>：将1个字中的4个字节循环左移1的字节。即将输入字[b0, b1, b2, b3]变换成[b1, b2, b3, b0]。</p></li><li><p><strong>字节代换</strong>：对字的循环结果使用S-BOX进行字节代换</p></li><li><p><strong>轮常量异或</strong>：将前两步的结果同轮常量Rcon[j]进行异或，其中j表示轮数。</p><p><img src="/img/algorithm/SqlEncryption/image-20250111204321128.png" alt="Rcon矩阵"></p></li></ul><h2 id="四、代码演示">四、代码演示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 常量 S-Box 和反向 S-Box</span><br>SBox = [<br>    <span class="hljs-comment"># 0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F</span><br>    [<span class="hljs-number">0x63</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0x7B</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0x6B</span>, <span class="hljs-number">0x6F</span>, <span class="hljs-number">0xC5</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0x2B</span>, <span class="hljs-number">0xFE</span>, <span class="hljs-number">0xD7</span>, <span class="hljs-number">0xAB</span>, <span class="hljs-number">0x76</span>],<br>    [<span class="hljs-number">0xCA</span>, <span class="hljs-number">0x82</span>, <span class="hljs-number">0xC9</span>, <span class="hljs-number">0x7D</span>, <span class="hljs-number">0xFA</span>, <span class="hljs-number">0x59</span>, <span class="hljs-number">0x47</span>, <span class="hljs-number">0xF0</span>, <span class="hljs-number">0xAD</span>, <span class="hljs-number">0xD4</span>, <span class="hljs-number">0xA2</span>, <span class="hljs-number">0xAF</span>, <span class="hljs-number">0x9C</span>, <span class="hljs-number">0xA8</span>, <span class="hljs-number">0x51</span>, <span class="hljs-number">0xA3</span>],<br>    [<span class="hljs-number">0x40</span>, <span class="hljs-number">0x8F</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0x9D</span>, <span class="hljs-number">0x38</span>, <span class="hljs-number">0xF5</span>, <span class="hljs-number">0xBC</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0xDA</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xF3</span>, <span class="hljs-number">0xD2</span>, <span class="hljs-number">0xCD</span>, <span class="hljs-number">0x0C</span>],<br>    [<span class="hljs-number">0x13</span>, <span class="hljs-number">0xEC</span>, <span class="hljs-number">0x5F</span>, <span class="hljs-number">0x97</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0xC4</span>, <span class="hljs-number">0xA5</span>, <span class="hljs-number">0xE3</span>, <span class="hljs-number">0xF6</span>, <span class="hljs-number">0x84</span>, <span class="hljs-number">0x9A</span>, <span class="hljs-number">0x7E</span>, <span class="hljs-number">0x3D</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x5D</span>],<br>    [<span class="hljs-number">0x19</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x60</span>, <span class="hljs-number">0x81</span>, <span class="hljs-number">0x4F</span>, <span class="hljs-number">0xDC</span>, <span class="hljs-number">0x22</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0xEE</span>, <span class="hljs-number">0xB8</span>, <span class="hljs-number">0x14</span>, <span class="hljs-number">0xDE</span>, <span class="hljs-number">0x5E</span>],<br>    [<span class="hljs-number">0x0B</span>, <span class="hljs-number">0xDB</span>, <span class="hljs-number">0xE0</span>, <span class="hljs-number">0x32</span>, <span class="hljs-number">0x3A</span>, <span class="hljs-number">0x0A</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0xC2</span>, <span class="hljs-number">0xD3</span>, <span class="hljs-number">0xAC</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0x95</span>],<br>    [<span class="hljs-number">0x0F</span>, <span class="hljs-number">0x37</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x3F</span>, <span class="hljs-number">0xF7</span>, <span class="hljs-number">0xCC</span>, <span class="hljs-number">0x34</span>, <span class="hljs-number">0xA0</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0xB5</span>, <span class="hljs-number">0x6E</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x8D</span>],<br>    [<span class="hljs-number">0x90</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x97</span>, <span class="hljs-number">0xB1</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xA9</span>, <span class="hljs-number">0xD2</span>, <span class="hljs-number">0x6F</span>, <span class="hljs-number">0x7A</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x99</span>, <span class="hljs-number">0x7D</span>, <span class="hljs-number">0x6B</span>, <span class="hljs-number">0x90</span>]<br>]<br><br><span class="hljs-comment"># 乘法常量矩阵用于 MixColumns</span><br>MixColumnsMatrix = [<br>    [<span class="hljs-number">0x02</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x01</span>],<br>    [<span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x01</span>],<br>    [<span class="hljs-number">0x01</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x03</span>],<br>    [<span class="hljs-number">0x03</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>]<br>]<br><br><span class="hljs-comment"># 字节替换 (SubBytes) 变换</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sub_bytes</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> [[SBox[(state[i][j] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0F</span>][state[i][j] &amp; <span class="hljs-number">0x0F</span>] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]<br><br><span class="hljs-comment"># 行移位 (ShiftRows) 变换</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">shift_rows</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):<br>        state[i] = state[i][i:] + state[i][:i]  <span class="hljs-comment"># 左移 i 位</span><br>    <span class="hljs-keyword">return</span> state<br><br><span class="hljs-comment"># 列混合 (MixColumns) 变换</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mix_columns</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gmul</span>(<span class="hljs-params">a, b</span>):<br>        p = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> a &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> a &amp; <span class="hljs-number">0x01</span>:<br>                p ^= b<br>            a &gt;&gt;= <span class="hljs-number">1</span><br>            b = (b &lt;&lt; <span class="hljs-number">1</span>) ^ (<span class="hljs-number">0x11B</span> <span class="hljs-keyword">if</span> b &amp; <span class="hljs-number">0x80</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> p<br><br>    new_state = [[<span class="hljs-number">0</span>] * <span class="hljs-number">4</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>            new_state[i][j] = gmul(state[i][<span class="hljs-number">0</span>], MixColumnsMatrix[j][<span class="hljs-number">0</span>]) ^ \<br>                              gmul(state[i][<span class="hljs-number">1</span>], MixColumnsMatrix[j][<span class="hljs-number">1</span>]) ^ \<br>                              gmul(state[i][<span class="hljs-number">2</span>], MixColumnsMatrix[j][<span class="hljs-number">2</span>]) ^ \<br>                              gmul(state[i][<span class="hljs-number">3</span>], MixColumnsMatrix[j][<span class="hljs-number">3</span>])<br>    <span class="hljs-keyword">return</span> new_state<br><br><span class="hljs-comment"># 轮密钥加 (AddRoundKey)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_round_key</span>(<span class="hljs-params">state, round_key</span>):<br>    <span class="hljs-keyword">return</span> [[state[i][j] ^ round_key[i][j] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]<br><br><span class="hljs-comment"># 密钥扩展（从原始密钥生成多个轮密钥）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">key_expansion</span>(<span class="hljs-params">key</span>):<br>    Rcon = [<span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x1B</span>, <span class="hljs-number">0x36</span>]<br>    round_keys = [[key[i + <span class="hljs-number">4</span> * j] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(round_keys) &lt; <span class="hljs-number">44</span>:  <span class="hljs-comment"># AES-128 使用 44 个字</span><br>        temp = round_keys[-<span class="hljs-number">1</span>]<br>        temp = [SBox[(temp[<span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0F</span>][temp[<span class="hljs-number">1</span>] &amp; <span class="hljs-number">0x0F</span>], <br>                SBox[(temp[<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0F</span>][temp[<span class="hljs-number">2</span>] &amp; <span class="hljs-number">0x0F</span>], <br>                SBox[(temp[<span class="hljs-number">3</span>] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0F</span>][temp[<span class="hljs-number">3</span>] &amp; <span class="hljs-number">0x0F</span>], <br>                SBox[(temp[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0F</span>][temp[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x0F</span>]]<br><br>        temp[<span class="hljs-number">0</span>] ^= Rcon[<span class="hljs-built_in">len</span>(round_keys) // <span class="hljs-number">4</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>            round_keys.append([round_keys[<span class="hljs-built_in">len</span>(round_keys) - <span class="hljs-number">4</span>][i] ^ temp[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)])<br><br>    <span class="hljs-keyword">return</span> round_keys<br><br><span class="hljs-comment"># 完整的 AES 加密过程</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">AES_encrypt</span>(<span class="hljs-params">plain_text, key</span>):<br>    state = [[plain_text[i + <span class="hljs-number">4</span> * j] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]<br>    round_keys = key_expansion(key)<br>    <br>    state = add_round_key(state, round_keys[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 初始轮</span><br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">round</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):  <span class="hljs-comment"># 9 轮</span><br>        state = sub_bytes(state)<br>        state = shift_rows(state)<br>        state = mix_columns(state)<br>        state = add_round_key(state, round_keys[<span class="hljs-built_in">round</span>])<br>    <br>    <span class="hljs-comment"># 最后一轮，没有 MixColumns</span><br>    state = sub_bytes(state)<br>    state = shift_rows(state)<br>    state = add_round_key(state, round_keys[<span class="hljs-number">10</span>])<br>    <br>    <span class="hljs-comment"># 输出密文（行列转置为结果）</span><br>    <span class="hljs-keyword">return</span> [state[i][j] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]<br><br><span class="hljs-comment"># 主函数，输入数据</span><br>plain_text = [<br>    <span class="hljs-number">0x32</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xe0</span>,<br>    <span class="hljs-number">0xc0</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x7a</span>,<br>    <span class="hljs-number">0x5b</span>, <span class="hljs-number">0x6b</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x79</span>,<br>    <span class="hljs-number">0x44</span>, <span class="hljs-number">0x5d</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x5e</span><br>]<br><br>key = [<br>    <span class="hljs-number">0x2b</span>, <span class="hljs-number">0x7e</span>, <span class="hljs-number">0x15</span>, <span class="hljs-number">0x16</span>,<br>    <span class="hljs-number">0x28</span>, <span class="hljs-number">0xae</span>, <span class="hljs-number">0xd2</span>, <span class="hljs-number">0xa6</span>,<br>    <span class="hljs-number">0xab</span>, <span class="hljs-number">0xf7</span>, <span class="hljs-number">0x97</span>, <span class="hljs-number">0x75</span>,<br>    <span class="hljs-number">0x46</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x3d</span><br>]<br><br><span class="hljs-comment"># 执行加密</span><br>ciphertext = AES_encrypt(plain_text, key)<br><br><span class="hljs-comment"># 输出密文</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Ciphertext:&quot;</span>)<br><span class="hljs-built_in">print</span>([<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> ciphertext])<br><br></code></pre></td></tr></table></figure><h2 id="五，参考文献">五，参考文献</h2><p><a href="https://www.cnblogs.com/block2016/p/5596676.html">https://www.cnblogs.com/block2016/p/5596676.html</a></p><p><a href="https://blog.csdn.net/qq_28205153/article/details/55798628">https://blog.csdn.net/qq_28205153/article/details/55798628</a></p><p><a href="https://zhuanlan.zhihu.com/p/78913397">https://zhuanlan.zhihu.com/p/78913397</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法笔记】康托展开</title>
    <link href="/2025/01/11/OJ/CantorUnfolds/"/>
    <url>/2025/01/11/OJ/CantorUnfolds/</url>
    
    <content type="html"><![CDATA[<h1>康托展开</h1><h3 id="康托展开运算">康托展开运算</h3><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>X</mi><mo>=</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo><mo>+</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mo>⋅</mo><mn>0</mn><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">X = a_n (n-1)! + a_{n-1} (n-2)! + \cdots + a_1 \cdot 0!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)!</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)!</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5945em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">0</span><span class="mclose">!</span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为整数, 并且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">0 \leq a_i &lt; i, 1 \leq i \leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>。</p><h3 id="康托展开举例">康托展开举例</h3><p>再举个例子说明。</p><p>在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1, 2, 3, 4, 5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">)</span></span></span></span> 5 个数的排列组合中，计算 34152 的康托展开值。</p><p>首先是 3，则小于 3 的数有两个，为 1 和 2，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mn>5</mn><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">a[5] = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord">5</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，则首位小于 3 的所有排列组合为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mn>5</mn><mo stretchy="false">]</mo><mo>×</mo><mo stretchy="false">(</mo><mn>5</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">a[5] \times (5 - 1)!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord">5</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)!</span></span></span></span>。</p><p>第二位是 4，由于第一位小于 4，1、2、3 中一定会有 1 个充当第一位，所以排在 4 之下的只剩 2 个，所以其计算的是在第二位之后小于 4 的个数。因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">a[4] = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>。</p><p>第三位是 1，则在其之后小于 1 的数有 0 个，所以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a[3] = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</p><p>第四位是 5，则在其之后小于 5 的数有 1 个，为 2，所以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a[2] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p><p>最后一位就不用计算了，因为在它之后已经没有数了，所以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a[1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 固定为 0。</p><p>根据公式：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>X</mi><mo>=</mo><mn>2</mn><mo>×</mo><mn>4</mn><mo stretchy="false">!</mo><mo>+</mo><mn>2</mn><mo>×</mo><mn>3</mn><mo stretchy="false">!</mo><mo>+</mo><mn>0</mn><mo>×</mo><mn>2</mn><mo stretchy="false">!</mo><mo>+</mo><mn>1</mn><mo>×</mo><mn>1</mn><mo stretchy="false">!</mo><mo>+</mo><mn>0</mn><mo>×</mo><mn>0</mn><mo stretchy="false">!</mo><mo>=</mo><mn>61</mn></mrow><annotation encoding="application/x-tex">X = 2 \times 4! + 2 \times 3! + 0 \times 2! + 1 \times 1! + 0 \times 0! = 61</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">0</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">61</span></span></span></span></span></p><p>所以比 34152 小的组合有 61 个，即 34152 是第 62。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cantor</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a[], <span class="hljs-type">long</span> <span class="hljs-type">long</span> len)</span> </span>&#123; <br>    <span class="hljs-comment">//cantor展开,n表示是n位的全排列，a[]表示全排列的数（用数组表示） </span><br><br><span class="hljs-comment">//1-100阶乘 </span><br><span class="hljs-type">int</span> factorial[<span class="hljs-number">101</span>];<br>factorial[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>factorial[i] = factorial[i<span class="hljs-number">-1</span>]*i;<br>&#125;<br><br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span>; j &lt;= len; j++) &#123;<br><span class="hljs-keyword">if</span>(a[j] &lt; a[i]) &#123;<br>cnt ++;<br>&#125;<br>&#125;<br>ans += cnt*factorial[len-i];<span class="hljs-comment">//累积</span><br>cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">//计数器归零</span><br>&#125;<br><span class="hljs-keyword">return</span> ans<span class="hljs-number">+1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法笔记】存图方式 — 链式前向星</title>
    <link href="/2025/01/11/OJ/ChainForwardStar/"/>
    <url>/2025/01/11/OJ/ChainForwardStar/</url>
    
    <content type="html"><![CDATA[<h1>存图方式 — 链式前向星</h1><h2 id="边的存储">边的存储</h2><p>这种存图方式只需要开一个数组存储每个点引出的第一条边，然后存储每个点作为起点的每条边，这样就可以做到不重不漏</p><p>在链式前向星存图中，我们需要定义一个结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">EDGE</span> &#123;<br>    <span class="hljs-type">int</span> next;<br>    <span class="hljs-type">int</span> to;<br>&#125; edge[<span class="hljs-number">1000</span>];<br></code></pre></td></tr></table></figure><p>和一个数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> head[<span class="hljs-number">1000</span>]<br></code></pre></td></tr></table></figure><p>和一个变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">//指针</span><br></code></pre></td></tr></table></figure><p>起点用head数组存</p><p><strong>举例：</strong></p><p><img src="/img/OJ/image-20250111211707179.png" alt=""></p><p>如图：这样一个有向图的输入是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="逐步分析：">逐步分析：</h3><h4 id="1-输入1-2，代表1连向2。">1. 输入1 2，代表1连向2。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">cnt ++;<span class="hljs-comment">//作为结构体下标，没有意义</span><br>head[<span class="hljs-number">1</span>] = cnt; <span class="hljs-comment">//结点1的第一个儿子存在了edge[cnt]里面</span><br>edge[cnt].to = <span class="hljs-number">2</span>; <span class="hljs-comment">//结点1的儿子是2</span><br></code></pre></td></tr></table></figure><p>此时 ：cnt = 1</p><table><thead><tr><th style="text-align:center">edge</th><th style="text-align:center">cnt = 1</th><th style="text-align:center">cnt = 2</th><th style="text-align:center">cnt = 3</th><th style="text-align:center">cnt = 4</th></tr></thead><tbody><tr><td style="text-align:center">to</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">next</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><table><thead><tr><th style="text-align:center">head[ ]</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th></tr></thead><tbody><tr><td style="text-align:center">值</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><h4 id="2-输入1-3，代表1连向3">2. 输入1 3，代表1连向3.</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">cnt++;<br>head[<span class="hljs-number">1</span>] = cnt;<br>edge[cnt].to = <span class="hljs-number">3</span>;<span class="hljs-comment">//结点1的儿子是3</span><br><span class="hljs-comment">//这时，3成为了结点1的儿子，不过2被挤了下去</span><br><span class="hljs-comment">//所以要引入结构体中next元素，记录：3还有个兄弟（next）是2</span><br><br><span class="hljs-comment">//所以代码要换成：</span><br>cnt++;<br>edge[cnt].to = <span class="hljs-number">3</span>;<span class="hljs-comment">//结点1连向3</span><br>edge[cnt].next = head[<span class="hljs-number">1</span>];<span class="hljs-comment">//3的兄弟是2</span><br>head[<span class="hljs-number">1</span>] = cnt;<span class="hljs-comment">//更新head</span><br></code></pre></td></tr></table></figure><p>此时：cnt = 2</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">cnt = 1</th><th style="text-align:center">cnt = 2</th><th style="text-align:center">cnt = 3</th><th style="text-align:center">cnt = 4</th></tr></thead><tbody><tr><td style="text-align:center">to</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">next</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><table><thead><tr><th style="text-align:center">head[ ]</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td style="text-align:center">值</td><td>2</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h4 id="3-输入1-4，代表1连向4。">3. 输入1 4，代表1连向4。</h4><p>此时：cnt = 3</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">cnt = 1</th><th style="text-align:center">cnt = 2</th><th style="text-align:center">cnt = 3</th><th style="text-align:center">cnt = 4</th></tr></thead><tbody><tr><td style="text-align:center">to</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">next</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td></tr></tbody></table><table><thead><tr><th style="text-align:center">head[ ]</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td style="text-align:center">值</td><td>3</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h4 id="4-输入2-3，代表2连向3。">4. 输入2 3，代表2连向3。</h4><p>此时：cnt = 4</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">cnt = 1</th><th style="text-align:center">cnt = 2</th><th style="text-align:center">cnt = 3</th><th style="text-align:center">cnt = 4</th></tr></thead><tbody><tr><td style="text-align:center">to</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">next</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td></tr></tbody></table><table><thead><tr><th style="text-align:center">head[ ]</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td style="text-align:center">值</td><td>3</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p><strong>若需要记录权值，在结构体中加入一个元素即可</strong></p><p>代码：（带权值）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;<br>    <span class="hljs-type">int</span> next;<br>    <span class="hljs-type">int</span> to;<br>    <span class="hljs-type">int</span> wei;<br>&#125; edge[maxn];<br><span class="hljs-type">int</span> head[maxn]; <span class="hljs-comment">//head[i] 为i点的第一条边</span><br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span> </span>&#123;<br>    edge[++cnt].next = head[u];<br>    edge[cnt].to = v;<br>    edge[cnt].w = w;<br>    head[u] = cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, w;<br>        <span class="hljs-built_in">addedge</span>(a, b, w);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注意：">注意：</h4><p>这里的next指的是遍历时的下一条边，head指的是遍历时的第一条边，而存边时相当于反过来操作，所以next记录上一条边，而head记录最后一条边。</p><h2 id="边的遍历">边的遍历</h2><p>在遍历以x为起点的所有边时，只需要这样就行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=head[x]; i; <span class="hljs-attribute">i</span>=edge[i].next)<br></code></pre></td></tr></table></figure><p>这个循环的结束条件是i等于0，因为最后一条边，也就是存边时第一条边，在把head值存进next时，head还没有更新过，也就是0。所以当next返回0时，就说明这些边遍历完毕了。</p><h2 id="优势与特点">优势与特点</h2><p>既可以存图，也可以存树，比起邻接矩阵，链式前向星的空间复杂度是O（n），大大节省了存储空间，因为按边存储省掉了很多两点无边的空间。并且在遍历的时候，那些与起点无边相连的点也不需要进行处理，可以说时间和空间都占优势，这就是被OIer们广泛使用的原因。</p><h1>实践 —— 单源最短路径</h1><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> head[<span class="hljs-number">100000</span>],cnt;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans[<span class="hljs-number">1000000</span>];<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">1000000</span>];<br><span class="hljs-type">int</span> m,n,s;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br><span class="hljs-type">int</span> to;<br><span class="hljs-type">int</span> nextt;<br><span class="hljs-type">int</span> wei;<br>&#125;edge[<span class="hljs-number">1000000</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span></span><br><span class="hljs-function"></span>&#123;<br>edge[++cnt].to=y;<br>edge[cnt].wei=z;<br>edge[cnt].nextt=head[x];<br>head[x]=cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>ans[i]=<span class="hljs-number">2147483647</span>;<br>&#125;<br>ans[s]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-built_in">addedge</span>(a,b,c);<br>&#125;<br><span class="hljs-type">int</span> pos=s;<br><span class="hljs-keyword">while</span>(vis[pos]==<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> minn=<span class="hljs-number">2147483647</span>;<br>vis[pos]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[pos];i!=<span class="hljs-number">0</span>;i=edge[i].nextt)<br>&#123;<br><span class="hljs-keyword">if</span>(!vis[edge[i].to]&amp;&amp;ans[edge[i].to]&gt;ans[pos]+edge[i].wei)<br>&#123;<br>ans[edge[i].to]=ans[pos]+edge[i].wei;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(ans[i]&lt;minn&amp;&amp;vis[i]==<span class="hljs-number">0</span>)<br>&#123;<br>minn=ans[i];<br>pos=i;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br>cout&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【常见算法问题】最大子序列和问题</title>
    <link href="/2025/01/11/OJ/MaxSubColumn/"/>
    <url>/2025/01/11/OJ/MaxSubColumn/</url>
    
    <content type="html"><![CDATA[<h1>最大子列和问题</h1><p>求解一个整数数组 A 的<strong>最大子序列和</strong>（Maximum Subsequence Sum），即在数组 A 中找到一个连续子序列，使得该子序列中所有元素的和最大。</p><h2 id="算法1：暴力枚举">算法1：暴力枚举</h2><p>逐一遍历数组中所有可能的连续子序列，计算其和并记录最大值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">MaxSubseqSum1</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> N)</span><br>&#123;<br> <span class="hljs-type">int</span> ThisSum, MaxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i, j, k;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; N; j++) &#123;<br>            ThisSum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(k = i; k &lt;= j; k++)<br>                ThisSum += A[k];<br>                <span class="hljs-keyword">if</span>(ThisSum &gt; MaxSum) <br>                    MaxSum = ThisSum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> MaxSum;<br>&#125;<br></code></pre></td></tr></table></figure><p>算法复杂度：O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">N^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>)</p><h2 id="算法2：暴力优化">算法2：暴力优化</h2><p>枚举所有可能的子序列求解最大子序列和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">MaxSubseqSum1</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> N)</span><br>&#123;<br> <span class="hljs-type">int</span> ThisSum, MaxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i, j, k;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        ThisSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(j = i; j &lt; N; j++) &#123;<br>ThisSum += A[j];<br>             <span class="hljs-keyword">if</span>(ThisSum &gt; MaxSum) <br>                 MaxSum = ThisSum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> MaxSum;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)</p><h2 id="算法3：贪心">算法3：贪心</h2><p>通过一次遍历动态计算最大子序列和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">MaxSubseqSum1</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> N)</span> &#123;<br>    <span class="hljs-type">int</span> ThisSum, MaxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        ThisSum += A[i];<br>        <span class="hljs-keyword">if</span>(ThisSum &gt; MaxSum) &#123;<br>            MaxSum = ThisSum;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ThisSum &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果当前子序列小于0，则不可能使后面增大，抛弃</span><br>            ThisSum = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> MaxSum;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：O(N)</p>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法笔记】快速幂</title>
    <link href="/2025/01/11/OJ/QuickCount/"/>
    <url>/2025/01/11/OJ/QuickCount/</url>
    
    <content type="html"><![CDATA[<h1>快速幂运算</h1><p><strong>前置知识：复习一下数学知识：</strong></p><p>对于指数：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>X</mi><mi>A</mi></msup><mo>∗</mo><msup><mi>X</mi><mi>B</mi></msup><mo>=</mo><msup><mi>X</mi><mrow><mi>A</mi><mo>+</mo><mi>B</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X^A*X^B = X^{A+B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mrow><mo fence="true">(</mo><msup><mi>X</mi><mi>A</mi></msup><mo fence="true">)</mo></mrow><mi>B</mi></msup><mo>=</mo><msup><mi>X</mi><mrow><mi>A</mi><mo>⋅</mo><mi>B</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\left(X^A\right)^B = X^{A \cdot B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4726em;vertical-align:-0.35em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1226em;"><span style="top:-3.3442em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mbin mtight">⋅</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>下面我们开始上例题：</p><p><strong>接下来解决一道来自杭州电子科技大学OJ上的题目：</strong></p><p>问题描述：</p><p>求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>B</mi></msup></mrow><annotation encoding="application/x-tex">A^B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span></span></span></span> 的最后三位数表示的整数<br>说明：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>B</mi></msup></mrow><annotation encoding="application/x-tex">A^B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span></span></span></span> 的含义是&quot;A的B次方&quot;</p><p>链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2035">Problem - 2035 (hdu.edu.cn)</a></p><h2 id="初次思考">初次思考</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 普通的求幂函数</span><br><span class="hljs-comment"> * @param base 底数</span><br><span class="hljs-comment"> * @param power  指数</span><br><span class="hljs-comment"> * @return  求幂结果的最后3位数表示的整数</span><br><span class="hljs-comment">**/</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">normalPower</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span>, base, <span class="hljs-type">long</span> <span class="hljs-type">long</span> power)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>; i &lt;= power; i++) &#123;<br>        result = result * base;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result % <span class="hljs-number">1000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码只能首先数目较小的数字，当遇到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>100</mn></msup></mrow><annotation encoding="application/x-tex">2^{100}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">100</span></span></span></span></span></span></span></span></span></span></span></span>时，会因为数据太大而导致内存溢出。</p><p>那如何解决上述问题呢？</p><p><strong>别急，让我们在补充一下数学知识</strong></p><p>“取模”运算的运算法则如下：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mspace width="1em"/><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo>=</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mo stretchy="false">(</mo><mi>a</mi><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>b</mi><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mspace width="1em"/><mo stretchy="false">(</mo><mi>a</mi><mo>−</mo><mi>b</mi><mo stretchy="false">)</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo>=</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mo stretchy="false">(</mo><mi>a</mi><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mi>b</mi><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mspace width="1em"/><mo stretchy="false">(</mo><mi>a</mi><mo>⋅</mo><mi>b</mi><mo stretchy="false">)</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo>=</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mo stretchy="false">(</mo><mi>a</mi><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mi>b</mi><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align} \quad (a + b) \mod p = \big((a \mod p) + (b \mod p)\big) \mod p  \\ \quad (a - b) \mod p = \big((a \mod p) - (b \mod p)\big) \mod p  \\ \quad (a \cdot b) \mod p = \big((a \mod p) \cdot (b \mod p)\big) \mod p \\\end{align}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.53em;vertical-align:-2.015em;"></span><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.515em;"><span style="top:-4.665em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span></span></span><span style="top:-3.155em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span></span></span><span style="top:-1.645em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.015em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.515em;"><span style="top:-4.515em;"><span class="pstrut" style="height:2.85em;"></span><span class="eqn-num"></span></span><span style="top:-3.005em;"><span class="pstrut" style="height:2.85em;"></span><span class="eqn-num"></span></span><span style="top:-1.495em;"><span class="pstrut" style="height:2.85em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.015em;"><span></span></span></span></span></span></span></span></span></p><p>在这里我们只需要注意第三条</p><p>因此，我们可以借助这个法则，在循环乘积的每一步都提前进行“取模”运算，而不是等到最后对结果直接取模，就能够解决上述问题。</p><p>所以我们将代码修改为这个样子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">normalPower</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span>, base, <span class="hljs-type">long</span> <span class="hljs-type">long</span> power)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= power; i++) &#123;<br>        result = result * base;<br>        result = result % <span class="hljs-number">1000</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result % <span class="hljs-number">1000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>诶这次代码就可以解决当数据太大溢出的问题了</p><p><strong>输出结果：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">2100</span><br><span class="hljs-attribute">base</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> power <span class="hljs-operator">=</span> <span class="hljs-number">100376</span><br></code></pre></td></tr></table></figure><h2 id="再次思考（-如何优化代码？）">再次思考（ 如何优化代码？）</h2><p>对于上述代码，当数据很大时，循环的次数随着数据的增大而线性增长，以至于上述算法的时间复杂O(N)太长，当遇到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1000000</mn></msup></mrow><annotation encoding="application/x-tex">2^{1000000}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1000000</span></span></span></span></span></span></span></span></span></span></span></span>类似的数据时，程序会运行很长时间，下面我们来测试一下代码的运行速率。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br> <br>using namespace <span class="hljs-built_in">std</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 普通的求幂函数</span><br><span class="hljs-comment"> * @param base 底数</span><br><span class="hljs-comment"> * @param power  指数</span><br><span class="hljs-comment"> * @return  求幂结果的最后3位数表示的整数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">normalPower</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> base, <span class="hljs-type">long</span> <span class="hljs-type">long</span> power)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= power; i++) &#123;<br>        result = result * base;<br>        result = result % <span class="hljs-number">1000</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result % <span class="hljs-number">1000</span>;<br>&#125;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">clock_t</span> start, finish;<br>    <span class="hljs-comment">//clock_t为CPU时钟计时单元数</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> base, power;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; base &gt;&gt; power;<br>    start = clock();<br>    <span class="hljs-comment">//clock()函数返回此时CPU时钟计时单元数</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; normalPower(base, power) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    finish = clock();<br>    <span class="hljs-comment">//clock()函数返回此时CPU时钟计时单元数</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;the time cost is&quot;</span> &lt;&lt; <span class="hljs-type">double</span>(finish - start) / CLOCKS_PER_SEC;<br>    <span class="hljs-comment">//finish与start的差值即为程序运行花费的CPU时钟单元数量，再除每秒CPU有多少个时钟单元，即为程序耗时</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">2</span> <span class="hljs-number">1000000000</span><br><span class="hljs-number">376</span><br>the time cost is <span class="hljs-number">17.61</span><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>竟然要了17.61秒！！！！</strong></p><p>为了优化算法，提高算法效率，我们引出了——<strong>快速幂算法</strong></p><h2 id="快速幂算法初入门：">快速幂算法初入门：</h2><p>快速幂算法能帮我们算出指数非常大的幂，传统的求幂算法之所以时间复杂度非常高（为O(指数n)），就是因为当指数n非常大的时候，需要执行的循环操作次数也非常大。所以我们快速幂算法的核心思想就是<strong>每一步都把指数分成两半，而相应的底数做平方运算</strong>。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。让我们先来看一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">3</span>^<span class="hljs-number">10</span>=<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span><br><br><span class="hljs-comment">//尽量想办法把指数变小来，这里的指数为10</span><br><br><span class="hljs-number">3</span>^<span class="hljs-number">10</span>=(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>)*(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>)*(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>)*(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>)*(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>)<br><br><span class="hljs-number">3</span>^<span class="hljs-number">10</span>=(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>)^<span class="hljs-number">5</span><br><br><span class="hljs-number">3</span>^<span class="hljs-number">10</span>=<span class="hljs-number">9</span>^<span class="hljs-number">5</span><br><br><span class="hljs-comment">//此时指数由10缩减一半变成了5，而底数变成了原来的平方，求3^10原本需要执行10次循环操作，求9^5却只需要执行5次循环操作，但是3^10却等于9^5,我们用一次（底数做平方操作）的操作减少了原本一半的循环量，特别是在幂特别大的时候效果非常好，例如2^10000=4^5000,底数只是做了一个小小的平方操作，而指数就从10000变成了5000，减少了5000次的循环操作。</span><br><br><span class="hljs-comment">//现在我们的问题是如何把指数5变成原来的一半，5是一个奇数，5的一半是2.5，但是我们知道，指数不能为小数，因此我们不能这么简单粗暴的直接执行5/2，然而，这里还有另一种方法能表示9^5</span><br><br><span class="hljs-number">9</span>^<span class="hljs-number">5</span>=（<span class="hljs-number">9</span>^<span class="hljs-number">4</span>）*（<span class="hljs-number">9</span>^<span class="hljs-number">1</span>）<br><br><span class="hljs-comment">//此时我们抽出了一个底数的一次方，这里即为9^1，这个9^1我们先单独移出来,剩下的9^4又能够在执行“缩指数”操作了，把指数缩小一半，底数执行平方操作</span><br><br><span class="hljs-number">9</span>^<span class="hljs-number">5</span>=（<span class="hljs-number">81</span>^<span class="hljs-number">2</span>）*(<span class="hljs-number">9</span>^<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">//把指数缩小一半，底数执行平方操作</span><br><br><span class="hljs-number">9</span>^<span class="hljs-number">5</span>=（<span class="hljs-number">6561</span>^<span class="hljs-number">1</span>）*(<span class="hljs-number">9</span>^<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">//此时，我们发现指数又变成了一个奇数1，按照上面对指数为奇数的操作方法，应该抽出了一个底数的一次方，这里即为6561^1，这个6561^1我们先单独移出来，但是此时指数却变成了0，也就意味着我们无法再进行“缩指数”操作了。</span><br><br><span class="hljs-number">9</span>^<span class="hljs-number">5</span>=（<span class="hljs-number">6561</span>^<span class="hljs-number">0</span>）*(<span class="hljs-number">9</span>^<span class="hljs-number">1</span>)*(<span class="hljs-number">6561</span>^<span class="hljs-number">1</span>)=<span class="hljs-number">1</span>*(<span class="hljs-number">9</span>^<span class="hljs-number">1</span>)*(<span class="hljs-number">6561</span>^<span class="hljs-number">1</span>)=(<span class="hljs-number">9</span>^<span class="hljs-number">1</span>)*(<span class="hljs-number">6561</span>^<span class="hljs-number">1</span>)=<span class="hljs-number">9</span>*<span class="hljs-number">6561</span>=<span class="hljs-number">59049</span><br><br>我们能够发现，最后的结果是<span class="hljs-number">9</span>*<span class="hljs-number">6561</span>，而<span class="hljs-number">9</span>是怎么产生的？是不是当指数为奇数<span class="hljs-number">5</span>时，此时底数为<span class="hljs-number">9</span>。那<span class="hljs-number">6561</span>又是怎么产生的呢？是不是当指数为奇数<span class="hljs-number">1</span>时，此时的底数为<span class="hljs-number">6561</span>。所以我们能发现一个规律：最后求出的幂结果实际上就是在变化过程中所有当指数为奇数时底数的乘积。<br></code></pre></td></tr></table></figure><h3 id="1-初步优化：">1. 初步优化：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">normalPower</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> base, <span class="hljs-type">long</span> <span class="hljs-type">long</span> power)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(power &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span>(power % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//如果指数为偶数</span><br>            power = power / <span class="hljs-number">2</span>; <span class="hljs-comment">//让指数减半</span><br>            base = base * base % <span class="hljs-number">1000</span>; <span class="hljs-comment">// 底数变大为原来的平方</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//若指数为奇数</span><br>            power --; <span class="hljs-comment">// 让指数减一变为偶数</span><br>            power = power / <span class="hljs-number">2</span>; <span class="hljs-comment">// 执行上述操作</span><br>            result = result * base % <span class="hljs-number">1000</span>; <span class="hljs-comment">// 不要忘记记录单独分离出来的底数</span><br>            base = base * base % <span class="hljs-number">1000</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><p>神奇的事情发生了：</p><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">2</span> <span class="hljs-number">1000000000</span><br><span class="hljs-number">376</span><br>the time cost is <span class="hljs-number">0.002</span><br>Processfinished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>竟然只花了0.002秒就求出了结果，而且结果也是正确的！</p><h3 id="2-进阶优化">2. 进阶优化</h3><p>虽然上述代码效率已经很高了，但是我们能对其再次进行压榨。</p><p>我们看到上述代码其实是有重复部分的，比如这里：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">power</span> <span class="hljs-operator">=</span> power / <span class="hljs-number">2</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">base</span> <span class="hljs-operator">=</span> base * base % <span class="hljs-number">1000</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>和这里</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">power</span> <span class="hljs-operator">=</span> power - <span class="hljs-number">1</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">power</span> <span class="hljs-operator">=</span> power / <span class="hljs-number">2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>可以压缩成一句话</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">power</span> <span class="hljs-operator">=</span> power / <span class="hljs-number">2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>因为power是一个整数 power / 2 后还是一个整数，遵循的法则是向下取整，例如：5 / 2 = 2 。因此我们可以吧代码压缩成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">fastPower</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> base, <span class="hljs-type">long</span> <span class="hljs-type">long</span> power)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(power &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span>(power % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            result = result * base % <span class="hljs-number">1000</span>;<br>        &#125;<br>        power = power / <span class="hljs-number">2</span>;<br>        base = base * base % <span class="hljs-number">1000</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>依旧是测试性能时间：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">2</span> <span class="hljs-number">1000000000</span><br><span class="hljs-number">376</span><br>the time cost is <span class="hljs-number">0.001</span><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>惊喜吧 又减少了0.001s awa！</p><h3 id="3-终极优化">3. 终极优化</h3><p>在C语言中，power % 2 ==  1可以用更快的“<strong>位运算</strong>”来代替。</p><p>例如：power &amp; 1</p><p>因为如果power为偶数，则其二进制表示的最后一位一定是0</p><p>如果power是奇数，则其二进制表示的最后一位一定是1。</p><p>将他们分别与 1 的二进制做“与”运算，得到的就是power二进制最后一位的数字了。</p><p>结果是 0 则为偶数，是 1 则为奇数。</p><p>例如5是奇数，则 5 &amp; 1 = 1；而 6 是偶数，则 6 &amp; 1 = 0；因此奇偶数的判断就可以用“位运算”来替换了。</p><p><strong>下面是图解：</strong></p><p><img src="/img/OJ/Qcounting.png" alt="快速幂"></p><p>同样，对于power = power / 2 来说，也可以用更快的“位运算”进行替代，我们只要把power的二进制表示向右移动1位（相当于原数除以2）就能变成原来的一半了。</p><p>因此代码修改为下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">fastPower</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> base, <span class="hljs-type">long</span> <span class="hljs-type">long</span> power)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(power &gt; <span class="hljs-number">0</span>) &#123; <br>        <span class="hljs-keyword">if</span>(power &amp; <span class="hljs-number">1</span>) &#123;<br>            result = result * base % <span class="hljs-number">1000</span>;<br>        &#125;<br>        power &gt;&gt;= <span class="hljs-number">1</span>;<br>        base = (base * base) % <span class="hljs-number">1000</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">2</span> <span class="hljs-number">1000000000</span><br><span class="hljs-number">376</span><br>the timee cost is <span class="hljs-number">0</span><br>Process ffinished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>简直可怕，时间花费竟然接近于0秒！！</strong></p><p><strong>想象一下，如果同样两家公司，采用不同的算法，给用户带来的体验区别将是质的改变！</strong></p><p><strong>这就是算法的魅力！</strong></p><h2 id="参考文献">参考文献</h2><ul><li><p><a href="https://blog.csdn.net/m0_52072919/article/details/116400820">https://blog.csdn.net/m0_52072919/article/details/116400820</a></p></li><li><p><a href="https://oi-wiki.org/math/binary-exponentiation/">https://oi-wiki.org/math/binary-exponentiation/</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷】P3916 —— 反向建边 + dfs</title>
    <link href="/2025/01/11/OJ/TraverseGraph/"/>
    <url>/2025/01/11/OJ/TraverseGraph/</url>
    
    <content type="html"><![CDATA[<h1>图的遍历(反向建边+dfs)</h1><p><a href="https://www.luogu.com.cn/problem/P3916">https://www.luogu.com.cn/problem/P3916</a></p><p>按题目来每次考虑每个点可以到达点编号最大的点，不如考虑较大的点可以反向到达哪些点</p><p>循环从N到1，则每个点i能访问到的结点的A值都是i</p><p>每个点访问一次，这个A值就是最优的，因为之后如果再访问到这个结点那么答案肯定没当前大了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXL 100010</span><br><br><span class="hljs-type">int</span> N, M, A[MAXL];<br>vector&lt;<span class="hljs-type">int</span>&gt; G[MAXL]; <span class="hljs-comment">//vector存图 </span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> d)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(A[x]) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//访问过 </span><br>A[x] = d;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;G[x].<span class="hljs-built_in">size</span>(); i++)<br><span class="hljs-built_in">dfs</span>(G[x][i], d);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> u, v;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;N, &amp;M);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=M; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);<br>G[v].<span class="hljs-built_in">push_back</span>(u); <span class="hljs-comment">//反向建边 </span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=N; i; i--) <span class="hljs-built_in">dfs</span>(i, i); <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=N; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, A[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机视觉】多目标追踪——匈牙利算法与KM算法</title>
    <link href="/2025/01/10/DeepLearning/Hungarian/"/>
    <url>/2025/01/10/DeepLearning/Hungarian/</url>
    
    <content type="html"><![CDATA[<h1>多目标追踪——匈牙利算法与KM算法</h1><h2 id="一、基本概念">一、基本概念</h2><ul><li><strong>匈牙利算法</strong>（Hungarian Algorithm）是一种用于解决 <strong>二分图最大匹配</strong> 或 <strong>最小权重匹配</strong> 问题的算法，常用于优化分配问题。该算法的核心目标是通过优化一个矩阵的方式，找到最优的匹配方案，最常见的应用是任务分配问题，比如将n个任务分配给n个人，使得任务的总成本最小或总效益最大。</li><li>此算法之所以被称作匈牙利算法，是因为算法很大一部分是基于以前匈牙利数学家 Dénes Kőnig 和 Jenő Egerváry 的工作之上创建起来的。</li><li>匈牙利算法有很多的用途，但在本文中，我们主要讨论匈牙利算法在目标追踪中的作用。</li></ul><ol><li><p><strong>二分图</strong></p><ul><li><p>二分图是一种特殊的图，它的节点可以分成两个互不重叠的集合，使得图中每条边都连接这两个集合中的节点。换句话说，二分图的所有边都跨越这两个集合，图中的每一条边都连接一个集合中的节点与另一个集合中的节点。</p><p>以下是一个典型的二分图</p></li></ul><p><img src="/img/DeepLearning/Hungarian/bcad61ec6ee23b6fd1175da36b086bc.png" alt="图1"></p></li><li><p>匹配</p><ul><li><strong>匹配（Matching）</strong> 是图论中的一个基本概念，指的是在图中选择一组边，使得每条边的两个端点都不相同（即不重复）。具体来说，匹配问题要求选择一些边，使得这些边没有共享的顶点。</li></ul><p><img src="/img/DeepLearning/Hungarian/image-20250110171824278.png" alt="图2"></p><ul><li>如果存在一组边，使得图中的大部分节点都与其他节点有匹配关系（而不是全部），称为 <strong>近似匹配（Near Perfect Matching）</strong> 或 <strong>最大匹配（Maximum Matching）</strong>。</li></ul></li></ol><p>因此，匈牙利算法适用于求解 <strong>二分图的最大匹配</strong> 或 <strong>最小权重匹配</strong> 问题，时间复杂度通常为O (n3)</p><h2 id="二、匈牙利算法">二、匈牙利算法</h2><h3 id="为什么需要匈牙利算法？">为什么需要匈牙利算法？</h3><p>在目标跟踪中，随着时间的推移，物体的位置会不断变化，特别是在动态环境下，物体可能会发生遮挡、交叉、或快速移动。因此，我们不仅需要对物体进行准确的检测，还需要在不同的帧之间保持对同一物体的追踪，以确保物体在整个视频序列中始终保持相同的ID。这是目标跟踪中的 <strong>数据关联问题</strong>，也就是在每一帧中，如何将当前帧检测到的目标与上一帧的目标进行匹配，保持物体的身份一致性。</p><p>为了实现这一点，我们通常使用 <strong>匈牙利算法</strong> 来解决这个匹配问题。</p><h3 id="Example">Example</h3><p>我们来用一个实际的例子说明匈牙利算法的步骤：</p><p>以下图为例，假设左边的四张图是我们在第N帧检测到的目标（U），右边四张图是我们在第N+1帧检测到的目标（V）。红线连起来的图，是我们的算法认为是同一行人可能性较大的目标。但由于算法并不是绝对理想的，因此并不一定会保证每张图都有一对一的匹配，可能每张图有一对二甚至一对多的情况发生。</p><p><img src="/img/DeepLearning/Hungarian/image-20200227185052525.png" alt="图3"></p><ul><li><p>第一步</p><p>给图片1进行匹配，发现此时与其相连的右1还未匹配，于是将其配对，连上一条蓝线。</p></li></ul><p><img src="/img/DeepLearning/Hungarian/image-20200227185149106.png" alt="图4"></p><ul><li><p>第二步</p><p>接着匹配左2，发现此时与其相连的右二还未匹配，于是将其配对，连上一条蓝线。</p></li></ul><p><img src="/img/DeepLearning/Hungarian/image-20200227185228250.png" alt="图5"></p><ul><li><p>第三步</p><p>接着匹配 左3 ，我们发现，左3 与其相连接的 右1 和 右2 都已经预先被匹配完毕了。</p><p>但为了完成 左3 的匹配任务，我们想到可以给之前 右1 的匹配的对象—— 左1，重新分配一个新的对象 ——即与 左1 相连的另一张图 右2。</p><p>但我们又发现，右2 也已经被匹配出去了。</p><p>于是我们可以用同样的思想，给之前 右2 匹配的对象—— 左2，重新分配一张图——即与左2相连的另一张图 右3。（后面再遇到类似的情况也是同样的操作，这是一个递归的过程）</p><p>此时的匹配结果分别如下：（黄色的线表示临时被拆除的线）</p><p><img src="/img/DeepLearning/Hungarian/image-20250110174112528.png" alt="图6"></p><p>这时，问题就迎刃而解了，左3完美匹配上了右1！</p><p><img src="/img/DeepLearning/Hungarian/image-20200227185430170.png" alt="图7"></p></li><li><p>第四步：</p><p>最后匹配左4，很遗憾，按照第三步无法给左4腾出来一个匹配对象，无奈放弃。匈牙利算法至此结束。</p></li></ul><p>可以看到，由于在候选匹配中包含了许多错误的匹配红线，所以按照算法流程下来匹配准确率并不高。可见匈牙利算法预先红线连接的准确率依赖度较高，也就是说要求我们事先必须要进行一个精准的预测，比如设定一个阈值（置信度），把较高置信度的边送入匈牙利算法进行匹配，才能够得到更好的结果。</p><p><strong>为了更好的解决上述问题，我们可以采取KM算法</strong></p><h2 id="三、KM算法">三、KM算法</h2><p>KM算法的应用背景可以是一个 <strong>带权二分图</strong>，其中每一条边都有一个代价。目标是找到一个最优匹配，使得所选边的总代价最小。</p><h3 id="算法步骤">算法步骤</h3><ol><li><p>首先对每个顶点赋值，将左边的顶点赋值为最大权重，右边的顶点赋值为0。</p><p>如图，我们将左1赋值为其两边中较大的0.8。</p><p><img src="/img/DeepLearning/Hungarian/image-20200227185713197.png" alt="图8"></p></li><li><p>进行匹配。</p><p>匹配的原则是：<strong>只与权重相同的边进行匹配</strong>。</p><p>若找不到匹配的边，则对此条路径的所有左图权重-0.1，右图权重+0.1。（加减的值不唯一，视情况而定）</p><p>例如对左1进行匹配，符合匹配条件的只有：左1 —— 右1</p><p><img src="/img/DeepLearning/Hungarian/image-20200227185802547.png" alt="图9"></p><p>同理：接下来对左2进行匹配。</p><p><img src="/img/DeepLearning/Hungarian/image-20200227185829028.png" alt="图10"></p><p>然后是左3，注意此时左3想匹配的对象（右1）已经被左1匹配了，而左1又无法重新匹配一个新的对象（因为开始匹配的边权最大）。那应该怎么办呢？</p><p>我们不妨可以用给员工分配工作的角度思考：其实我们寻找<strong>最优匹配</strong>的过程，也就是<strong>帮每个员工找到他们工作效率最高的工作</strong>，但有些工作会冲突，员工A和员工B对工作C的工作效率都是最高的，这是我们应该让A或者B换一份工作，但如果真这么做了，那么我们只能换到<strong>降低总体效率值的工作</strong>。</p><p>但我们现在只要求最优匹配，所以<strong>如果员工A换一份工作效率稍微低一些的工作的话，我们是可以接受的（对员工B也是如此）</strong></p><p><img src="/img/DeepLearning/Hungarian/image-20250110185620992.png" alt="图11"></p><p>那么在KM算法中的体现就是：<strong>对所有冲突的边的顶点做加减操作</strong>，令左边顶点值减0.1，右边顶点值加0.1。结果如下图所示。</p><p><img src="/img/DeepLearning/Hungarian/image-20200227185854835.png" alt="图12"></p><p>经过此操作后，再重新进行匹配操作。</p><p>恭喜！左3多了一条可匹配的边，因为此时左3对右2的匹配要求只需权重大于等于0.8+0即可，所以左3与右2匹配成功！</p><p><img src="/img/DeepLearning/Hungarian/image-20200227185923170.png" alt="图13"></p><p>最后进行左4的匹配。由于左4唯一的匹配对象右3已被左2匹配，发生冲突。进行一轮加减操作重新匹配后发现左四还是匹配失败。再经过两轮以后左4期望值降为0，放弃匹配。</p><p>至此KM算法结束。成功匹配三对，可以发现采用KM算法的匹配结果比之前采用匈牙利算法匹配的结果更加精准可靠。</p></li></ol><h2 id="四、代码实现">四、代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将yolo模型的检测框和卡尔曼滤波的跟踪框进行匹配</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">associate_detections_to_trackers</span>(<span class="hljs-params">detections, trackers, iou_threshold = <span class="hljs-number">0.3</span></span>):<br>    <span class="hljs-comment"># 检测框数</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(trackers) == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> np.empty((<span class="hljs-number">0</span>, <span class="hljs-number">2</span>), dtype = <span class="hljs-built_in">int</span>), np.arange(<span class="hljs-built_in">len</span>(detections)), np.empty((<span class="hljs-number">0</span>, <span class="hljs-number">5</span>), dtype = <span class="hljs-built_in">int</span>)<br>    <span class="hljs-comment"># 跟踪框数</span><br>    iou_matrix = np.zeros((<span class="hljs-built_in">len</span>(detections), <span class="hljs-built_in">len</span>(trackers)), dtype = np.float32)<br>    <span class="hljs-comment"># 计算检测框和跟踪框之间的IOU</span><br>    <span class="hljs-keyword">for</span> d, det <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(detections):<br>        <span class="hljs-keyword">for</span> t, trk <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(trackers):<br>            iou_matrix[d, t] = IOU(det, trk)<br>    <span class="hljs-comment"># 匈牙利算法进行匹配</span><br>    matched_indices = linear_sum_assignment(-iou_matrix)<br>    <span class="hljs-comment"># 未匹配的检测框</span><br>    unmatched_detections = []<br>    <span class="hljs-keyword">for</span> d, det <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(detections):<br>        <span class="hljs-keyword">if</span> d <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> matched_indices[<span class="hljs-number">0</span>]:<br>            unmatched_detections.append(d)<br>    <span class="hljs-comment"># 未匹配的跟踪框</span><br>    unmatched_trackers = []<br>    <span class="hljs-keyword">for</span> t, trk <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(trackers):<br>        <span class="hljs-keyword">if</span> t <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> matched_indices[<span class="hljs-number">1</span>]:<br>            unmatched_trackers.append(t)<br>    <span class="hljs-comment"># 未匹配的跟踪框</span><br>    matches = []<br>    <span class="hljs-keyword">for</span> d, t <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(matched_indices[<span class="hljs-number">0</span>], matched_indices[<span class="hljs-number">1</span>]):<br>        <span class="hljs-keyword">if</span> iou_matrix[d, t] &lt; iou_threshold:<br>            unmatched_detections.append(d)<br>            unmatched_trackers.append(t)<br>        <span class="hljs-keyword">else</span>:<br>            matches.append((d, t))<br>    <span class="hljs-comment"># 返回匹配结果</span><br>    <span class="hljs-keyword">return</span> np.array(matches), np.array(unmatched_detections), np.array(unmatched_trackers)<br></code></pre></td></tr></table></figure><h2 id="参考文献">参考文献</h2><ul><li><a href="https://www.cnblogs.com/ariel-dreamland/p/13522590.html">https://www.cnblogs.com/ariel-dreamland/p/13522590.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/459758723">https://zhuanlan.zhihu.com/p/459758723</a></li><li><a href="https://zhuanlan.zhihu.com/p/62981901">https://zhuanlan.zhihu.com/p/62981901</a></li><li><a href="https://blog.csdn.net/lemonxiaoxiao/article/details/108704280">https://blog.csdn.net/lemonxiaoxiao/article/details/108704280</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>DeepLearning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepLearning</tag>
      
      <tag>OpenCV</tag>
      
      <tag>目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Google SEO】如何做好一个网站的SEO？</title>
    <link href="/2025/01/10/SEO/SeoOptimistic/"/>
    <url>/2025/01/10/SEO/SeoOptimistic/</url>
    
    <content type="html"><![CDATA[<h1>[Google SEO] 如何做好一个网站的SEO？</h1><h2 id="一、为什么要做-WordPress-SEO优化？">一、为什么要做 WordPress SEO优化？</h2><p><strong>有流量的地方就有搜索，有搜索就离不开SEO。</strong> SEO获取的流量是最具价值的，也是相对稳定的。特别对于外贸网站而言，如果单纯依赖广告投放来吸引全球用户访问，随着竞争加剧，广告成本必然逐步上涨。</p><p>然而，通过搜索引擎优化（SEO）来获取流量，不仅无需额外付费，还能带来比Google Ads广告投放更高价值的流量。SEO不仅能够帮助网站在搜索引擎中占据更高的排名，而且这种流量是长期且持续的，与广告费用逐年攀升的趋势相比，SEO显得更加经济和高效。</p><h3 id="WordPress-做-SEO-优化的优势">WordPress 做 SEO 优化的优势</h3><ol><li><strong>开源免费，功能强大</strong>：WordPress 是一个开源平台，免费使用，并且具有强大的功能和灵活性，适合各种规模的 SEO 优化。</li><li><strong>结构合理，利于 SEO 布局</strong>：WordPress 默认的代码结构和页面层次设计有利于搜索引擎抓取，便于进行有效的 SEO 布局。</li><li><strong>主题模板丰富，外观多样化</strong>：WordPress 提供了丰富的主题模板，外观设计不易同质化，同时配合强大的 SEO 插件，能有效避免更换主题时 SEO 数据丢失的问题。</li><li><strong>开发者多，插件丰富</strong>：由于 WordPress 拥有庞大的开发者社区，几乎所有 SEO 所需的功能都可以通过现成的插件实现，节省了开发时间和成本。</li></ol><h2 id="二、WordPress-SEO-优化步骤">二、WordPress SEO 优化步骤</h2><p>首先你要拥有一个安装好了的WordPress网站，如果没有可以搜索一下相关教程。</p><h3 id="1-确定是否使用www域名">1. 确定是否使用www域名</h3><p><strong>直接上结论：</strong></p><ul><li>做国内SEO优化，建议使用带有www的域名；</li><li>做国外SEO优化，建议使用不带www的域名。</li></ul><p>目前主流的 SEO 观点推荐直接使用主域名（不带 www 的域名），同时将带有 www 的域名通过 301 重定向到主域名。这样可以集中网站的权重，避免重复内容问题，提升 SEO 效果。</p><p>然而，如果你的网站已经使用了 www 开头的域名，并且已经运营了一段时间，那么没有必要强制更换为不带 www 的域名。虽然建议使用，但这个对seo的效果没有直接的影响。</p><h3 id="2-添加SLL安全证书">2. 添加SLL安全证书</h3><p>众所周知，国内的任何网站都需要申请SLL安全证书，否则网站随时可能会被ban掉。</p><p>如果你的网站只面向Google，这个要求可以宽松一些。但Google也表示过，建议网站都启用SSL安全证书，这样可以更好的保障你的网站安全。</p><p>此外，SSL安全证书也有很多可以免费申请的，甚至有些虚拟主机可以一键安装SSL证书，也不必担心费用和技术问题。</p><p><a href="https://web.dev/articles/enable-https?hl=zh-Hans&amp;visit_id=638722810167143512-2861211603&amp;rd=1">使用HTTPS确保网站安全</a></p><h3 id="3-站点标题与副标题的优化">3. 站点标题与副标题的优化</h3><p>WordPress的设置里面带有站点标题和副标题两个选项。</p><p>站点标题通常是你网站的名称，而副标题则是对网站整体内容的简短描述。在副标题中，最好能够包含你网站的主要 SEO 关键词，以提升网站在相关搜索中的可见性。比如，如果你的网站是关于香水的，可以在副标题中加入如 <strong>“香水爱好者的香氛世界”</strong>、<strong>“高端香水推荐与评测”</strong>、<strong>“香水选购指南”</strong> 等相关关键词，这不仅有助于用户理解你网站的主题，也能提高搜索引擎对你网站的相关性评分。</p><p>只有网站标题包含了关键词，那么别人从搜索引擎搜寻相关内容才有可能看到你的网站。</p><h3 id="4-安装WordPress-SEO插件">4. 安装WordPress SEO插件</h3><p><a href="https://wpslimseo.com/">Slim SEO</a>，<a href="https://rankmath.com/">Rank Math</a>和<a href="https://cn.wordpress.org/plugins/wordpress-seo/">Yoast SEO</a>这三种插件都可以选择，都被广泛应用于网站中。</p><p>安装SEO插件的方法很简单，直接在WordPress后台插件里面选择添加，然后搜索SEO，上图中这4款SEO插件都可以考虑，<strong>但是一次只使用一款SEO插件就行了。</strong></p><p>这些SEO插件可以帮助你去规范网站的标题、描述和一些社会化标签的内容，而不会因为更换主题导致这些关键代码发生变化。</p><h3 id="5-设置SEO友好的固定链接">5. 设置SEO友好的固定链接</h3><p>WordPress 直接在后台设置里面修改即可。</p><p>推荐选择文章名这个格式的固定链接。</p><p><strong>注意：固定链接一旦确定就不建议在网站被搜索引擎收录很多页面后修改。</strong></p><h3 id="6-文章要带有关键字">6. 文章要带有关键字</h3><p>使用Yoast SEO和Rank Math，都会在你发文章的页面出现一个SEO提示框，会给你一些SEO建议，其中就包含使用Focus Keyword（焦点关键词/中心关键词）</p><p>关键词是页面内容的核心主题，搜索引擎通过分析页面中的关键词来确定该页面的相关性和排名。通常，在优化文章时，你需要围绕这个焦点关键词来创建内容，并确保它在标题、内容、元描述、图片ALT标签等地方出现，以帮助搜索引擎理解你的文章主题。</p><p>注意：能为了突出关键词然后去各种不合理的使用关键词，Google可以识别出来你是否是为了关键词而出现的关键词</p><h3 id="7-取一个好的标题">7. 取一个好的标题</h3><p>无论怎么取名，标题里面一定要包含你文章的主要关键词。例如下面这些：</p><ul><li>WordPress SEO优化终极解决方案</li><li>做好这些WordPress SEO优化，流量飙升</li><li>从这几点开始，做好WordPress SEO优化</li></ul><p>一个关键词可以组合成很多个不同的标题，但是哪个标题能够更多的增加点击率，也是一门学问。</p><p>英文网站的话可以借助一下几个网站测试下标题质量。</p><ul><li><a href="https://headlines.sharethrough.com/">Sharethrough标题分析器</a></li><li><a href="https://coschedule.com/headline-analyzer">CoSchedule标题分析器</a></li><li><a href="https://www.aminstitute.com/headline/">aminstitute–情感营销价值标题分析器</a></li><li><a href="https://www.impactbnd.com/blog-title-generator/blogabout">BlogAbout by Impact</a></li></ul><p>包括但不限于此，各位可以具体搜一搜其他的网站。</p><h3 id="8-编辑元描述增加点击率">8. 编辑元描述增加点击率</h3><p>在搜索结果页面中，标题下方的文字部分就是网页的<strong>元描述（Meta Description）</strong>。虽然Google曾表示，是否手动编写元描述并不会对排名产生直接影响，因为它会根据页面内容自动生成合适的描述，但如果你编写了元描述，它会优先考虑你提供的信息。</p><p>元描述不仅仅是一个简短的页面介绍，它也是影响用户点击率的关键因素之一。即使排名第二，如果你的元描述更具吸引力，用户可能会选择点击你的页面，而不是第一位的内容。因此，元描述的撰写同样需要一定的文案技巧，它可以帮助你提高搜索结果的点击率，进而间接影响页面的SEO表现。</p><p>然而，并不需要为每篇文章都手动编写元描述，这样既费时又费力。大多数站长并非专业文案，且SEO文案写作也需要一定技巧。你只需要确保为网站的重点页面编写清晰、吸引人的元描述，剩下的内容可以交给Google根据页面内容自动生成。</p><h3 id="9-代码优化">9. 代码优化</h3><p><strong>(1) <code>&lt;h&gt;</code> 标签的使用</strong></p><p>虽然即便你网站有多个H1标签，谷歌也可以识别出来哪个是正确的标题。</p><p><code>&lt;h1&gt;</code>和<code>&lt;h2&gt;</code>标签都能很好地突出显示页面的重要标题（标题含有关键词）,这有助于排名的提升。</p><p><strong><code>&lt;h&gt;</code>标签的使用事项</strong>：</p><ul><li><code>&lt;h1&gt;</code>标签和<code>&lt;h2&gt;</code>标签，不建议同时使用</li><li><code>&lt;h1&gt;</code>标签和<code>&lt;h2&gt;</code>标签在使用的时候建议包含关键词</li><li><code>&lt;h1&gt;</code>标签和<code>&lt;h2&gt;</code>标签在使用的时候建议只出现一次</li><li><code>&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;</code>标签SEO作用较小，建议不要乱用</li><li><code>&lt;h6&gt;</code>可以用在首页友情链接处，以降低友情链接对页面目标关键词的影响</li></ul><p><strong>(2) <code>&lt;strong&gt;</code> 标签的使用</strong></p><p><code>&lt;strong&gt;</code>标签表示强调的作用，有加强语气的意思，在浏览器中表现为加粗显示，可以突出标签内文本内容。</p><p>使用该标签可以使页面突出关键词，有助于关键词的排名提升。</p><p><strong>(3) <code>&lt;img&gt;</code> 标签中的alt属性</strong></p><p>下图中这个图片的替代文本，就是alt标签。</p><p><img src="/img/SEO/image-20250112205619603.png" alt=""></p><p>html代码的格式，如果你用的WordPress，那么就是下面这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;class值&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;图片地址&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;alt标签内容&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;宽度&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;高度&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>alt标签就是为图片的文字提示，通常用来描述这个图片是什么内容，alt标签可以起到一定的seo作用，同时也可以在图片失效时起到文章救场的作用。</p><p>当你写的文章图片丢失了，网页可以显示图片的alt属性值，用户在阅读文章时可以脑补一下你图片内容，比纯粹的一张挂掉的图片更友好。</p><p>此外，在别人通过Google图片搜索时，你的图片因为添加了alt标签也有机会被搜索到。它是影响SEO的一个重要因素</p><h3 id="10-长文章使用目录">10. 长文章使用目录</h3><p>Google相对来说更加喜欢长文章，但是长文章并不是太适合用户阅读，所以增加文章目录一方面可以提高用户体验度，另一方面也方便搜索引擎确定文章内容。</p><p>WordPress添加文章目录的方法非常简单，安装一个目录插件然后配合合理的标题标签使用就可以了。</p><h3 id="11-合理命名图片">11. 合理命名图片</h3><p>一般情况，我们上传到网站上的图片名字都是随机的或者直接使用中文命名。</p><p>建议如下：</p><ol><li>不要使用中文名图片</li><li>不要使用无意义的命名</li><li>建议使用和内容相关的英文词来命名</li><li>单词之间包含连字符分开</li><li>文章特色图片名称包含关键词</li></ol><h3 id="12-注意文章写作技巧">12. 注意文章写作技巧</h3><p>文章是获得搜索排名的核心要素，因此写好一篇文章是进行SEO优化的基础。在撰写文章时，<strong>第一段内容</strong>对SEO优化尤其重要，因为它不仅帮助搜索引擎理解文章的主题，还能吸引读者的注意力。</p><p>在第一段中，通常会包含文章的核心关键词，例如本文的 <strong>“WordPress SEO优化”</strong>，这有助于提升搜索引擎的相关性评分，同时也确保搜索引擎能准确识别文章内容的主题。此外，第一段也是访客接触到的第一个内容，如果它没有吸引到读者，或者没有包含他们搜索的关键词，那么他们很可能会迅速离开网站，转而点击其他搜索结果。</p><p>工具如 <strong>Yoast SEO</strong> 和 <strong>Rank Math</strong> 在写文章时，会提供 SEO 优化建议，帮助你提升页面的SEO效果。这些建议可以作为参考，但并不需要完全按照其提示来操作，最终的优化策略应根据你内容的实际情况和目标进行调整。</p><h3 id="13-注意文章长度">13. 注意文章长度</h3><p><img src="/img/SEO/image-20250112205626863.png" alt=""></p><p>我们在日常使用Google搜索的时候会发现，往往一些长文章会获得不错的排名。</p><p>但是，这个观点也要具体问题具体分析，并不是说所有内容都适合长文章。</p><p>在满足用户搜索需求的基础上，适当的补充一下内容宽度，还是很有好处的。</p><h3 id="14-使用合适的Nofollow链接">14. 使用合适的Nofollow链接</h3><p>如果你没有特殊设置，那么你文章里面插入的每一个链接都是nofollow的。</p><p>什么是nofollow链接？</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">&lt;<span class="hljs-keyword">a</span> href=<span class="hljs-string">&quot;https://laojiao1.github.io/&quot;</span> <span class="hljs-built_in">rel</span>=<span class="hljs-string">&quot;nofollow&quot;</span>&gt;Laojiao&lt;/<span class="hljs-keyword">a</span>&gt;<br></code></pre></td></tr></table></figure><p>像上面这样的包含rel=”nofollow”属性的就是nofollow链接。</p><p>添加nofollow的作用是告诉搜索引擎不要追踪这个链接，维基百科的解释如下：</p><blockquote><p>nofollow 是 HTML 中的一个属性，用于告诉搜索引擎不要追踪特定的网页链接。<br>可以用于阻止在 PR 值高的网站上以留言等方式添加链接从而提高自身网站排名的行为，以改善搜索结果的质量，防止垃圾链接的蔓延。<br>网站站长也可以对其网页中的付费链接使用 nofollow 来防止该链接降低搜索排名。</p></blockquote><h3 id="15-做好内部链接优化">15. 做好内部链接优化</h3><p>内部链接优化这个很好理解，在一篇文章中插入的来自本网站另一篇文章的链接，就是内部链接</p><p>内部链接的作用一方面是把你网站的文章和内容串联起来，另外一方面就是丰富文章的内容宽度和深度。</p><h3 id="16-做好外部链接优化">16. 做好外部链接优化</h3><p>外部链接优化就是指非自己网站的其他网站给你留下的链接，叫做外链。</p><p>例如你觉得我这篇文章不错，转发到自己博客，或者自己博客发文章插入了这篇文章的地址，那么就算帮我做了一条外链。</p><p>但外链始终是在别人网站上，不可控。此外，做外链是件挺费精力的事情。</p><p>如果你能获得一些高质量的外部链接对SEO排名效果比较显著。（权威性的网站，或者说大网站，可以给你留链接，那么这种外链质量就挺高。）</p><p>不推荐买付费链接，买的不好可能惹火烧身直接没有排名了。</p><h3 id="17-设置网站地图并提交你的网站">17. 设置网站地图并提交你的网站</h3><p>网站地图又称为sitemap，它是你网站上所有文章和页面的链接汇总，可以帮助搜索引擎发现你网站上的页面。</p><p>现在主流的WordPress SEO插件都支持sitemap功能，不需要额外安装对应的插件。</p><p>设置好网站地图后，可以去各大搜索引擎提交你的站点地图。例如Google、Bing、Yandex等。</p><p>这里涉及到Google Search Console的使用，可以搜一搜相关教程，这里就不细说了。</p><h3 id="18-做好关键词研究">18. 做好关键词研究</h3><p>自己使用Google搜索能发现很多关键词，例如下图中就是和Google SEO相关的一些搜索词。</p><p><img src="/img/SEO/image-20250112205632815.png" alt=""></p><p><strong>关键词研究是贯穿在整个SEO过程中的，几乎每一步都会涉及到关键词研究。</strong></p><p>英文网站有很多研究关键词的工具，例如<a href="https://kwfinder.com/">KWFinder</a>，<a href="https://semrush.sjv.io/mgnWAZ/">SEMrush</a>和<a href="https://ahrefs.com/">Ahrefs</a>.</p><p>中文网站可以用爱站、5118等网站。</p><h3 id="19-使用结构化标签">19. 使用结构化标签</h3><img src="/img/SEO/image-20250112205636575.png" style="zoom:67%;" /><p>Google是非常喜欢这些 Schema标签的。</p><p>Rank Math插件就支持Schema标签，也可以单独安装 Schema插件实现。</p><p>一些网站带有评分的结果，实际上就是使用了schema标签。</p><h3 id="20-保证重要文章内容持续更新">20. 保证重要文章内容持续更新</h3><h3 id="21-优化网站速度">21. 优化网站速度</h3><p>网站速度也是影响网页排名的一个因素，研究显示，一个页面超过4秒还没有打开，那么四分之一的访客会选择放弃该网站。</p><p>WordPress默认的安装完毕高级主题和对应的插件后，不做优化打开速度是比较慢的，所以需要对速度做一些优化。</p><p><a href="https://zhuanlan.zhihu.com/p/564720348">24种解决方法</a></p><h3 id="22-死链检测">22. 死链检测</h3><p>网站运营了一段时间后，可能会出现一些死链（也就是无法打开，访问错误的链接）。</p><p>这些死链会影响搜索引擎的抓取，以及降低用户体验。</p><p>可以安装 404 Solution 插件来检查死链的存在。</p><h3 id="23-确保移动端访问正常">23. 确保移动端访问正常</h3><p>WordPress大多数的主题都是响应式设计的，会根据不同浏览器展示不同的布局，所以一般情况下都不用担心移动端不兼容的问题。</p><p>同时，Google有一个<a href="https://search.google.com/test/mobile-friendly">移动端检测工具</a>，你可以去测试下。</p><p>不过实际测试中，这个结果有bug，明明自己用手机测试打开正常的网站，会在Google移动端检测工具里面报错，所以也不用太担心这个检测，以自己网站实际测试为准（国外也有很多站长碰到过这个问题，目前没有可行的解决办法）。</p><h3 id="24-安装统计代码">24. 安装统计代码</h3><p>安装统计代码会一定程度上拖慢网站速度，不过分析统计数据是做SEO优化的一个日常工作。</p><p>外贸网站奶爸推荐使用Google Analytics（分析），可以配合Google Search Console一起使用。</p><h3 id="25-跟踪关键词排名">25. 跟踪关键词排名</h3><p>如果你是专业做seo的，那么关注关键词的排名也是很重要的一项工作。</p><p>根据排名变化去分析seo效果和判断如何继续优化和保持排名。</p><p>作为企业网站，你自己网站的几个主要关键词排名变化还是建议每天关注一下的。</p><p>看看自己排名有没有变化，有没有出现新的对手网站，然后分析对手网站。</p><h3 id="26-使用高质量的图片">26. 使用高质量的图片</h3><p>高质量图片通常文件大小会更大，所以如果你网站本身的网速比较慢，那么使用高质量图片的话最好使用一个CDN服务，避免图片拖慢网站速度。</p><p>另外高质量图片主要是为了获得更好的Google图片搜索排名，如果你的网站业务跟着图像来的用户不多，那么也不用特意弄高质量图片。</p><p>只要文章配图清晰即可。</p><h3 id="27-增加用户会话时长">27. 增加用户会话时长</h3><p>会话时长是对Google网站排名影响比较大的一个因素，同时对应的是“<strong>网站跳出率</strong>”。</p><p>网站跳出率低，那么相应的会话时长就会比较高。</p><p>而跳出率高，那么会话时长通常也不会太久。</p><p>跳出率过高，会话时长短，Google会认为你的网页内容没有满足到用户的搜索需求。</p><p>不过，这个并不是绝对的，要根据实际文章内容来决定，例如一个解决问题的文章，别人进来一眼看到解决办法，然后关闭网页，实际上是满足了他的用户需求的。</p><p>而你为了去增加会话时长，故意把答案藏得很深，反而有可能导致Google降低网页排名。</p><h3 id="28-删除无意义文章">28. 删除无意义文章</h3><p>一个网站做seo优化排名，那么网站整体的内容越单一，越精准，优化起来越简单。</p><p>国外称这个为“content pruning”，内容修剪。</p><p>就是把一些和网站主题内容不相关的，过时了的文章删了，<strong>宁愿要少量的高质量内容，也比大量的无关内容更好</strong>。</p><p>奶爸建站笔记之前也包含了一些带娃的日志，后面就统一删除了。</p><h3 id="29-删除重复内容">29. 删除重复内容</h3><p>有时候时间久了，自己都不知道同一个话题写了相同的文章了。可能两篇文章有一些细微的差别。</p><p>但是最好是能够把两篇文章合二为一，删除其中的一篇，然后301重定向到另外一篇。</p><h3 id="30-创建关于页面">30. 创建关于页面</h3><p>关于页面、联系我们页面，包括隐私申明页面，这些都可以增加网站的信任度，会间接影响网站访客对你网站的宣传力度，从而影响到网站的流量和排名。</p><h3 id="31-删除垃圾评论">31. 删除垃圾评论</h3><p>通常网站上线后，都会受到垃圾评论的骚扰。</p><p>这些垃圾评论往往都是包含了很多的链接，而一些网站管理员以为是真人评论，特别高兴，就通过了审核。</p><p>实际上这些带有链接的垃圾评论会损坏你网站形象，影响SEO排名的。</p><h3 id="32-添加面包屑导航">32. 添加面包屑导航</h3><p>面包屑导航一方面可以让用户清楚的知道自己所处网站位置，可以方便切换到上一级目录。</p><p>另外一方面也增加了搜索引擎蜘蛛的爬行轨迹。</p><p>一些高级WordPress主题会自带面包屑导航功能，如果你的主题不支持，那么也可以自己通过插件或者代码来实现。</p><h3 id="33-使用外部链接">33. 使用外部链接</h3><p>外部链接又叫“反向链接”或“导入链接”,是指其他网站的链接指向你的网站。</p><p>外部链接包括：单向外链和双向外链（友情链接）</p><p>比如本文最后的“参考文章”就是一种外链形式。</p><p><strong>外链的作用</strong>：</p><ul><li>增加网站的权重</li><li>提高网站关键词排名</li><li>提高网站流量</li></ul><p><strong>外链的查询：</strong></p><ul><li>谷歌查询：link:+网站域名地址</li><li>百度查询：domain:+网站域名地址</li></ul><p>或者利用工具：</p><ul><li>爱站网：<a href="https://link.aizhan.com/">https://link.aizhan.com/</a></li><li>站长工具：<a href="https://outlink.chinaz.com/">https://outlink.chinaz.com/</a></li></ul><p><strong>外链的增加方法：</strong></p><ol><li>友情链接：个人关系</li><li>论坛外链：比如个人回复，帖子回复，签名档</li><li>博客外链：友情链接模块，博客文章，博客评论</li><li>提交外链（花money）</li><li>问答平台：可以在一些问答的回复中增加外链，但要注意回复的质量。</li></ol><p><strong>外链的注意事项：</strong></p><ul><li>循序渐进，不要一下增加很多</li><li>注意质量，不要单纯追求数量</li><li>内容相关性要强</li></ul><h3 id="34-状态码的解读与优化">34. 状态码的解读与优化</h3><h4 id="301重定向：">301重定向：</h4><p>页面永久性移走（301重定向）是一种非常重要的“自动转向技术”。</p><p>它是作为网址重定向最为可行的一种方法：当用户或搜索引擎向网站服务器发出浏览请求时，服务器返回的HTTP数据流中头信息(header)中的状态码的一种，表示本网页永久性转移到另一个地址。</p><p><strong>网站301优化意义</strong>：</p><ol><li>网站改版完成，先将新版上线，在线上保持一段时间新旧内容共存。</li><li>新旧内容同时存在一段时间，且新版内容已开始收录后，对新旧内容设置301跳转，将旧版内容指向新版对应内容。</li><li>301重定向有利于网站首选域的确定，对于同一资源页面多条路径的301重定向有助于URL权重的集中。</li></ol><p>按照上述操作方式在现有情况下能够尽可能的降低网站因改版带来的流量损失，提高用户体验度，同时有利于网站优化</p><h4 id="404错误页面：">404错误页面：</h4><p><img src="/img/SEO/404.png" alt="404"></p><p>404页面面是客户端在浏览网页时，服务器无法正常提供信息，或是服务器无法回应，且不知道原因。404错误信息通常是在目标页面被更改或移除，或客户端输入页面地址错误后显示的页面。</p><p>可以制定一些样式好看或带有提示的404页面，提交到自己的网站上，来提醒客户一些错误信息。</p><h3 id="35-链轮">35. 链轮</h3><p><strong>什么是链轮？</strong><br>SEO链轮(SEO Link Wheels)是从国外引入国内的，一种比较新颖的SEO策略。是一种比较先进的网络营销方式。</p><p>SEO链轮是指通过在互联网上建立大量的独立站点或是在各大门户网站上开设博客，这些独立站点或是博客群通过单向的、有策略、有计划紧密的链接并都指向要优化的目标网站，以达到提升目标网站在搜索引|擎结果中的排名</p><p><strong>链轮的作用：</strong></p><ul><li>提升网页权重</li><li>提升网页关键词排名</li><li>提升网页搜索引擎权重</li><li>提升网页知名度</li><li>提升网站流量</li></ul><img src="/img/SEO/ChainWheel.png" style="zoom:50%;" /><h2 id="三、WordPress-SEO优化总结">三、WordPress SEO优化总结</h2><p>实际在运营网站的过程中，没有必要每一条都去做，毕竟很少有人可以一直坚持所有页面都做完这么多条优化项目的。</p><p>只需要做好基础的SEO优化，一些竞争比较大的页面和关键词去详细做一下SEO。做到比对手的内容更准、更全，排名超过它的机会就会大很多。</p><h2 id="四、WordPress-SEO插件推荐">四、WordPress SEO插件推荐</h2><ol><li><a href="https://yoast.com/wordpress/plugins/seo/">Yoast SEO</a> 目前WordPress用户量第一的SEO插件，分为免费版和高级版；</li><li><a href="https://aioseo.com/">All in one SEO</a> 用户量第二的SEO插件，分类免费版和高级版；</li><li><a href="https://rankmath.com/">Rank Math</a> 上升势力强劲的SEO插件，免费版带有很多高级功能，也推出了高级版；</li><li><a href="https://www.wbolt.com/plugins/sst?invite=316">Smart SEO Tool</a> 最符合国人使用习惯的SEO插件，完全免费；</li><li><a href="https://www.wbolt.com/plugins/bsl-pro?invite=316">多合一搜索自动推送管理插件</a> 付费插件，可以帮你把文章推送给搜索引擎收录，中文网站推荐使用；</li><li><a href="https://www.wbolt.com/plugins/skt?invite=316">热门关键词推荐插件Pro</a> 不知道怎么写文章做SEO？这个插件必不可少，中英文网站均适用；</li><li><a href="https://www.wbolt.com/plugins/spider-analyser?invite=316">Spider Analyser</a> 统计搜索引擎对你网站爬取信息的，帮助分析收录情况，喜欢分析网站数据的可以使用。</li></ol><h1>参考文章</h1><ul><li><a href="https://blog.naibabiji.com/google-seo/wordpress-seo.html">https://blog.naibabiji.com/google-seo/wordpress-seo.html</a></li><li><a href="https://www.bilibili.com/video/BV1m4411A79a?spm_id_from=333.788.videopod.episodes&amp;vd_source=2b06cc402150237b16279df9e94ff252">https://www.bilibili.com/video/BV1m4411A79a?spm_id_from=333.788.videopod.episodes&amp;vd_source=2b06cc402150237b16279df9e94ff252</a></li></ul><p><strong>注：本篇仅用于学习记录，内容稍有粗糙，自己看为主</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Google SEO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Google SEO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Google SEO】Google抓取网页流程和搜索算法</title>
    <link href="/2025/01/09/SEO/GoogleSearch/"/>
    <url>/2025/01/09/SEO/GoogleSearch/</url>
    
    <content type="html"><![CDATA[<h1>2. Google抓取网页流程和搜索算法</h1><h2 id="一、Google-搜索的基本流程">一、Google 搜索的基本流程</h2><p>从视频中可以看到Google抓取和输出一个网页在搜索结果的流程大概是：</p><ol><li>用户在 Google 搜索框中输入关键词或查询短语，发起搜索请求。</li><li>Google 的搜索引擎蜘蛛（Googlebot）会遍历互联网上的网页，收集它们的内容（<strong>抓取</strong>）并加入到Google的索引库中（<strong>索引</strong>）。</li><li>当用户发起查询时，Google 会根据多个排名因素（如页面内容、关键词相关性、网站质量等）对索引中的网页进行排序。Google 会使用算法评估哪个页面最符合用户查询的需求，在自己的索引库中找到合适的网页展示给用户</li></ol><p><img src="/img/SEO/image-20250109203925071.png" alt=""></p><p>想要Google发现你的网站并且加入索引，我们可以通过：</p><ul><li><p>提交<strong>站点地图（Sitemap）</strong>—— 一个包含你网站所有重要页面的文件，可以帮助搜索引擎更容易地发现并抓取你的内容。</p></li><li><p>通过 <strong>Google Search Console</strong> 提交网站地图 —— 确保 Googlebot 能更快地抓取和索引你的页面。</p></li></ul><p>以上两种方式来告诉Google你的网站链接。</p><p>Google为你网页计算内容排名的时候，就会考虑你页面的标题、描述、url或者内容等地方是否会出现对应的关键词，或者关键词的近义词。</p><p><img src="/img/SEO/image-20250109204435550.png" alt=""></p><h2 id="二、Google搜索排名算法">二、Google搜索排名算法</h2><p>假如你的网站允许被Google抓取，那么Google机器人就会把你的网站内容收录到索引库中，但索引库中必然会有千亿级别的网页。Google搜索排名算法就是对这些索引进行整理和排序，以最快的速度把用户所需要的内容呈现出来。</p><p><strong>Google的排名系统由多个算法共同运作，而不是单一的算法。为了提供最相关的信息，Google的搜索算法会综合考虑多种因素，包括查询的关键词、网页的相关性和可用性、信息来源的权威性，以及用户的位置和个人设置。每个因素的权重会根据查询的不同而有所变化。例如，对于查询字典定义类的信息，网页的相关性更为重要；而在查询时事新闻时，内容的新鲜度则会被赋予更高的权重。</strong></p><h3 id="1-分析关键词">1. 分析关键词</h3><p>Google有一套完整的语言模型，会根据你输入的关键词进行一系列的分析。</p><p>例如：</p><ul><li>搜索“如何换灯泡” —— 这里“换”的意思是“替换”</li><li>搜索“如何换货币” —— 这里“换”的意思是“兑换”</li></ul><h3 id="2-挑选与搜索内容相符合的页面">2. 挑选与搜索内容相符合的页面</h3><p>当Google了解你的搜索意图后，Google会从自己的索引库中寻找与查询信息相匹配的网页。</p><p><img src="/img/SEO/image-20250109205828224.png" alt=""></p><p>也就是说，在搜索时，Google算法会在索引中查询您的搜索关键词以找到合适的网页，算法分析的内容包括但不限于在某个网页上的<strong>关键字或者相关信息</strong>的<strong>出现频率</strong>。</p><p><strong>这也给我们在做SEO时提供了启发</strong>——想要获得某个关键词的排名，那么你的文章标题和内容应该包含一定的关键词，帮助Google算法了解你的网页内容从而推荐给相关用户。但是一定不能为了排名而乱插入关键词。</p><h3 id="3-为网页排名">3. 为网页排名</h3><p><img src="/img/SEO/image-20250109205808224.png" alt=""></p><p>网页排名是搜索引擎根据一系列因素决定特定网页在搜索结果中显示位置的过程。Google 的排名系统基于复杂的算法，通过评估网页的相关性、质量、权威性等来确定排名。</p><p>这个排名过程中，会根据用户在网页的停留时间，PageRank，或者内链接等因素多方面考虑。因此网页的排名是在不断变化当中的。</p><p>Google 对站长提出了基本要求：</p><ul><li>在设计网站时，应该首先关注用户的需求，而不是单纯为了迎合搜索引擎。</li><li>避免做出任何欺骗用户的行为。</li><li>不要采用不正当手段来提升搜索引擎排名。衡量自己做法是否合适的一种方式是，想象自己需要向竞争对手或 Google 的员工解释这些做法时，是否能心安理得。另一个自我测试的方法是，问自己：“这是否能真正为用户提供价值？如果没有搜索引擎的存在，我是否还会这么做？”</li><li>思考怎样才能让自己的网站在行业中独树一帜，具有独特性、价值或者吸引力，从而在同类网站中脱颖而出。</li></ul><h3 id="4-返回最佳结果">4. 返回最佳结果</h3><p>在第三步为网页排名中，Google对索引库的页面有一个基础排名后，并不一定在实际显示出来的结果排名中就一定位于第一名。真正的第一名，Google还会根据一些其他因素来考虑。</p><p><img src="/img/SEO/image-20250109210121782.png" alt=""></p><p>假设用户搜索“如何选择适合的跑步鞋”。</p><p>Google会首先根据关键词匹配和页面相关性对多个网页进行基础排名。然而，如果其中一篇文章刚刚更新，包含了2025年最新款的跑步鞋推荐，而另一篇文章发布于几个月前没有最新信息，那么即使后者在基础排名中较高，Google可能会优先显示更新的页面，因为它提供了更具时效性的内容。</p><p>此外，页面的加载速度和移动端体验也会影响最终排名，哪怕基础排名较低的页面提供了更好的用户体验，Google也可能将其排在前面。</p><h3 id="5-搜索环境和地理位置">5. 搜索环境和地理位置</h3><p>Google 在搜索结果排序时，会根据你的地理位置和个人搜索历史来调整显示内容。</p><p>这意味着，不同国家和地区的用户搜索相同的关键词时，得到的搜索结果可能会有所不同。</p><p><img src="/img/SEO/image-20250109210508669.png" alt=""></p><p>例如，假设你搜索“最佳餐厅”。如果你位于纽约，Google会优先显示你所在城市的餐厅推荐，而不是全球或其他城市的餐厅。即使其他地方的餐厅排名很高，Google会根据你的位置提供更相关的本地搜索结果。此外，如果你过去经常搜索过某些餐厅或餐饮相关的内容，Google可能会根据你的搜索历史推荐你可能感兴趣的餐厅，进一步个性化你的搜索结果。</p><h2 id="参考文献">参考文献</h2><ul><li><a href="https://www.google.com/intl/zh-CN/search/howsearchworks/crawling-indexing/">https://www.google.com/intl/zh-CN/search/howsearchworks/crawling-indexing/</a></li><li><a href="https://www.google.com/intl/zh-CN/search/howsearchworks/algorithms/">https://www.google.com/intl/zh-CN/search/howsearchworks/algorithms/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Google SEO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Google SEO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Google SEO】Google SEO 初探</title>
    <link href="/2025/01/09/SEO/SeoExplore/"/>
    <url>/2025/01/09/SEO/SeoExplore/</url>
    
    <content type="html"><![CDATA[<h1>1. Google SEO——从搜索引擎优化中获得更多免费流量</h1><h2 id="一、什么是Google-SEO？">一、什么是Google SEO？</h2><p>SEO是搜索引擎优化的缩写，Google SEO就是针对Google的搜索引擎优化。</p><p>是在符合Google优化规则的前提下对网站进行一系列的设置和优化，让网站获得更好的搜索排名，从而获得更多的免费流量。</p><h2 id="二、为什么SEO很重要？">二、为什么SEO很重要？</h2><p>每天都有很多人通过Google搜索找到自己需要的东西，而我们做SEO优化就是为了获得更好的搜索排名，从而让更多潜在用户访问你的网站，进而产生成交，带来收益。</p><h2 id="三、如何做SEO？">三、如何做SEO？</h2><p>Google的建议是你应该搭建一个对用户有用的网站，任何优化都是用于改善用户体验。简单理解就是以用户体验为首位，发布有价值的文章内容，文章的标题和内容部分包含有意义的搜索关键词。</p><p>PS：<a href="https://www.by928.com/guizhou/502.html">外贸网站SEO不是给钱就能成的</a></p><h3 id="第一步：关键词研究">第一步：关键词研究</h3><p><strong>关键词</strong>，英文名叫<strong>Keywords</strong>，简单来说就是你这个网站希望别人通过什么词语搜索到你。</p><p>选取关键词是第一步也是最重要的一步。如果选错了关键词，那么在整个SEO过程中都会走很多的弯路。假如最开始的定位并非做现在的内容，就会导致定位更换几次，如果关键词没定好，内容规划起来就很麻烦。</p><p>很多外贸网站在设置标题时，仅仅使用公司名称，或者干脆不设置标题，这样做不利于SEO优化。除非你是全球知名品牌，否则很少有人会通过你的品牌名来寻找你的网站。为了提升曝光率和流量，你的标题应该<strong>包含与你的产品和服务相关的关键词</strong>。比如，你可以将标题设置为：“XXX – 手机配件批发, 手机壳, 数据线, 手机充电器制造商”。这样，潜在客户在搜索“手机配件”、“手机壳”、“数据线”或“手机充电器制造商”等相关关键词时，就有更高的机会找到你的网站，提升网站的可见性和搜索排名。</p><h3 id="第二步：编写友好内容">第二步：编写友好内容</h3><p>简单来说就是站在用户的角度来写文章，确保内容不仅对搜索引擎有利，更能解决用户的实际问题，提升用户体验。</p><p>例如，香水网站在编写文章时，想着的就是提供香水选购的全面指南，同时也有人搜索“男士香水推荐”、“女士香水品牌”、“香水购买指南”等词汇，因此你看到的这个页面标题叫“香水购买指南_ 男士香水推荐 _女士香水品牌推荐 | 香水之家”。</p><p>满足SEO基本要求：</p><ol><li>内容满足用户需要</li><li>内容有价值</li></ol><p>内容优化还有很多细节要做，例如标题标签优化，Meta描述优化，URL优化，内容优化，内部链接，移动端优化等等可以操作的地方。</p><h3 id="第三步：内部链接优化">第三步：内部链接优化</h3><p><img src="/img/SEO/%E5%86%85%E9%93%BE%E5%9B%BE.png" alt="内链"></p><p>如上图，把网站的文章页面串联起来。</p><p>简单来说，就是那些在文本里可以点击的链接，点进去同样是该网站下的文章或者页面，这就是内链。</p><p>内链建设时要保证顺其自然，不要刻意添加，否则会导致网页结构紊乱，劝退用户的阅读意愿。应该是文章写到那个地方，在合适的地方添加一个对用户有帮助的链接。</p><h3 id="第四步：外部链接建设">第四步：外部链接建设</h3><p>SEO界有一句俗话——“内容为王，外链为皇”，所谓外部链接就是其他网站指向你网站的链接。</p><p>作为商业网站，外联是提高网站可信度和排名的关键因素。</p><p>具体来说有以下几种方式（其实就是蹭流量）：</p><ul><li><p><strong>获得高质量的外部链接</strong>：从相关领域的网站或博客获取高质量的反向链接。</p></li><li><p><strong>客座博客</strong>：写一些与自己业务相关的文章，发布在其他高流量网站或博客上，获得链接。</p></li><li><p><strong>社交媒体</strong>：通过社交媒体渠道吸引流量，提升品牌曝光，并间接影响SEO。</p></li></ul><p>但有一点一定要注意：<strong>不要花钱买低质量外链！</strong></p><h2 id="四、Google-SEO优化工具">四、Google SEO优化工具</h2><p>一些很好用的工具可以来帮助我们更加高效的进行SEO工作，提升可行度。</p><h4 id="Google-Search-Console"><a href="https://developers.google.cn/search/docs/monitor-debug/search-console-start?hl=zh-cn">Google Search Console</a></h4><p>Google Search Console又称谷歌搜索控制台、谷歌管理员工具、谷歌站长工具，是Google官方推出的站点管理工具，<strong>如果Google的搜索蜘蛛发现你网站有任何问题了，就会通知你</strong>。你也可以在上面看到很多网站在Google上面的数据。</p><h4 id="Google-Analytics"><a href="https://developers.google.cn/analytics?hl=zh-cn">Google Analytics</a></h4><p><strong>Google Analytics</strong> 是一款由 Google 提供的免费网页分析工具，<strong>添加到网站后可以告诉你网站每天的流量信息</strong>。</p><p><strong>主要功能：</strong></p><ol><li><strong>访问量分析</strong>：查看网站的访问次数、页面浏览量、访客来源等。</li><li><strong>用户行为追踪</strong>：分析用户在网站上的行为，如浏览的页面、停留时间、跳出率等。</li><li><strong>流量来源</strong>：分析访客是通过搜索引擎、社交媒体、广告还是直接访问来到网站。</li><li><strong>受众分析</strong>：查看访客的地理位置、设备、浏览器等信息，帮助你优化用户体验。</li></ol><p>这些数据可以用来分析网站的用户访问情况，然后进行对应的SEO调整，是很重要的一项工作。</p><p>当然，SEO工具只是辅助，关键还是网站内容和基础的SEO优化。</p>]]></content>
    
    
    <categories>
      
      <category>Google SEO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Google SEO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机视觉】目标追踪检测——卡尔曼滤波</title>
    <link href="/2025/01/09/DeepLearning/kalman/"/>
    <url>/2025/01/09/DeepLearning/kalman/</url>
    
    <content type="html"><![CDATA[<h1>卡尔曼滤波——目标追踪检测</h1><h2 id="一、背景介绍">一、背景介绍</h2><p>卡尔曼滤波（Kalman）是一种在单目标和多目标检测领域中的常用算法，卡尔曼滤波可以看做一种<strong>运动模型</strong>，用来对目标的位置进行预测，并且利用<strong>预测结果对跟踪的目标进行修正</strong>。它能在存在诸多不确定性情况的组合信息中<strong>估计动态系统的状态</strong>，是一种强大的、通用性极强的工具。</p><p>只要是存在不确定信息的动态系统，卡尔曼滤波(Kalman)就可以对系统下一步要做什么做出有根据的推测。即使有噪声信息干扰，卡尔曼滤波通常也能很好的弄清楚究竟发生了什么，找出现象间不易察觉的相关性。因此卡尔曼滤波(Kalman)非常适合不断变化的系统。</p><p>它的优点还有内存占用较小（只需保留前一个状态）、速度快，是实时问题和嵌入式系统的理想选择。</p><h2 id="二、卡尔曼滤波的原理">二、卡尔曼滤波的原理</h2><p>目标的位置，速度，加速度的测量值往往在任何时候都有噪声。卡尔曼滤波利用目标的动态信息，设法去掉噪声的影响，得到一个关于目标位置的好的估计。这个估计可以实对<strong>当前目标位置</strong>的估计，也可以是对<strong>将来位置</strong>的估计，同时也可以是<strong>对过去位置</strong>的估计。</p><ul><li><strong>场景描述</strong></li></ul><p>我们假设一个简单的场景，有一辆小车在行驶，它的速度是v，可以通过观测得到它的位置p,也就是说我们可以实时的观测小车的状态。</p><p>假设小车在某一时刻的状态可以表示为如下向量：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>p</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>v</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\vec{x} =  \begin{bmatrix} p \\ v \\ \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p><p>虽然我们比较确定小车此时的状态，无论是计算还是检测都会存在一定的误差，所以我们只能认为当前状态是其真实状态的一个<strong>最优估计</strong>。那么我们不妨认为当前状态服从一个高斯分布，如下图所示：</p><p><img src="/img/DeepLearning/kalman/image-20250109112459878.png" alt="图1"></p><p>高斯分布的中心 <code>μ</code> 就是图中的 X<sub>k</sub></p><ul><li><p><strong>预测下一时刻的状态</strong></p><p>通过一些物理学知识来预测小车的下一个状态，即通过k-1时刻的位置和速度，可以推测下一个时刻的状态为：</p></li></ul><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>p</mi><mi>k</mi></msub><mo>=</mo><msub><mi>p</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>v</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">Δ</mi><mi>t</mi><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>a</mi><mi mathvariant="normal">Δ</mi><msup><mi>t</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">p_k = p_{k-1} + v_{k-1}Δt + \frac{1}{2}aΔt^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord">Δ</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal">a</span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub><mo>=</mo><msub><mi>v</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>a</mi><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">v_k = v_{k-1} + aΔt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">a</span><span class="mord">Δ</span><span class="mord mathnormal">t</span></span></span></span></span></p><p>​写成矩阵的形式：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mover accent="true"><mi mathvariant="bold">x</mi><mo>^</mo></mover><mi>k</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><msub><mover accent="true"><mi mathvariant="bold">x</mi><mo>^</mo></mover><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">Δ</mi><msup><mi>t</mi><mn>2</mn></msup></mrow><mn>2</mn></mfrac></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mi>a</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi mathvariant="bold">F</mi><mi>k</mi></msub><msub><mover accent="true"><mi mathvariant="bold">x</mi><mo>^</mo></mover><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi mathvariant="bold">B</mi><mi>k</mi></msub><msub><mi mathvariant="bold">u</mi><mi>k</mi></msub></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}\hat{\mathbf{x}}_{k} &amp; =\begin{bmatrix}  1 &amp; Δt\\  0 &amp; 1\end{bmatrix} \hat{\mathbf{x}}_{k-1}+\left[\begin{array}{c}\frac{\Delta t^{2}}{2} \\\Delta t\end{array}\right] a \\&amp; =\mathbf{F}_{k} \hat{\mathbf{x}}_{k-1}+\mathbf{B}_{k} \mathbf{u}_{k}\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.3779em;vertical-align:-1.939em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.439em;"><span style="top:-4.439em;"><span class="pstrut" style="height:3.539em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf">x</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.26em;"><span class="pstrut" style="height:3.539em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.939em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.439em;"><span style="top:-4.439em;"><span class="pstrut" style="height:3.539em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Δ</span><span class="mord mathnormal">t</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf">x</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.539em;"><span style="top:-3.539em;"><span class="pstrut" style="height:3.0179em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0179em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Δ</span><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.339em;"><span class="pstrut" style="height:3.0179em;"></span><span class="mord"><span class="mord">Δ</span><span class="mord mathnormal">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.039em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span></span></span><span style="top:-2.26em;"><span class="pstrut" style="height:3.539em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathbf">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf">x</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.939em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>​F<sub>k</sub> 称为状态转移矩阵，表明如何从当前状态推算到下一个状态</p><p>​B<sub>k</sub> 称为状态控制矩阵，表明加速减速如何改变小车的状态</p><p>​u<sub>k</sub> 称为状态控制向量，表明控制的力度大小和方向</p><ul><li><p><strong>考虑系统外部影响</strong></p><p>由于外界有很多因素（比如风速，障碍物等）会对小车的状态产生影响。假设外部的不确定性因素对小车造成的系统状态误差服从高斯分布 <strong>w<sub>k</sub> ~ N(0, Q<sub>k</sub>)</strong>，我们就可以得到卡尔曼滤波中完整的状态预测方程：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mover accent="true"><mi mathvariant="bold">x</mi><mo>^</mo></mover><mi>k</mi></msub><mo>=</mo><msub><mi mathvariant="bold">F</mi><mi>k</mi></msub><msub><mover accent="true"><mi mathvariant="bold">x</mi><mo>^</mo></mover><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi mathvariant="bold">B</mi><mi>k</mi></msub><msub><mi mathvariant="bold">u</mi><mi>k</mi></msub></mrow></mstyle></mtd></mtr></mtable><mo>+</mo><msub><mi>w</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\begin{aligned}\hat{\mathbf{x}}_{k}=\mathbf{F}_{k} \hat{\mathbf{x}}_{k-1}+\mathbf{B}_{k} \mathbf{u}_{k}\end{aligned} + w_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5em;vertical-align:-0.5em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf">x</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathbf">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf">x</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mover accent="true"><mi mathvariant="bold">P</mi><mo>^</mo></mover><mi>k</mi></msub><mo>=</mo><msub><mi mathvariant="bold">F</mi><mi>k</mi></msub><msub><mi mathvariant="bold">P</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><msubsup><mi mathvariant="bold">F</mi><mi>k</mi><mi>T</mi></msubsup><mo>+</mo><msub><mi mathvariant="bold">Q</mi><mi>k</mi></msub></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}\hat{\mathbf{P}}_{k}=\mathbf{F}_{k} {\mathbf{P}}_{k-1} {\mathbf{F}}^T_{k}+\mathbf{Q}_{k}\end{aligned} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6096em;vertical-align:-0.5548em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0548em;"><span style="top:-3.1052em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9495em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf">P</span></span><span style="top:-3.2551em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathbf">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">P</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">F</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.453em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5548em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>一般情况下，假设 w<sub>k</sub> 为 0。</p></li><li><p><strong>基于观测值进行最优估计</strong></p><p>在上述中，我们可以通过小车的上一个状态，对当前状态做出预测；但与此同时，我们也需要考虑小车的观测状态。</p><p>例如下图中，x<sub>k-1</sub>是小车前一个时刻的估计值，服从高斯分布，其中方差（variance）可以作为不确定性。</p><p><img src="/img/DeepLearning/kalman/image-20250109120834141.png" alt="图2"></p><p>x<sub>k</sub>是<strong>下一个时刻的估计</strong>，可以看到——分布变“胖”了。显然下一个时刻的估计相比于前一个时刻的估计会更加的不准确（因为上一时刻本身就是估计值，根据估计值估计下一时刻，相当于在递推的过程中又加了一层噪声，显然误差会越来越大）。</p><p>y<sub>k</sub>是一个<strong>观测值</strong>，是传感器定位的结果，但传感器对小车距离的测量也会受到种种因素的影响，所以这个结果同样不准确。</p><p>现在，我们知道了下一个时刻的估计结果，也知道了传感器返回的观测值结果。那么问题就来了，到底应该相信谁？</p><p>科学家们做出了一个解释，<strong>用x<sub>k</sub>分布乘上y<sub>k</sub>的分布，会得到一个更加精确的位置的分布</strong>（实际上这就是卡尔曼滤波器需要做的事情）</p></li></ul><p><img src="/img/DeepLearning/kalman/image-20250109122741224.png" alt="图3"></p><p>可以看到，新的分布不仅保证了在给定的蓝色和红色条件下，小车位于该点的概率最大。并且还是一个正态分布，这意味着可以把它当做初值继续往下算了！这就是Kalman滤波能够<strong>迭代</strong>的关键！</p><p>接下来，把灰色分布当做第一张图中的蓝色分布对k+1时刻进行预测，算法就可以开始循环往复了</p><ul><li><p><strong>实际中的计算方法</strong></p><p>在实际使用卡尔曼滤波的时候，计算的步骤一般为：</p><ol><li><p>预测阶段：使用模型来预测下一个时间点的状态和协方差</p><p><strong>a. 通过状态转移矩阵和控制输入预测下一个时间步的状态。</strong></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi mathvariant="bold">x</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi mathvariant="bold">F</mi><mo>⋅</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi mathvariant="bold">B</mi><mo>⋅</mo><mi mathvariant="bold">u</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}\mathbf{x} &amp;= (\mathbf{F} \cdot \mathbf{x}) + (\mathbf{B} \cdot \mathbf{u}) \\\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5em;vertical-align:-0.5em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord mathbf">F</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathbf">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">u</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><p><code>x</code> 是当前的状态向量（位置、速度等）。</p></li><li><p><code>F</code> 是状态转移矩阵，它描述了如何从当前状态推算到下一个状态。</p></li><li><p><code>Bu</code> 是控制输入项，其中 <code>B</code> 是控制输入矩阵，<code>u</code> 是控制输入向量。例如，在某些应用中，控制输入可能是加速度、外部力等。</p></li></ul><p><strong>b. 通过状态转移矩阵和过程噪声来预测下一个时间步的协方差。</strong></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi mathvariant="bold">P</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi mathvariant="bold">F</mi><mo>⋅</mo><mi mathvariant="bold">P</mi><mo>⋅</mo><msup><mi mathvariant="bold">F</mi><mi mathvariant="normal">⊤</mi></msup><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="bold">Q</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}\mathbf{P} &amp;= (\mathbf{F} \cdot \mathbf{P} \cdot \mathbf{F}^\top) + \mathbf{Q}\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5591em;vertical-align:-0.5296em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0296em;"><span style="top:-3.1304em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5296em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0296em;"><span style="top:-3.1304em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord mathbf">F</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">P</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">Q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5296em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><p><code>P</code> 是协方差矩阵，表示状态的不确定性。</p></li><li><p><code>F</code> 是状态转移矩阵，<code>P</code> 是当前的协方差矩阵。</p></li><li><p><code>Q</code> 是过程噪声协方差矩阵，表示系统本身的模型误差或噪声。</p></li></ul></li><li><p>更新阶段：通过新的测量值来调整预测的状态。</p><p><strong>a. 通过卡尔曼增益公式计算增益 <code>K</code>，它决定了如何将预测结果和测量值结合。</strong></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi mathvariant="bold">K</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi mathvariant="bold">P</mi><mo>⋅</mo><msup><mi mathvariant="bold">H</mi><mi mathvariant="normal">⊤</mi></msup><mo>⋅</mo><msup><mrow><mo fence="true">(</mo><mrow><mo fence="true">(</mo><mi mathvariant="bold">H</mi><mo>⋅</mo><mi mathvariant="bold">P</mi><mo>⋅</mo><msup><mi mathvariant="bold">H</mi><mi mathvariant="normal">⊤</mi></msup><mo fence="true">)</mo></mrow><mo>+</mo><mi mathvariant="bold">R</mi><mo fence="true">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}\mathbf{K} &amp;= \mathbf{P} \cdot \mathbf{H}^\top \cdot \left( \left( \mathbf{H} \cdot \mathbf{P} \cdot \mathbf{H}^\top \right) + \mathbf{R} \right)^{-1} \\\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.7631em;vertical-align:-0.6316em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1316em;"><span style="top:-3.1316em;"><span class="pstrut" style="height:3.1031em;"></span><span class="mord"><span class="mord mathbf">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6316em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1316em;"><span style="top:-3.1316em;"><span class="pstrut" style="height:3.1031em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathbf">P</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord mathbf">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">P</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">R</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1031em;"><span style="top:-3.352em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6316em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><p><code>K</code>是 <strong>卡尔曼增益</strong>，它表示我们对新测量值的信任程度。</p></li><li><p><code>P</code> 是预测的协方差矩阵。</p></li><li><p><code>H</code> 是观测矩阵，它将状态空间映射到测量空间。</p></li><li><p><code>R</code> 是测量噪声协方差矩阵，表示测量值的不确定性。</p></li></ul><p><strong>b. 计算当前测量值和预测测量值之间的差异</strong></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi mathvariant="bold">y</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi mathvariant="bold">z</mi><mo>−</mo><mi mathvariant="bold">H</mi><mo>⋅</mo><mi mathvariant="bold">x</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}\mathbf{y} &amp;= \mathbf{z} -  \mathbf{H} \cdot \mathbf{x} \\\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5em;vertical-align:-0.5em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathbf">z</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><code>y</code> 是 <strong>创新</strong>（或者称为测量残差），表示测量值 <code>z</code> 与预测值 <code>Hx</code> 之间的差异。</li><li><code>z</code> 是实际的测量值。</li><li><code>Hx</code> 是根据当前预测状态 <code>x</code> 计算的测量值。</li></ul><p><strong>c. 通过将创新值 <code>y</code> 和卡尔曼增益 <code>K</code> 结合来更新预测的状态，目的是修正状态估计，使其更加接近实际的测量值。</strong></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi mathvariant="bold">x</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi mathvariant="bold">x</mi><mo>+</mo><mi mathvariant="bold">K</mi><mo>⋅</mo><mi mathvariant="bold">y</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}\mathbf{x} &amp;= \mathbf{x} + \mathbf{K} \cdot \mathbf{y} \\\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5em;vertical-align:-0.5em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">K</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><code>x</code> 是更新后的状态向量。</li><li><code>K</code> 是卡尔曼增益，<code>y</code> 是创新。</li></ul><p><strong>d. 更新协方差矩阵</strong></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi mathvariant="bold">P</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mi mathvariant="bold">I</mi><mo>−</mo><mrow><mo fence="true">(</mo><mi mathvariant="bold">K</mi><mo>⋅</mo><mi mathvariant="bold">H</mi><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow><mo>⋅</mo><mi mathvariant="bold">P</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}\mathbf{P} &amp;= \left( \mathbf{I} - \left( \mathbf{K} \cdot \mathbf{H} \right) \right) \cdot \mathbf{P}\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5em;vertical-align:-0.5em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathbf">I</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathbf">K</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">H</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><p><code>P</code> 是更新后的协方差矩阵。</p></li><li><p><code>I</code> 是单位矩阵。</p></li><li><p><code>(I - KH)</code> 是卡尔曼增益对协方差的修正因子。这个操作是用来减小更新后的协方差，表示我们对更新后的状态估计更有信心。</p></li></ul><p><strong>e. 计算创新协方差，用于后续的卡尔曼增益计算</strong></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo>=</mo><mi>H</mi><mi>P</mi><msup><mi>H</mi><mi>T</mi></msup><mo>+</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">S = H P H^T + R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9747em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></span></p><ul><li><p><code>S</code> 是创新协方差，</p></li><li><p><code>H</code> 是观测矩阵，</p></li><li><p><code>P</code> 是预测的协方差矩阵，</p></li><li><p><code>R</code> 是测量噪声协方差矩阵。</p></li></ul></li></ol><p>简单来说就是通过不断的预测和更新，使得卡尔曼滤波器能够精确地估计目标的状态，并且在实际应用中适应测量噪声和系统噪声的变化。</p><p><strong>注意：</strong></p><ol><li>时刻关注不断迭代的系统变量，分别是<strong>系统的状态x，误差协方差矩阵P，卡尔曼增益K</strong></li><li>在实际使用时，对Q和R的选择要依据实际情况，可以不断调试来试图寻找一个最优解。</li></ol></li></ul><h2 id="三、代码实践">三、代码实践</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> filterpy.kalman <span class="hljs-keyword">import</span> KalmanFilter<br><br><span class="hljs-comment"># 生成1000个位置，从1到1000，是小车的实际位置</span><br>z = np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">1000</span>)<br><span class="hljs-comment"># 添加噪声</span><br>mu,sigma = <span class="hljs-number">0</span>,<span class="hljs-number">1</span><br>noise = np.random.normal(mu,sigma,<span class="hljs-number">1000</span>)<br><span class="hljs-comment"># 小车位置的观测值</span><br>z_nosie = z+noise<br><br><span class="hljs-comment"># dim_x 状态向量size,在该例中为[p,v]，即位置和速度,size=2</span><br><span class="hljs-comment"># dim_z 测量向量size，假设小车为匀速，速度为1，测量向量只观测位置，size=1</span><br>my_filter = KalmanFilter(dim_x=<span class="hljs-number">2</span>, dim_z=<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 定义卡尔曼滤波中所需的参数</span><br><span class="hljs-comment"># x 初始状态为[0,0],即初始位置为0，速度为0.</span><br><span class="hljs-comment"># 这个初始值不是非常重要，在利用观测值进行更新迭代后会接近于真实值</span><br>my_filter.x = np.array([[<span class="hljs-number">0.</span>], [<span class="hljs-number">0.</span>]])<br><br><span class="hljs-comment"># p 协方差矩阵，表示状态向量内位置与速度的相关性</span><br><span class="hljs-comment"># 假设速度与位置没关系，协方差矩阵为[[1,0],[0,1]]</span><br>my_filter.P = np.array([[<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>], [<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>]])<br><br><span class="hljs-comment"># F 初始的状态转移矩阵，假设为匀速运动模型，可将其设为如下所示</span><br>my_filter.F = np.array([[<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>], [<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>]])<br><br><span class="hljs-comment"># Q 状态转移协方差矩阵，也就是外界噪声，</span><br><span class="hljs-comment"># 在该例中假设小车匀速，外界干扰小，所以我们对F非常确定，觉得F一定不会出错，所以Q设的很小</span><br>my_filter.Q = np.array([[<span class="hljs-number">0.0001</span>, <span class="hljs-number">0.</span>], [<span class="hljs-number">0.</span>, <span class="hljs-number">0.0001</span>]])<br><br><span class="hljs-comment"># 观测矩阵 Hx = p</span><br><span class="hljs-comment"># 利用观测数据对预测进行更新，观测矩阵的左边一项不能设置成0</span><br>my_filter.H = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]])<br><span class="hljs-comment"># R 测量噪声，方差为1</span><br>my_filter.R = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 保存卡尔曼滤波过程中的位置和速度</span><br>z_new_list = []<br>v_new_list = []<br><span class="hljs-comment"># 对于每一个观测值，进行一次卡尔曼滤波</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(z_nosie)):<br>    <span class="hljs-comment"># 预测过程</span><br>    my_filter.predict()<br>    <span class="hljs-comment"># 利用观测值进行更新</span><br>    my_filter.update(z_nosie[k])<br>    <span class="hljs-comment"># do something with the output</span><br>    x = my_filter.x<br>    <span class="hljs-comment"># 收集卡尔曼滤波后的速度和位置信息</span><br>    z_new_list.append(x[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])<br>    v_new_list.append(x[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br><br><span class="hljs-comment"># 位移的偏差</span><br>dif_list = []<br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(z)):<br>    dif_list.append(z_new_list[k]-z[k])<br><span class="hljs-comment"># 速度的偏差</span><br>v_dif_list = []<br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(z)):<br>    v_dif_list.append(v_new_list[k]-<span class="hljs-number">1</span>)<br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">9</span>))<br>plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>plt.xlim(-<span class="hljs-number">50</span>,<span class="hljs-number">1050</span>)<br>plt.ylim(-<span class="hljs-number">3.0</span>,<span class="hljs-number">3.0</span>)<br>plt.scatter(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(z)),dif_list,color =<span class="hljs-string">&#x27;b&#x27;</span>,label = <span class="hljs-string">&quot;位置偏差&quot;</span>)<br>plt.scatter(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(z)),v_dif_list,color =<span class="hljs-string">&#x27;y&#x27;</span>,label = <span class="hljs-string">&quot;速度偏差&quot;</span>)<br>plt.legend(loc = <span class="hljs-string">&#x27;upper right&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><strong>结果演示：</strong></p><p><img src="/img/DeepLearning/kalman/image-20250109140421419.png" alt="图4"></p><h2 id="参考文献">参考文献</h2><p><a href="http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/">http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/</a></p><p><a href="https://blog.csdn.net/m0_46339652/article/details/119221972">https://blog.csdn.net/m0_46339652/article/details/119221972</a></p>]]></content>
    
    
    <categories>
      
      <category>DeepLearning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepLearning</tag>
      
      <tag>OpenCV</tag>
      
      <tag>目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

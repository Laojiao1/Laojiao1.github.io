<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【计算机视觉】YOLO 算法简述</title>
    <link href="/2025/01/13/DeepLearning/YOLO/"/>
    <url>/2025/01/13/DeepLearning/YOLO/</url>
    
    <content type="html"><![CDATA[<h1>YOLO 算法</h1><p>在正式介绍YOLO之前，先看一张图：</p><p><img src="/img/DeepLearning/YOLO/image-20250113153024148.png" alt="各类目标检测算法对比图"></p><p>可以看出YOLO的最大特点是速度快。<strong>YOLO在精度上仍然落后于目前最先进的检测系统。虽然它可以快速识别图像中的目标，但它在定位某些物体尤其是小的物体上精度不高。论文中做了精度／时间的权衡。</strong></p><p><img src="/img/DeepLearning/YOLO/image-20250113153042383.png" alt="算法发展过程"></p><p>YOLO算法系列的演变过程：<code>YOLO -&gt; YOLO9000 -&gt; YOLOv2 -&gt; YOLOv3</code></p><h2 id="YOLO介绍">YOLO介绍</h2><p>YOLO（You Only Look Once）是一种端到端的目标检测方法。以前的目标检测方法利用分类器来执行检测。与先前的方案不同，yolo网络<strong>使用单个神经网络，在一次评估中直接从完整图像上预测边界框和类别概率。由于整个检测流程仅用一个网络，所以可以直接对检测性能进行端到端的优化。</strong></p><p><img src="/img/DeepLearning/YOLO/image-20250113153127742.png" alt=""></p><h3 id="1-YOLO模型结构">1. YOLO模型结构</h3><p>YOLO 是一个简单直观的目标检测系统，其检测过程可以概括为以下三步：</p><ol><li><strong>图像预处理</strong><br>将输入图像缩放至固定大小 448×448，方便模型处理，同时确保输入维度一致。</li><li><strong>特征提取与预测</strong><br>利用卷积神经网络（CNN）对缩放后的图像进行处理，生成预测结果，包括目标的类别、置信度以及边界框位置。</li><li><strong>结果后处理</strong><br>根据模型输出的置信度对检测结果进行筛选，过滤掉低置信度的框，并通过非极大值抑制（NMS）去除重复框，最终得到精确的检测结果。</li></ol><p>网络结构如下：</p><p><img src="/img/DeepLearning/YOLO/image-20250113153355885.png" alt="YOLO网络结构图"></p><p>Yolo的网络架构受GoogleNet的启发，使用网络有24个卷积层，后面是2个全连接层。</p><h3 id="2-统一检测过程">2. 统一检测过程</h3><p>（1）原始图片resize到448x448，经过网络的处理之后，将图片输出成了一个7 x 7 x 30的结构</p><ul><li><strong>下面进行一个简单的过程解释：</strong></li></ul><p>系统将输入图像分成 n×n 的网格。如果目标的中心落入某个网格单元中，那么该网格单元就负责检测该目标。</p><p><img src="/img/DeepLearning/YOLO/image-20250113153911265.png" alt="yolo检测小狗"></p><p>接下来以下图为例，默认7 x 7个单元格，这里用3 x 3的单元格图演示</p><p><img src="/img/DeepLearning/YOLO/image-20250113153957203.png" alt=""></p><p>（2）在每个网格单元格中都会预测B个边界框，一般是两个，每一个边界框会预测一个置信度表示该边界框中是否包含目标。</p><p><img src="/img/DeepLearning/YOLO/image-20250113154031523.png" alt=""></p><p>（3）接下来对这些边界框进行NMS筛选（置信度以及IoU），删去重叠度较高的预测框，获取最优的检测结果。</p><p><img src="/img/DeepLearning/YOLO/image-20250113154049190.png" alt=""><img src="/img/DeepLearning/YOLO/image-20250113154201321.png" alt="image-20250113154201321"></p><h3 id="3-单元格（grid-cell）">3. 单元格（grid cell）</h3><p>上面第二步是理解YOLO网络的关键。YOLO 的输出是一个大小为 <strong>7 × 7 × 30</strong> 的特征图。这意味着输入图像被分成了 <strong>7 × 7 = 49 个网格单元格</strong>，每个单元格会预测若干个边界框以及相关的置信度分数和类别概率。</p><h4 id="置信度与边界框">置信度与边界框</h4><p>7 x 7 = 49 个像素值，可以理解成49个单元格，每个单元格可以代表原图的一个方块。单元格需要做的两件事：</p><ol><li><strong>预测边界框（bbox）</strong><ul><li>每个单元格预测 2 个边界框，每个边界框包含 5 个预测值：<ul><li>(𝑥, 𝑦)：边界框中心点的相对坐标（相对于当前单元格）。</li><li>(𝑤, ℎ)：边界框的宽度和高度（相对于整张图像）。</li><li>置信度 c：预测框是否包含目标的概率，并结合 IOU 表示框的准确性。</li></ul></li></ul></li><li><strong>预测类别概率</strong><ul><li>每个单元格会预测 <strong>20 个类别的概率</strong>，即目标属于某一类别的可能性（假设数据集中有 20 个类别）。</li></ul></li></ol><h4 id="输出特征图结构">输出特征图结构</h4><p>特征图的最后一维（30）可以拆解为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>30</mn><mo>=</mo><mn>2</mn><mo>×</mo><mo stretchy="false">(</mo><mn>4</mn><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>20</mn></mrow><annotation encoding="application/x-tex">30 = 2 ×(4+1)+20</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">30</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">20</span></span></span></span></span></p><ul><li><strong>4 + 1</strong>：每个边界框的 4 个位置坐标(𝑥, 𝑦, 𝑤, ℎ) 和 1 个置信度。</li><li><strong>2</strong>：每个单元格预测 2 个边界框。</li><li><strong>20</strong>：每个单元格对应的类别概率分布。</li></ul><h4 id="总预测量">总预测量</h4><ul><li><strong>7 x 7(49 个单元格)</strong> × <strong>2 个边界框</strong> = <strong>98 个预测框</strong>。</li><li>每个框结合类别概率，可以进一步计算类别特定的置信度，用于后续的目标检测结果筛选。</li></ul><h3 id="4-网络输出筛选（置信度比较）">4. 网络输出筛选（置信度比较）</h3><p><strong>一个网格单元预测两个边界框（Bbox），但在训练时，每个目标只分配一个 Bbox 专门负责（即一个目标对应一个 Bbox）</strong>。为了确定每个位置预测的两个 Bbox 中哪个更适合作为目标框，采用以下筛选策略：</p><ul><li><strong>通过置信度大小比较</strong></li></ul><p><img src="/img/DeepLearning/YOLO/image-20250113154929770.png" alt=""></p><ul><li><p><strong>评估标准</strong></p><ul><li><p>每个边界框都对应一个置信度</p></li><li><p>这些置信度分数反映了该模型对那个框内是否包含目标的信心程度，以及它对自己的预测的准确度的估量。</p></li><li><p>公式定义：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>P</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mtext>Object</mtext><mo stretchy="false">)</mo><mo>⋅</mo><msubsup><mtext>IOU</mtext><mtext>truth</mtext><mtext>pred</mtext></msubsup></mrow><annotation encoding="application/x-tex">P_r(\text{Object}) \cdot \text{IOU}_{\text{truth}}^{\text{pred}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord">Object</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2683em;vertical-align:-0.3013em;"></span><span class="mord"><span class="mord text"><span class="mord">IOU</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.967em;"><span style="top:-2.3987em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">truth</span></span></span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">pred</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3013em;"><span></span></span></span></span></span></span></span></span></span></span></p><ul><li>如果单元格里面没有Object，则置信度（confidence）为 <strong>0</strong>。</li><li>如果单元格中有目标，则置信度（confidence score）等于上述公式的值</li></ul></li></ul></li></ul><p>注：<strong>如何判断一个单元格（grid cell）中是否包含object？</strong></p><p>当图像中某个目标（Object）的真实框（Ground Truth）中心点落在某个单元格的范围内时，就判定该单元格包含该目标。</p><h4 id="预测位置">预测位置</h4><p>每个边界框（Bbox）包含 5 个预测值：(𝑥, 𝑦, 𝑤, ℎ, 𝑐𝑜𝑛𝑓𝑖𝑑𝑒𝑛𝑐𝑒)</p><ol><li><strong>中心点坐标 (𝑥, 𝑦)</strong><ul><li>表示边界框中心点相对于所属网格单元（Grid Cell）左上角的偏移值。</li><li>注：每个网格单元的左上角被设为原点 (0,0)，右下角设为 (1,1)，因此 (x,y) 的取值范围一定在 <strong>(0, 1)</strong> 之间。</li></ul></li><li><strong>宽度和高度 (𝑤, ℎ)</strong><ul><li>表示边界框的宽度和高度相对于整张图片的比例：<ul><li>𝑤 = 预测框宽度图片宽度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><mfrac><mtext>预测框宽度</mtext><mtext>图片宽度</mtext></mfrac></mrow><annotation encoding="application/x-tex">w = \frac{\text{预测框宽度}}{\text{图片宽度}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">图片宽度</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">预测框宽度</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li><li>ℎ = 预测框高度图片高度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mfrac><mtext>预测框高度</mtext><mtext>图片高度</mtext></mfrac></mrow><annotation encoding="application/x-tex">h = \frac{\text{预测框高度}}{\text{图片高度}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">图片高度</span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord cjk_fallback mtight">预测框高度</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></li></ul></li><li>通过标准化处理，(𝑤, ℎ) 的取值范围也在 <strong>(0, 1)</strong> 之间。</li></ul></li><li><strong>置信度（confidence）</strong><ul><li>置信度表示预测框中是否存在目标以及边界框与目标匹配的程度（IOU）。</li><li>它综合了两部分信息（即在上文中提到的<strong>评估标准</strong>）：<ul><li>当前网格单元中是否存在目标的概率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><mtext>Object</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(\text{Object})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord text"><span class="mord">Object</span></span><span class="mclose">)</span></span></span></span> 。</li><li>边界框的准确性，即预测框与真实框的重叠程度（IOU）。</li></ul></li></ul></li></ol><p><strong>为什么这样去做？</strong></p><p>预测中采用相对于网格单元位置的位置坐标，这使得真实值的界限在0到1之间，参数化更容易学习，从而使网络更加稳定。</p><hr><p><em>需要注意的一个问题：关于 yolo 的预测的 bbox 中心坐标是相对于 grid cell 左上角的偏移值, 不是直接预测而是预测偏移值。</em></p><p><em>但预测的 (x, y)可能为负数, 这样 (x, y) 就不在该 cell 中了——yolo v2 通过 (sigmoid(x), sigmoid(y)) 来解决这个问题.</em></p><h3 id="5-测试">5. 测试</h3><p>YOLO 的设计理念是让网络从全局视角预测目标，因此yolo 预测的是单元格的类别条件概率，而不是单独优化每个框的类别概率。单元格的类别条件概率可以理解为：</p><ul><li><strong>条件</strong>：在当前单元格中检测到物体。</li><li><strong>结果</strong>：该物体属于某个类别。</li></ul><p>因此，条件概率与预测框无直接关联，而是作为单元格整体预测的结果。这种设计减少了复杂性，并通过网络学习到更高效的特征分布。</p><p>最终测试的时候，条件类概率和<strong>每个框的预测的置信度值相乘得到每个框特定类别的置信度分数</strong>。这些分数体现了该类出现在框中的概率以及预测框拟合目标的程度。</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>P</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mtext>Class</mtext><mi mathvariant="normal">∣</mi><mtext>Object</mtext><mo stretchy="false">)</mo><mo>⋅</mo><msub><mi>P</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mtext>Object</mtext><mo stretchy="false">)</mo><mo>⋅</mo><msubsup><mtext>IOU</mtext><mtext>truth</mtext><mtext>pred</mtext></msubsup><mo>=</mo><msub><mi>P</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mtext>Class</mtext><mo stretchy="false">)</mo><mo>⋅</mo><msubsup><mtext>IOU</mtext><mtext>truth</mtext><mtext>pred</mtext></msubsup></mrow><annotation encoding="application/x-tex">P_r(\text{Class} | \text{Object}) \cdot P_r(\text{Object}) \cdot \text{IOU}_{\text{truth}}^{\text{pred}} = P_r(\text{Class}) \cdot \text{IOU}_{\text{truth}}^{\text{pred}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord">Class</span></span><span class="mord">∣</span><span class="mord text"><span class="mord">Object</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord">Object</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2683em;vertical-align:-0.3013em;"></span><span class="mord"><span class="mord text"><span class="mord">IOU</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.967em;"><span style="top:-2.3987em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">truth</span></span></span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">pred</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3013em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord">Class</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2683em;vertical-align:-0.3013em;"></span><span class="mord"><span class="mord text"><span class="mord">IOU</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.967em;"><span style="top:-2.3987em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">truth</span></span></span></span></span><span style="top:-3.1809em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">pred</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3013em;"><span></span></span></span></span></span></span></span></span></span></span></p><ul><li><strong>左侧</strong>表示：类别的条件概率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mtext>Class</mtext><mi mathvariant="normal">∣</mi><mtext>Object</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_r(\text{Class} | \text{Object})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord">Class</span></span><span class="mord">∣</span><span class="mord text"><span class="mord">Object</span></span><span class="mclose">)</span></span></span></span> 乘以单元格中存在物体的概率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mtext>Object</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_r(\text{Object})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord">Object</span></span><span class="mclose">)</span></span></span></span>，再结合边界框的准确性（IOU）。</li><li><strong>右侧</strong>是对左侧的简化结果：直接表示为类别概率 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mtext>Class</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P_r(\text{Class})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord text"><span class="mord">Class</span></span><span class="mclose">)</span></span></span></span> 和 IOU 的乘积。</li></ul><p><strong>个人理解：<strong>这个公式的乘积同时编码了</strong>预测框属于某类别的概率</strong>和<strong>预测框定位的准确性（IOU）</strong>。在后续处理中，可以根据计算得到的这些分数设置阈值，滤除低得分的预测框，然后对剩余的预测框应用 <strong>NMS（非极大值抑制）</strong>，去除重复框，最终保留下置信度高且定位准确的预测框，作为检测结果。</p><p><img src="/img/DeepLearning/YOLO/image-20250113161306397.png" alt="image-20250113161306397"></p><h2 id="总结">总结</h2><h3 id="优点">优点</h3><ol><li><strong>速度极快</strong><br>YOLO 将目标检测视为一个回归问题，大大简化了流程，避免了复杂的多阶段处理。在测试时，YOLO 只需对输入图像运行一次神经网络即可生成预测结果。在 Titan X GPU 上，基础版本的 YOLO 在不进行批处理的情况下，能够以 <strong>每秒 45 帧</strong> 的速度运行，具备实时处理能力。</li><li><strong>全局推断</strong><br>与基于滑动窗口或候选框的技术不同，YOLO 在训练和推断时都会考虑整个图像的上下文信息。这种全局视角使 YOLO 隐式学习到了类别之间的上下文关系和外观特征。因此，与 Fast R-CNN 相比，YOLO 在背景误检目标的情况下减少了一半的错误。</li><li><strong>泛化能力强</strong><br>YOLO 能够学习到目标的通用特征表征。例如，将在自然图像上训练的模型迁移到艺术图像上进行测试时，YOLO 的性能显著优于 DPM 和 R-CNN 等顶级检测方法。得益于其良好的泛化能力，YOLO 在面对新领域或意外输入时更稳定，发生故障的可能性更低。</li></ol><hr><h3 id="缺点">缺点</h3><ol><li><strong>准确率有所折扣</strong><br>虽然 YOLO 的速度快，但相比某些两阶段检测器（如 Faster R-CNN），其检测精度可能稍低，特别是在需要高精度检测的场景中。</li><li><strong>密集目标检测能力不足</strong><br>对于相互靠得很近的目标（如目标的中心点落在同一个网格单元内），YOLO 的检测效果较差，因为每个网格单元只能预测一个目标。这在处理包含大量目标的场景（如鸟群或畜群）时尤为明显——一个网格中可能包含多个目标，但 YOLO 只能检测出其中一个。</li></ol><h2 id="参考文献">参考文献</h2><ul><li><a href="https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Redmon_You_Only_Look_CVPR_2016_paper.pdf">https://www.cv-foundation.org/openaccess/content_cvpr_2016/papers/Redmon_You_Only_Look_CVPR_2016_paper.pdf</a></li><li><a href="https://openaccess.thecvf.com/content_cvpr_2017/papers/Redmon_YOLO9000_Better_Faster_CVPR_2017_paper.pdf">https://openaccess.thecvf.com/content_cvpr_2017/papers/Redmon_YOLO9000_Better_Faster_CVPR_2017_paper.pdf</a></li><li><a href="https://zhuanlan.zhihu.com/p/564708049">https://zhuanlan.zhihu.com/p/564708049</a></li><li><a href="https://blog.csdn.net/DFCED/article/details/105157452">https://blog.csdn.net/DFCED/article/details/105157452</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>DeepLearning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepLearning</tag>
      
      <tag>OpenCV</tag>
      
      <tag>目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷】采药——背包dp</title>
    <link href="/2025/01/12/OJ/BagDP/P1048/"/>
    <url>/2025/01/12/OJ/BagDP/P1048/</url>
    
    <content type="html"><![CDATA[<h1>采药（背包dp）</h1><p><a href="https://www.luogu.com.cn/problem/P1048">题目链接</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> T, M;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1001</span>;<br><span class="hljs-type">int</span> t[maxn], m[maxn];<br><span class="hljs-type">int</span> f[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; T &gt;&gt; M;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= M; i++) &#123;<br>        cin &gt;&gt; t[i] &gt;&gt; m[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= M; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = T; l &gt;= t[i]; l--) &#123;<br>        <span class="hljs-keyword">if</span>(f[l-t[i]] + m[i] &gt; f[l])<br>        f[l] = f[l-t[i]] + m[i]; <span class="hljs-comment">//状态方程</span><br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[T];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
      <category>BagDP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷】滑雪——记忆化搜索</title>
    <link href="/2025/01/12/OJ/BagDP/P1434/"/>
    <url>/2025/01/12/OJ/BagDP/P1434/</url>
    
    <content type="html"><![CDATA[<h1>滑雪（记忆化搜索）</h1><p><a href="https://www.luogu.com.cn/problem/P1434">题目链接</a></p><h3 id="本题关键字：记忆化搜索。">本题关键字：记忆化搜索。</h3><p><strong>首先，这题为什么会想到记忆化？(知道的人直接跳过)</strong></p><p>在dfs每种情况是，可能这个点之前已经搜过了，没必要再去搜索了，因此不如存储记住，就没必要再去dfs了。</p><hr><p>本题的主要思路：</p><p><strong>1.先去想dfs怎么做：</strong></p><p>这题每个点出发有可能，所以我们每个点都要开始dfs，最后取他们的最大值。</p><p>dfs部分和类似的迷宫差不多,用两个数组表示4个方向：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dx</span>[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br><span class="hljs-attribute">dy</span>[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;;<br></code></pre></td></tr></table></figure><p>改变方向直接xx=x+dx[i] , yy=y+dy[i]</p><p>接下来判断这个方向是否在地图范围内，即</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts">if(xx&gt;<span class="hljs-number">0</span>&amp;<span class="hljs-variable">&amp;xx</span><span class="hljs-params">&lt;=R&amp;<span class="hljs-variable">&amp;yy</span>&gt;</span><span class="hljs-number">0</span>&amp;<span class="hljs-variable">&amp;yy</span><span class="hljs-params">&lt;=C)</span><br></code></pre></td></tr></table></figure><p>当然还要判断这个点是否能滑到，也就是高度要前一个低：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">if(<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[xx]</span><span class="hljs-selector-attr">[yy]</span>&lt;<span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[x]</span><span class="hljs-selector-attr">[y]</span>)//<span class="hljs-selector-tag">a</span>为高度<br></code></pre></td></tr></table></figure><p>很明显，因为低的不可能滑向高的，所以我们不需要再开一个数组去记录这个点是否走过。</p><p>接下来，就要往四个方向搜索，取四个方向中距离最长的，然后+1，这就是这个点的结果了。</p><p><strong>2.记忆化搜索怎么写</strong></p><p>很显然，直接dfs会TLE。那么就需要记忆化来优化。</p><p>用s[i][j]表示从(i,j)点出发能走的最长距离。</p><p>每次搜索一次记忆一次即可。</p><p>下面给刚接触不怎么明白的人举例：(已经理解的人跳过)</p><p>由于样例不好讲我自己举例子：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span> <br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>先去找(1,1)的最长距离，很明显为1</p><p>接着找(1,2)的最长距离，很明显为1</p><p>接着找(1,3)的最长距离，为2((1,3)-&gt;(1,2))</p><p>然后找(2,1)的最长距离，为2((2,1)-&gt;(1,1))</p><p>然后是(2,2)的最长距离，如果没有记忆化，那么搜索过程为：(2,2)-&gt;(2,1)-&gt;(1,1)</p><p>但是（2,1）之前已经搜过了，再去搜就是浪费时间，之前搜索已经知道(2,1)的值为2，那么搜索过程就是缩短为：(2,2)-&gt;(2,1),即为3</p><p><strong>附上代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">101</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> a[maxn][maxn], s[maxn][maxn];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(s[x][y]) <span class="hljs-keyword">return</span> s[x][y];  <span class="hljs-comment">//记忆化搜索</span><br>    s[x][y] = <span class="hljs-number">1</span>; <span class="hljs-comment">//题目答案是有包含这个点的</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        <span class="hljs-type">int</span> xx = dx[i] + x;<br>        <span class="hljs-type">int</span> yy = dy[i] + y; <span class="hljs-comment">//四个方向</span><br>        <span class="hljs-keyword">if</span>(xx &gt; <span class="hljs-number">0</span> &amp;&amp; yy &gt; <span class="hljs-number">0</span> &amp;&amp; xx &lt;= n &amp;&amp; yy &lt;= m &amp;&amp; a[x][y] &gt; a[xx][yy]) &#123;<br>            <span class="hljs-built_in">dfs</span>(xx, yy);<br>            s[x][y] = <span class="hljs-built_in">max</span>(s[x][y], s[xx][yy]<span class="hljs-number">+1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s[x][y];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            cin &gt;&gt; a[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">//找从每个出发的最长距离</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">dfs</span>(i, j)); <span class="hljs-comment">//取最大值</span><br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
      <category>BagDP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷】樱花——混合背包</title>
    <link href="/2025/01/12/OJ/BagDP/P1833/"/>
    <url>/2025/01/12/OJ/BagDP/P1833/</url>
    
    <content type="html"><![CDATA[<h1>樱花（混合背包）</h1><p><a href="https://www.luogu.com.cn/problem/P1833">题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">200</span>;<br><span class="hljs-type">int</span> t[maxn], c[maxn], p[maxn], f[maxn];<br><span class="hljs-type">int</span> a, b;<br><span class="hljs-type">char</span> ch;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> pre[<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span>; i++) &#123;<br>        cin &gt;&gt; a &gt;&gt; ch &gt;&gt; b;<br>        pre[cnt] = a*<span class="hljs-number">60</span>+b;<br>        cnt++;<br>    &#125;<br>    <span class="hljs-type">int</span> time = pre[<span class="hljs-number">2</span>] - pre[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// cout &lt;&lt; time &lt;&lt; endl;</span><br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; t[i] &gt;&gt; c[i] &gt;&gt; p[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123; <span class="hljs-comment">//混合背包</span><br>        <span class="hljs-keyword">if</span>(p[i] == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//完全背包</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = t[i] ; j &lt;= time ; j ++)<br>            f[j] = <span class="hljs-built_in">max</span>(f[j] , f[j-t[i]] + c[i]) ;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//01背包和多重背包</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span> ; j &lt;= p[i] ; j ++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = time; l &gt;= t[i] ; l--) &#123;<br>        f[l] = <span class="hljs-built_in">max</span>(f[l], f[l-t[i]]+c[i]);<br>        &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; f[time];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
      <category>BagDP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷】5倍经验日——01背包变形</title>
    <link href="/2025/01/12/OJ/BagDP/P1082/"/>
    <url>/2025/01/12/OJ/BagDP/P1082/</url>
    
    <content type="html"><![CDATA[<h1>5倍经验日（01背包变形）</h1><p><a href="https://www.luogu.com.cn/problem/P1802">题目链接</a></p><p><strong>思路：</strong></p><p>​当i &gt;= use时，可以选择打败或者不打败</p><p>​f [i] = max( f [i] + lose, f [i-use] + win )。</p><p>​当i &lt; use时，无法战胜对方。</p><p>​f [i] += lose</p><p>​至于数据范围，最后输出时强制转换一下就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1100</span>;<br><span class="hljs-type">int</span> win[maxn], lose[maxn], use[maxn], f[maxn];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, x;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;x);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, lose+i, win+i, use+i);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = x; l &gt;= use[i]; l--)<br>            f[l] = <span class="hljs-built_in">max</span>(f[l]+lose[i], f[l-use[i]]+win[i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = use[i]<span class="hljs-number">-1</span>; l &gt;= <span class="hljs-number">0</span>; l--) &#123;<br>            f[l] += lose[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, <span class="hljs-number">5</span>*f[x]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
      <category>BagDP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷】挖地雷——DP顺推</title>
    <link href="/2025/01/12/OJ/BagDP/P2196/"/>
    <url>/2025/01/12/OJ/BagDP/P2196/</url>
    
    <content type="html"><![CDATA[<h1>挖地雷</h1><p><a href="https://www.luogu.com.cn/problem/P2196">题目链接</a></p><p>定义状态 <code>f[i]</code> 为以第 <code>i</code> 个节点结束的最大值，则：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><mo>+</mo><mi>a</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f[i] = max{f[j]} + a[i] (g[j][i] = 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span></p><p>最后用一个 <code>pre[i]</code> 数组存储前驱节点，递归输出即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, t, ans;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">201</span>;<br><span class="hljs-type">int</span> a[maxn];<br><span class="hljs-type">int</span> mp[maxn][maxn];<br><span class="hljs-type">int</span> f[maxn], pre[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(pre[x] == <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; x;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">print</span>(pre[x]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin &gt;&gt; x;<br>            <span class="hljs-keyword">if</span>(x == <span class="hljs-number">1</span>) <br>                mp[i][j] = x;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span>(mp[j][i] &amp;&amp; f[j] &gt; f[i]) &#123;<br>                f[i] = f[j];<br>                pre[i] = j;<br>            &#125;<br>        &#125;<br>        f[i] += a[i];<br>        <span class="hljs-keyword">if</span>(f[i] &gt; ans) &#123;<br>            ans = f[i];<br>            t = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">print</span>(t);<br>    cout &lt;&lt; endl;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
      <category>BagDP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
      <tag>洛谷</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机视觉】多目标追踪——SORT &amp; DeepSORT</title>
    <link href="/2025/01/12/DeepLearning/Sort_DeepSort/"/>
    <url>/2025/01/12/DeepLearning/Sort_DeepSort/</url>
    
    <content type="html"><![CDATA[<h1>SORT &amp; DeepSORT</h1><h2 id="一、SORT-介绍">一、SORT 介绍</h2><p>SORT（Simple Online and Realtime Tracking）是一种轻量级的多目标追踪算法，旨在在实时视频流中高效追踪多个目标。它基于两大核心技术：</p><ol><li><a href="https://laojiao1.github.io/2025/01/09/DeepLearning/kalman/">卡尔曼滤波器</a>：用于对每个目标的状态（位置和速度）进行估计和预测，以应对目标的移动。</li><li><a href="https://laojiao1.github.io/2025/01/10/DeepLearning/Hungarian/">匈牙利算法</a>：用于解决目标匹配问题，即在每一帧图像中，确定哪些检测框与上一帧的目标进行匹配。</li></ol><p>SORT 算法的核心思想是通过结合<strong>目标检测</strong>和<strong>运动预测</strong>来实现<strong>多目标追踪</strong>。首先，利用目标检测器（如Faster R-CNN）在每一帧图像中检测目标的边界框。接下来，通过卡尔曼滤波器对目标的运动进行建模和预测。卡尔曼滤波器结合当前目标状态和运动模型，预测目标在下一帧中的位置和速度。为了在不同帧之间建立目标的关联，SORT引入了基于<strong>匈牙利算法</strong>的数据关联方法。该方法通过最小化代价（如IOU距离）来匹配当前帧中的目标与先前帧中的已跟踪目标，从而确保每个目标的身份和轨迹得到正确追踪。</p><h2 id="二、SORT-目标追踪算法">二、SORT 目标追踪算法</h2><h3 id="1-SORT-初始框">1. SORT 初始框</h3><p>在单目标跟踪中，初始框通常是由人工手动框定的。而在多目标跟踪中，初始框是通过目标检测器自动生成的，避免了人工初始化的过程。SORT算法基于这种目标检测机制，利用<strong>Faster R-CNN</strong>作为检测器。Faster R-CNN是一个端到端的两阶段检测框架：第一阶段负责提取图像特征并生成候选区域，第二阶段则在这些候选区域中对目标进行分类和边界框回归。</p><p><img src="/img/DeepLearning/Sort_DeepSort/c1097403f1aa5f102addd3898b556d1.png" alt="Faster R-CNN网络"></p><p>该框架的一个重要优势是，在两个阶段之间共享参数，从而提高了检测效率。此外，由于其网络架构可以灵活地替换和调整，Faster R-CNN能够快速测试不同设计，优化检测性能。通过结合Faster R-CNN，SORT能够实现高效的目标检测和准确的目标跟踪。</p><h3 id="2-SORT-工作流程">2. SORT 工作流程</h3><p>SORT的工作流程是：首先，使用卡尔曼滤波器对目标进行预测；然后，通过匈牙利算法进行数据关联，将预测结果与当前帧中的检测结果匹配；最后，对未匹配的目标进行处理（通常是新目标的加入或丢失目标的删除）。</p><p><strong>关键步骤：<strong>轨迹卡尔曼滤波</strong>预测</strong>→ 使用<strong>匈牙利算法</strong>将预测后的tracks和当前帧中的detecions进行匹配（<strong>IOU匹配</strong>） → 卡尔曼滤波<strong>更新</strong></p><p><img src="/img/DeepLearning/Sort_DeepSort/image-20200430001731416.png" alt="SORT工作流程"></p><ul><li><strong>卡尔曼滤波</strong>包括两个步骤：<strong>预测</strong>和<strong>更新</strong>。在SORT中，通过引入线性速度模型，卡尔曼滤波用于对目标的位置进行<strong>预测</strong>，即先估计目标的未来位置，然后再进行目标匹配。运动模型提供了目标位置的预测信息，用于帮助追踪过程中更准确地估计物体的运动轨迹。</li><li><strong>匈牙利算法</strong>用于解决<strong>分配问题</strong>，其核心是通过计算每对目标框之间的<strong>IOU</strong>（Intersection over Union）值来构建一个代价矩阵。IOU越大，表示两个目标框之间的重合度越高，匹配的可能性越大。当IOU低于一个设定阈值（通常为0.3）时，认为这两个框不属于同一个目标，从而避免错误匹配。</li></ul><h3 id="3-SORT的运动模型">3. SORT的运动模型</h3><p>SORT算法通过为每个目标定义一个对象模型，将目标的身份和运动状态从当前帧传播到下一帧。为了简化计算，SORT使用了一个线性恒速模型来近似每个目标的帧间位移，这个模型假设目标在每帧之间的位移是恒定的，与其他物体和摄像机的运动无关。</p><p>目标的完整状态向量为：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">x</mi><mo>=</mo><mo stretchy="false">[</mo><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>s</mi><mo separator="true">,</mo><mi>r</mi><mo separator="true">,</mo><mover accent="true"><mi>u</mi><mo>˙</mo></mover><mo separator="true">,</mo><mover accent="true"><mi>v</mi><mo>˙</mo></mover><mo separator="true">,</mo><mover accent="true"><mi>s</mi><mo>˙</mo></mover><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\mathbf{x} = [u, v, s, r, \dot{u}, \dot{v}, \dot{s}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">u</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">˙</span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">˙</span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">s</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.0833em;"><span class="mord">˙</span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span></p><p>其中：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">u</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span>：目标中心位置的坐标（通常为 x 和 y）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span>：目标的尺度（通常是目标框的面积）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>：目标的纵横比（aspect ratio）</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>u</mi><mo>˙</mo></mover></mrow><annotation encoding="application/x-tex">\dot{u}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">u</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">˙</span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>v</mi><mo>˙</mo></mover></mrow><annotation encoding="application/x-tex">\dot{v}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1111em;"><span class="mord">˙</span></span></span></span></span></span></span></span></span></span>：目标在 u 和 v 方向上的速度。</li><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>s</mi><mo>˙</mo></mover></mrow><annotation encoding="application/x-tex">\dot{s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6679em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6679em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">s</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.0833em;"><span class="mord">˙</span></span></span></span></span></span></span></span></span></span>：目标尺度的变化速率。</li></ul><p>SORT算法具有较低的计算复杂度，适合实时追踪，但由于它仅基于目标的运动信息（位置和速度），对目标间的遮挡、外观变化、长时间丢失等情况的鲁棒性较差。</p><p>为了提升跟踪的精度和鲁棒性，<strong>DeepSORT</strong> 应运而生——通过结合深度学习特征和传统的运动预测模型，DeepSORT不仅能够有效解决目标间的相似性判别问题，还能显著增强目标在长时间遮挡或交叉运动中的追踪稳定性。</p><h2 id="三、DeepSORT">三、DeepSORT</h2><h3 id="1-DeepSORT-介绍">1. DeepSORT 介绍</h3><p><strong>DeepSORT</strong>（Deep Learning-based SORT）是基于SORT（Simple Online and Realtime Tracking）算法的改进版，整体框架延续了 SORT 的核心思路，仍然采用了 <strong>卡尔曼滤波</strong> 和 <strong>匈牙利算法</strong> 进行目标的运动预测和数据关联。然而，DeepSORT 在此基础上引入了一个关键改进：<strong>鉴别网络（Deep Association Metric）</strong>，用于增强目标之间的匹配精度。</p><h3 id="2-DeepSORT-算法">2. DeepSORT 算法</h3><h4 id="DeepSORT-关键工作流程">- DeepSORT 关键工作流程</h4><ol><li><p><strong>轨迹卡尔曼滤波预测</strong>：</p><ul><li>对于每个已追踪的目标，卡尔曼滤波器会基于目标的当前位置和速度，预测目标在当前帧中的位置。这一过程是根据目标的运动模型（例如线性恒速模型）进行的，主要用于估计目标在下一帧的可能位置。</li></ul></li><li><p><strong>使用匈牙利算法进行匹配</strong>：</p><ul><li><p>匈牙利算法用于解决目标匹配问题，将</p><p>预测后的目标轨迹tracked targets）与 当前帧中的检测框（detections）进行匹配。这里的匹配通常通过两种方式进行：</p><ul><li><strong>级联匹配</strong>（Cascade Matching）：首先进行粗匹配，然后逐步精细化，确保每个目标的匹配都是最合适的。</li><li><strong>IOU匹配</strong>（Intersection over Union matching）：通过计算目标边界框与检测框之间的 <strong>IOU</strong> 值，匹配预测轨迹和当前帧中的检测目标。IOU值较高的目标会被认为是同一个目标，从而进行匹配。</li></ul></li></ul></li><li><p><strong>卡尔曼滤波更新</strong>：</p><ul><li>在目标匹配后，卡尔曼滤波器会根据匹配结果对目标的状态进行 <strong>更新</strong>。这一步会根据实际检测到的目标位置来修正预测轨迹，从而提高追踪的准确性。</li></ul></li></ol><p>流程图如下：</p><p><img src="/img/DeepLearning/Sort_DeepSort/image-20200430003426746.png" alt="DeepSort工作流程"></p><h4 id="级联匹配流程">- 级联匹配流程</h4><p>这个流程是DeepSORT多目标跟踪算法中确保目标准确匹配的重要步骤</p><ol><li><p><strong>距离计算</strong>：</p><ul><li><p>使用 <strong>马氏距离（Mahalanobis Distance, d1）</strong> 和 <strong>余弦距离（Cosine Distance, d2）</strong>，通过线性加权方式生成 <strong>代价矩阵（Cost Matrix）</strong>：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mo>=</mo><mi>λ</mi><msub><mi>d</mi><mn>1</mn></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>λ</mi><mo stretchy="false">)</mo><msub><mi>d</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">C= \lambda d_1 + (1 - \lambda) d_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal">λ</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">λ</span><span class="mclose">)</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p></li><li><p><strong>马氏距离</strong> 表示运动模型的匹配程度，衡量预测轨迹与检测框之间的一致性</p></li><li><p><strong>余弦距离</strong> 衡量外观特征的相似性，判断目标外观的一致性</p></li></ul></li><li><p><strong>门限限制（Gate Matrix）</strong>：</p><ul><li>引入一个 <strong>门限（gating_threshold）</strong> 来过滤掉不可能的匹配结果，生成 <strong>Gate Matrix</strong>，将代价矩阵中超过最大距离（<strong>max_distance</strong>）的匹配关系剔除，减少误匹配</li></ul></li><li><p><strong>匈牙利算法（Hungarian Algorithm）进行分配</strong>：</p><ul><li>根据生成的代价矩阵，使用 <strong>匈牙利算法</strong> 在当前帧中的检测结果和轨迹之间进行匹配</li></ul></li><li><p><strong>级联匹配</strong>：</p><ul><li>以目标轨迹的 <strong>age（年龄）</strong> 为顺序，优先匹配 <strong>missing age = 0</strong>（即刚更新过的轨迹）对应的检测框，确保更新最频繁的目标优先匹配</li><li>如果有轨迹未匹配成功，其 <strong>missing age</strong> 加1，继续尝试匹配，直到达到最大允许丢失帧数（<strong>max_age</strong>）</li><li>重复该过程直至所有检测和轨迹匹配完成</li></ul></li><li><p><strong>输出结果</strong>：</p><ul><li>返回已匹配的轨迹集合和未匹配的检测集合，用于更新目标状态或初始化新的目标轨迹</li></ul></li></ol><p>流程图如下：</p><p><img src="/img/DeepLearning/Sort_DeepSort/image-20200430004523485.png" alt="级联匹配"></p><h2 id="四、代码实现">四、代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># SORT多目标追踪</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sort</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, max_age = <span class="hljs-number">1</span>, min_hits = <span class="hljs-number">3</span></span>):<br>        <span class="hljs-comment"># 最大跟踪次数</span><br>        <span class="hljs-variable language_">self</span>.max_age = max_age<br>        <span class="hljs-comment"># 最小命中次数</span><br>        <span class="hljs-variable language_">self</span>.min_hits = min_hits<br>        <span class="hljs-comment"># 跟踪框</span><br>        <span class="hljs-variable language_">self</span>.trackers = []<br>        <span class="hljs-comment"># 帧数</span><br>        <span class="hljs-variable language_">self</span>.frame_count = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self, dets</span>):<br>        <span class="hljs-comment"># 记录状态异常的跟踪器索引</span><br>        <span class="hljs-variable language_">self</span>.frame_count = <span class="hljs-number">1</span><br>        <span class="hljs-comment"># 根据当前所有的卡尔曼跟踪器个数（即上一帧中跟踪的目标个数）创建二维数组</span><br>        <span class="hljs-comment"># 存储器跟踪预测treks</span><br>        treks = np.zeros((<span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.trackers), <span class="hljs-number">5</span>))<br>        to_del = [] <span class="hljs-comment"># 要删除的目标框</span><br>        ret = [] <span class="hljs-comment"># 存储要返回的追踪目标框</span><br>        <span class="hljs-comment"># 循环遍历卡尔曼滤波器t产生的对应目标的跟踪框</span><br>        <span class="hljs-keyword">for</span> t, trk <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(treks):<br>            <span class="hljs-comment"># 更新跟踪器的状态</span><br>            pos = <span class="hljs-variable language_">self</span>.trackers[t].predict()[<span class="hljs-number">0</span>]<br>            trk[:] = [pos[<span class="hljs-number">0</span>], pos[<span class="hljs-number">1</span>], pos[<span class="hljs-number">2</span>], pos[<span class="hljs-number">3</span>], <span class="hljs-number">0</span>]<br>            <span class="hljs-comment"># 若跟踪器的跟踪次数大于最大跟踪次数，则删除</span><br>            <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">any</span>(np.isnan(pos)):<br>                to_del.append(t)<br>        <span class="hljs-comment"># 删除跟踪器</span><br>        treks = np.ma.compress_rows(np.ma.masked_invalid(treks))<br>        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(to_del):<br>            <span class="hljs-variable language_">self</span>.trackers.pop(t)<br>        <span class="hljs-comment"># 检测框数</span><br>        matched, unmatched_dets, unmatched_trks = associate_detections_to_trackers(dets, treks)<br><br>        <span class="hljs-comment"># 更新跟踪器状态</span><br>        <span class="hljs-keyword">for</span> t, trk <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-variable language_">self</span>.trackers):<br>            <span class="hljs-keyword">if</span> t <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> unmatched_trks:<br>                d = matched[np.where(matched[:, <span class="hljs-number">1</span>] == t)[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>]<br>                trk.update(dets[d, :][<span class="hljs-number">0</span>])<br><br>        <span class="hljs-comment"># 新的跟踪器</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> unmatched_dets:<br>            trk = KalmanBoxTracker(dets[i, :])<br>            <span class="hljs-variable language_">self</span>.trackers.append(trk)<br><br>        i = <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.trackers)<br>        <span class="hljs-keyword">for</span> trk <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(<span class="hljs-variable language_">self</span>.trackers):<br>            d = trk.get_state()[<span class="hljs-number">0</span>]<br>            <span class="hljs-keyword">if</span> (trk.time_since_update &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">and</span> (trk.hit_streak &gt;= <span class="hljs-variable language_">self</span>.min_hits <span class="hljs-keyword">or</span> <span class="hljs-variable language_">self</span>.frame_count &lt;= <span class="hljs-variable language_">self</span>.min_hits):<br>                ret.append(np.concatenate((d, [trk.<span class="hljs-built_in">id</span>+<span class="hljs-number">1</span>])).reshape(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>))<br>            i -= <span class="hljs-number">1</span><br>            <span class="hljs-comment"># 跟踪失败或离开画面的目标从卡尔曼跟踪器中删除</span><br>            <span class="hljs-keyword">if</span> trk.time_since_update &gt; <span class="hljs-variable language_">self</span>.max_age:<br>                <span class="hljs-variable language_">self</span>.trackers.pop(i)<br><br>        <span class="hljs-comment"># 返回当前画面中所有目标的box与id</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(ret) &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> np.concatenate(ret)<br>        <span class="hljs-keyword">return</span> np.empty((<span class="hljs-number">0</span>, <span class="hljs-number">5</span>))<br></code></pre></td></tr></table></figure><h2 id="五、总结">五、总结</h2><h3 id="1-SORT算法">1. <strong>SORT算法</strong></h3><p>SORT（Simple Online and Realtime Tracking）是一种轻量级且高效的多目标跟踪算法，它依赖于强大的目标检测器（如Faster R-CNN）提供检测框，通过结合 <strong>卡尔曼滤波</strong> 和 <strong>匈牙利算法</strong> 实现目标的实时跟踪。</p><ul><li><strong>卡尔曼滤波</strong>：用于预测目标在下一帧的位置，通过运动模型更新目标状态。</li><li><strong>匈牙利算法</strong>：解决目标匹配问题，将检测框和预测轨迹进行关联。</li></ul><p>虽然SORT算法简单高效，但在目标遮挡、密集场景以及外观相似的目标之间容易出现错误匹配。</p><h3 id="2-DeepSORT算法">2. <strong>DeepSORT算法</strong></h3><p>DeepSORT是SORT算法的改进版本，在保持高效性的同时，提升了多目标跟踪的准确性和鲁棒性。主要改进包括：</p><ol><li><strong>增加了级联匹配</strong>：通过优先匹配更新频繁的轨迹（即轨迹“年龄”较小的目标），减少了误匹配和目标丢失。</li><li><strong>引入目标确认机制</strong>：增加了“确认状态”（Confirmed Tracks）的概念，只有经过多帧匹配的目标才会被确认，从而避免短时噪声目标干扰。</li><li><strong>深度外观特征的融合</strong>：引入深度学习提取的外观特征（Deep Association Metric），结合马氏距离和余弦距离来优化匹配过程，大幅提高了在目标遮挡或外观相似情况下的跟踪效果。</li></ol><ul><li><strong>卡尔曼滤波 + 匈牙利算法</strong>：依然是跟踪的基础框架，用于处理运动状态的预测和检测框的匹配。</li></ul><h3 id="参考文献">参考文献</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/59148865">https://zhuanlan.zhihu.com/p/59148865</a></li><li><a href="https://zhuanlan.zhihu.com/p/646154999">https://zhuanlan.zhihu.com/p/646154999</a></li><li><a href="https://blog.csdn.net/zimiao552147572/article/details/106009021">https://blog.csdn.net/zimiao552147572/article/details/106009021</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>DeepLearning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepLearning</tag>
      
      <tag>OpenCV</tag>
      
      <tag>目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法】AES-数据库加密算法</title>
    <link href="/2025/01/11/algorithm/SqlEncryption/"/>
    <url>/2025/01/11/algorithm/SqlEncryption/</url>
    
    <content type="html"><![CDATA[<h1>数据库信息加密</h1><p>​为了保障三方用户的个人隐私，防止信息泄露，我们采用了高级加密标准（AES，Advanced Encryption Standard）为最常见的对称加密算法，并利用java自带软件包javax.crypto 对数据库中的信息进行加密。该加密算法的具体流程如下：</p><p><img src="/img/algorithm/SqlEncryption/image-20250111204228629.png" alt="AES加密流程"></p><h2 id="一，AES的数据结构">一，AES的数据结构</h2><p>​加密解密算法的输入是一个128位分组。这些分组被描述成4×4的字节方阵，这个分组被复制到state数组中，并在加密和解密的每一阶段都被修改。在字节方阵中，每一格都是一个字，包含了4字节。在矩阵中字是按列排序的。</p><p><img src="/img/algorithm/SqlEncryption/image-20250111204236830.png" alt="AES的数据结构"></p><h2 id="二，AES加密过程：">二，AES加密过程：</h2><p>​我们采用明文长度固定128位，密钥长度128位。首先将前端传输过来的字符串信息转换成byte位（明文），将该明文转换为一个4×4的矩阵，和给定初始的子密钥进行异或得到变换矩阵。接着将该变换矩阵进行字节代换，行移位，列混合，轮密钥加，如此循环9次后跳出，在第10次循环（即最后一次循环中）只进行字节代换，行移位，轮密钥加得到最终矩阵，该矩阵即为密文。</p><p><img src="/img/algorithm/SqlEncryption/image-20250111204241908.png" alt="AES加密过程"></p><h2 id="三，加密的详细结构">三，加密的详细结构</h2><h3 id="1-字节代换（SubBytes）">1.字节代换（SubBytes）</h3><p>通过S-BOX查表进行字节的代换。</p><p><img src="https://pic1.zhimg.com/80/v2-e160744c78b680b008c165cb78841858_1440w.webp" alt="S-BOX表"></p><p>​加密图示：</p><p><img src="https://pic1.zhimg.com/80/v2-83b41eb29d3e797bafdc4d669365bf5c_1440w.webp" alt="加密图示"></p><h3 id="2-行移位（ShiftRows）">2.行移位（ShiftRows）</h3><p><img src="/img/algorithm/SqlEncryption/image-20250111204259284.png" alt="行移位"></p><h3 id="3-列混合（MixColumns）">3.列混合（MixColumns）</h3><p>​列混合变换是通过矩阵相乘来实现的，经行移位后的状态矩阵与固定的矩阵相乘，得到混淆后的状态矩阵，如下图的公式所示：</p><p><img src="/img/algorithm/SqlEncryption/image-20250111204303699.png" alt="列混合"></p><p>​状态矩阵中的第j列(0 ≤j≤3)的列混合可以表示为下图所示：</p><p><img src="/img/algorithm/SqlEncryption/image-20250111204308063.png" alt="状态矩阵的第j列"></p><p>​注意：矩阵元素的乘法和加法都是定义在基于GF(2^8)上的二元运算，并不是通常意义上的乘法和加法。具体运算规则为：</p><p><img src="/img/algorithm/SqlEncryption/image-20250111204314508.png" alt="具体运算规则"></p><h3 id="4-轮密钥加（AddRoundKey）">4.轮密钥加（AddRoundKey）</h3><p>​轮密钥加是将128位轮密钥同状态矩阵中的数据进行逐位异或操作。</p><p>​例如：对于该密钥矩阵和状态矩阵进行操作</p><p><img src="/img/algorithm/SqlEncryption/1.png" alt="轮密钥加"></p><p>​由于会进行10轮循环，因此密钥需要进行扩展。</p><p>​<strong>密钥扩展过程：</strong></p><p>​设要求的列为Wi。</p><p>​考虑在求Wi时根据i是否为4的倍数：</p><ol><li><p>若i不是4的倍数，那么第i列由如下等式确定：<strong>W[i] = W[i-4] ⊕ W[i-1]</strong></p></li><li><p>如果i是4的倍数，那么第i列由如下等式确定：<strong>W[i] = W[i-4] ⊕ T(W[i-1])</strong></p></li></ol><p>​<strong>T函数的求解：</strong></p><ul><li><p><strong>字循环</strong>：将1个字中的4个字节循环左移1的字节。即将输入字[b0, b1, b2, b3]变换成[b1, b2, b3, b0]。</p></li><li><p><strong>字节代换</strong>：对字的循环结果使用S-BOX进行字节代换</p></li><li><p><strong>轮常量异或</strong>：将前两步的结果同轮常量Rcon[j]进行异或，其中j表示轮数。</p><p><img src="/img/algorithm/SqlEncryption/image-20250111204321128.png" alt="Rcon矩阵"></p></li></ul><h2 id="四、代码演示">四、代码演示</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 常量 S-Box 和反向 S-Box</span><br>SBox = [<br>    <span class="hljs-comment"># 0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F</span><br>    [<span class="hljs-number">0x63</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0x7B</span>, <span class="hljs-number">0xF2</span>, <span class="hljs-number">0x6B</span>, <span class="hljs-number">0x6F</span>, <span class="hljs-number">0xC5</span>, <span class="hljs-number">0x30</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0x2B</span>, <span class="hljs-number">0xFE</span>, <span class="hljs-number">0xD7</span>, <span class="hljs-number">0xAB</span>, <span class="hljs-number">0x76</span>],<br>    [<span class="hljs-number">0xCA</span>, <span class="hljs-number">0x82</span>, <span class="hljs-number">0xC9</span>, <span class="hljs-number">0x7D</span>, <span class="hljs-number">0xFA</span>, <span class="hljs-number">0x59</span>, <span class="hljs-number">0x47</span>, <span class="hljs-number">0xF0</span>, <span class="hljs-number">0xAD</span>, <span class="hljs-number">0xD4</span>, <span class="hljs-number">0xA2</span>, <span class="hljs-number">0xAF</span>, <span class="hljs-number">0x9C</span>, <span class="hljs-number">0xA8</span>, <span class="hljs-number">0x51</span>, <span class="hljs-number">0xA3</span>],<br>    [<span class="hljs-number">0x40</span>, <span class="hljs-number">0x8F</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0x9D</span>, <span class="hljs-number">0x38</span>, <span class="hljs-number">0xF5</span>, <span class="hljs-number">0xBC</span>, <span class="hljs-number">0xB6</span>, <span class="hljs-number">0xDA</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xF3</span>, <span class="hljs-number">0xD2</span>, <span class="hljs-number">0xCD</span>, <span class="hljs-number">0x0C</span>],<br>    [<span class="hljs-number">0x13</span>, <span class="hljs-number">0xEC</span>, <span class="hljs-number">0x5F</span>, <span class="hljs-number">0x97</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x17</span>, <span class="hljs-number">0xC4</span>, <span class="hljs-number">0xA5</span>, <span class="hljs-number">0xE3</span>, <span class="hljs-number">0xF6</span>, <span class="hljs-number">0x84</span>, <span class="hljs-number">0x9A</span>, <span class="hljs-number">0x7E</span>, <span class="hljs-number">0x3D</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x5D</span>],<br>    [<span class="hljs-number">0x19</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x60</span>, <span class="hljs-number">0x81</span>, <span class="hljs-number">0x4F</span>, <span class="hljs-number">0xDC</span>, <span class="hljs-number">0x22</span>, <span class="hljs-number">0x2A</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0xEE</span>, <span class="hljs-number">0xB8</span>, <span class="hljs-number">0x14</span>, <span class="hljs-number">0xDE</span>, <span class="hljs-number">0x5E</span>],<br>    [<span class="hljs-number">0x0B</span>, <span class="hljs-number">0xDB</span>, <span class="hljs-number">0xE0</span>, <span class="hljs-number">0x32</span>, <span class="hljs-number">0x3A</span>, <span class="hljs-number">0x0A</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0x06</span>, <span class="hljs-number">0x24</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0xC2</span>, <span class="hljs-number">0xD3</span>, <span class="hljs-number">0xAC</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0x95</span>],<br>    [<span class="hljs-number">0x0F</span>, <span class="hljs-number">0x37</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x3F</span>, <span class="hljs-number">0xF7</span>, <span class="hljs-number">0xCC</span>, <span class="hljs-number">0x34</span>, <span class="hljs-number">0xA0</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0xB5</span>, <span class="hljs-number">0x6E</span>, <span class="hljs-number">0xFF</span>, <span class="hljs-number">0xD0</span>, <span class="hljs-number">0x8D</span>],<br>    [<span class="hljs-number">0x90</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x97</span>, <span class="hljs-number">0xB1</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0xA9</span>, <span class="hljs-number">0xD2</span>, <span class="hljs-number">0x6F</span>, <span class="hljs-number">0x7A</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x99</span>, <span class="hljs-number">0x7D</span>, <span class="hljs-number">0x6B</span>, <span class="hljs-number">0x90</span>]<br>]<br><br><span class="hljs-comment"># 乘法常量矩阵用于 MixColumns</span><br>MixColumnsMatrix = [<br>    [<span class="hljs-number">0x02</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x01</span>],<br>    [<span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x01</span>],<br>    [<span class="hljs-number">0x01</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x03</span>],<br>    [<span class="hljs-number">0x03</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>]<br>]<br><br><span class="hljs-comment"># 字节替换 (SubBytes) 变换</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sub_bytes</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">return</span> [[SBox[(state[i][j] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0F</span>][state[i][j] &amp; <span class="hljs-number">0x0F</span>] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]<br><br><span class="hljs-comment"># 行移位 (ShiftRows) 变换</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">shift_rows</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>):<br>        state[i] = state[i][i:] + state[i][:i]  <span class="hljs-comment"># 左移 i 位</span><br>    <span class="hljs-keyword">return</span> state<br><br><span class="hljs-comment"># 列混合 (MixColumns) 变换</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mix_columns</span>(<span class="hljs-params">state</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gmul</span>(<span class="hljs-params">a, b</span>):<br>        p = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> a &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> a &amp; <span class="hljs-number">0x01</span>:<br>                p ^= b<br>            a &gt;&gt;= <span class="hljs-number">1</span><br>            b = (b &lt;&lt; <span class="hljs-number">1</span>) ^ (<span class="hljs-number">0x11B</span> <span class="hljs-keyword">if</span> b &amp; <span class="hljs-number">0x80</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> p<br><br>    new_state = [[<span class="hljs-number">0</span>] * <span class="hljs-number">4</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>            new_state[i][j] = gmul(state[i][<span class="hljs-number">0</span>], MixColumnsMatrix[j][<span class="hljs-number">0</span>]) ^ \<br>                              gmul(state[i][<span class="hljs-number">1</span>], MixColumnsMatrix[j][<span class="hljs-number">1</span>]) ^ \<br>                              gmul(state[i][<span class="hljs-number">2</span>], MixColumnsMatrix[j][<span class="hljs-number">2</span>]) ^ \<br>                              gmul(state[i][<span class="hljs-number">3</span>], MixColumnsMatrix[j][<span class="hljs-number">3</span>])<br>    <span class="hljs-keyword">return</span> new_state<br><br><span class="hljs-comment"># 轮密钥加 (AddRoundKey)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_round_key</span>(<span class="hljs-params">state, round_key</span>):<br>    <span class="hljs-keyword">return</span> [[state[i][j] ^ round_key[i][j] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]<br><br><span class="hljs-comment"># 密钥扩展（从原始密钥生成多个轮密钥）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">key_expansion</span>(<span class="hljs-params">key</span>):<br>    Rcon = [<span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x04</span>, <span class="hljs-number">0x08</span>, <span class="hljs-number">0x10</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x40</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x1B</span>, <span class="hljs-number">0x36</span>]<br>    round_keys = [[key[i + <span class="hljs-number">4</span> * j] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(round_keys) &lt; <span class="hljs-number">44</span>:  <span class="hljs-comment"># AES-128 使用 44 个字</span><br>        temp = round_keys[-<span class="hljs-number">1</span>]<br>        temp = [SBox[(temp[<span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0F</span>][temp[<span class="hljs-number">1</span>] &amp; <span class="hljs-number">0x0F</span>], <br>                SBox[(temp[<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0F</span>][temp[<span class="hljs-number">2</span>] &amp; <span class="hljs-number">0x0F</span>], <br>                SBox[(temp[<span class="hljs-number">3</span>] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0F</span>][temp[<span class="hljs-number">3</span>] &amp; <span class="hljs-number">0x0F</span>], <br>                SBox[(temp[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">4</span>) &amp; <span class="hljs-number">0x0F</span>][temp[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x0F</span>]]<br><br>        temp[<span class="hljs-number">0</span>] ^= Rcon[<span class="hljs-built_in">len</span>(round_keys) // <span class="hljs-number">4</span>]<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>            round_keys.append([round_keys[<span class="hljs-built_in">len</span>(round_keys) - <span class="hljs-number">4</span>][i] ^ temp[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)])<br><br>    <span class="hljs-keyword">return</span> round_keys<br><br><span class="hljs-comment"># 完整的 AES 加密过程</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">AES_encrypt</span>(<span class="hljs-params">plain_text, key</span>):<br>    state = [[plain_text[i + <span class="hljs-number">4</span> * j] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]<br>    round_keys = key_expansion(key)<br>    <br>    state = add_round_key(state, round_keys[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 初始轮</span><br>    <br>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">round</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>):  <span class="hljs-comment"># 9 轮</span><br>        state = sub_bytes(state)<br>        state = shift_rows(state)<br>        state = mix_columns(state)<br>        state = add_round_key(state, round_keys[<span class="hljs-built_in">round</span>])<br>    <br>    <span class="hljs-comment"># 最后一轮，没有 MixColumns</span><br>    state = sub_bytes(state)<br>    state = shift_rows(state)<br>    state = add_round_key(state, round_keys[<span class="hljs-number">10</span>])<br>    <br>    <span class="hljs-comment"># 输出密文（行列转置为结果）</span><br>    <span class="hljs-keyword">return</span> [state[i][j] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>)]<br><br><span class="hljs-comment"># 主函数，输入数据</span><br>plain_text = [<br>    <span class="hljs-number">0x32</span>, <span class="hljs-number">0x88</span>, <span class="hljs-number">0x31</span>, <span class="hljs-number">0xe0</span>,<br>    <span class="hljs-number">0xc0</span>, <span class="hljs-number">0x80</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x7a</span>,<br>    <span class="hljs-number">0x5b</span>, <span class="hljs-number">0x6b</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x79</span>,<br>    <span class="hljs-number">0x44</span>, <span class="hljs-number">0x5d</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x5e</span><br>]<br><br>key = [<br>    <span class="hljs-number">0x2b</span>, <span class="hljs-number">0x7e</span>, <span class="hljs-number">0x15</span>, <span class="hljs-number">0x16</span>,<br>    <span class="hljs-number">0x28</span>, <span class="hljs-number">0xae</span>, <span class="hljs-number">0xd2</span>, <span class="hljs-number">0xa6</span>,<br>    <span class="hljs-number">0xab</span>, <span class="hljs-number">0xf7</span>, <span class="hljs-number">0x97</span>, <span class="hljs-number">0x75</span>,<br>    <span class="hljs-number">0x46</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x3d</span><br>]<br><br><span class="hljs-comment"># 执行加密</span><br>ciphertext = AES_encrypt(plain_text, key)<br><br><span class="hljs-comment"># 输出密文</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Ciphertext:&quot;</span>)<br><span class="hljs-built_in">print</span>([<span class="hljs-built_in">hex</span>(byte) <span class="hljs-keyword">for</span> byte <span class="hljs-keyword">in</span> ciphertext])<br><br></code></pre></td></tr></table></figure><h2 id="五，参考文献">五，参考文献</h2><p><a href="https://www.cnblogs.com/block2016/p/5596676.html">https://www.cnblogs.com/block2016/p/5596676.html</a></p><p><a href="https://blog.csdn.net/qq_28205153/article/details/55798628">https://blog.csdn.net/qq_28205153/article/details/55798628</a></p><p><a href="https://zhuanlan.zhihu.com/p/78913397">https://zhuanlan.zhihu.com/p/78913397</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法笔记】存图方式 — 链式前向星</title>
    <link href="/2025/01/11/OJ/ChainForwardStar/"/>
    <url>/2025/01/11/OJ/ChainForwardStar/</url>
    
    <content type="html"><![CDATA[<h1>存图方式 — 链式前向星</h1><h2 id="边的存储">边的存储</h2><p>这种存图方式只需要开一个数组存储每个点引出的第一条边，然后存储每个点作为起点的每条边，这样就可以做到不重不漏</p><p>在链式前向星存图中，我们需要定义一个结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">EDGE</span> &#123;<br>    <span class="hljs-type">int</span> next;<br>    <span class="hljs-type">int</span> to;<br>&#125; edge[<span class="hljs-number">1000</span>];<br></code></pre></td></tr></table></figure><p>和一个数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> head[<span class="hljs-number">1000</span>]<br></code></pre></td></tr></table></figure><p>和一个变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">//指针</span><br></code></pre></td></tr></table></figure><p>起点用head数组存</p><p><strong>举例：</strong></p><p><img src="/img/OJ/image-20250111211707179.png" alt=""></p><p>如图：这样一个有向图的输入是：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h3 id="逐步分析：">逐步分析：</h3><h4 id="1-输入1-2，代表1连向2。">1. 输入1 2，代表1连向2。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">cnt ++;<span class="hljs-comment">//作为结构体下标，没有意义</span><br>head[<span class="hljs-number">1</span>] = cnt; <span class="hljs-comment">//结点1的第一个儿子存在了edge[cnt]里面</span><br>edge[cnt].to = <span class="hljs-number">2</span>; <span class="hljs-comment">//结点1的儿子是2</span><br></code></pre></td></tr></table></figure><p>此时 ：cnt = 1</p><table><thead><tr><th style="text-align:center">edge</th><th style="text-align:center">cnt = 1</th><th style="text-align:center">cnt = 2</th><th style="text-align:center">cnt = 3</th><th style="text-align:center">cnt = 4</th></tr></thead><tbody><tr><td style="text-align:center">to</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">next</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><table><thead><tr><th style="text-align:center">head[ ]</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th></tr></thead><tbody><tr><td style="text-align:center">值</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><h4 id="2-输入1-3，代表1连向3">2. 输入1 3，代表1连向3.</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">cnt++;<br>head[<span class="hljs-number">1</span>] = cnt;<br>edge[cnt].to = <span class="hljs-number">3</span>;<span class="hljs-comment">//结点1的儿子是3</span><br><span class="hljs-comment">//这时，3成为了结点1的儿子，不过2被挤了下去</span><br><span class="hljs-comment">//所以要引入结构体中next元素，记录：3还有个兄弟（next）是2</span><br><br><span class="hljs-comment">//所以代码要换成：</span><br>cnt++;<br>edge[cnt].to = <span class="hljs-number">3</span>;<span class="hljs-comment">//结点1连向3</span><br>edge[cnt].next = head[<span class="hljs-number">1</span>];<span class="hljs-comment">//3的兄弟是2</span><br>head[<span class="hljs-number">1</span>] = cnt;<span class="hljs-comment">//更新head</span><br></code></pre></td></tr></table></figure><p>此时：cnt = 2</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">cnt = 1</th><th style="text-align:center">cnt = 2</th><th style="text-align:center">cnt = 3</th><th style="text-align:center">cnt = 4</th></tr></thead><tbody><tr><td style="text-align:center">to</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">next</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><table><thead><tr><th style="text-align:center">head[ ]</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td style="text-align:center">值</td><td>2</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h4 id="3-输入1-4，代表1连向4。">3. 输入1 4，代表1连向4。</h4><p>此时：cnt = 3</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">cnt = 1</th><th style="text-align:center">cnt = 2</th><th style="text-align:center">cnt = 3</th><th style="text-align:center">cnt = 4</th></tr></thead><tbody><tr><td style="text-align:center">to</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">next</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td></tr></tbody></table><table><thead><tr><th style="text-align:center">head[ ]</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td style="text-align:center">值</td><td>3</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><h4 id="4-输入2-3，代表2连向3。">4. 输入2 3，代表2连向3。</h4><p>此时：cnt = 4</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">cnt = 1</th><th style="text-align:center">cnt = 2</th><th style="text-align:center">cnt = 3</th><th style="text-align:center">cnt = 4</th></tr></thead><tbody><tr><td style="text-align:center">to</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">next</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td></tr></tbody></table><table><thead><tr><th style="text-align:center">head[ ]</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td style="text-align:center">值</td><td>3</td><td>0</td><td>0</td><td>0</td></tr></tbody></table><p><strong>若需要记录权值，在结构体中加入一个元素即可</strong></p><p>代码：（带权值）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123;<br>    <span class="hljs-type">int</span> next;<br>    <span class="hljs-type">int</span> to;<br>    <span class="hljs-type">int</span> wei;<br>&#125; edge[maxn];<br><span class="hljs-type">int</span> head[maxn]; <span class="hljs-comment">//head[i] 为i点的第一条边</span><br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span> </span>&#123;<br>    edge[++cnt].next = head[u];<br>    edge[cnt].to = v;<br>    edge[cnt].w = w;<br>    head[u] = cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> a, b, w;<br>        <span class="hljs-built_in">addedge</span>(a, b, w);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注意：">注意：</h4><p>这里的next指的是遍历时的下一条边，head指的是遍历时的第一条边，而存边时相当于反过来操作，所以next记录上一条边，而head记录最后一条边。</p><h2 id="边的遍历">边的遍历</h2><p>在遍历以x为起点的所有边时，只需要这样就行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">for</span>(int <span class="hljs-attribute">i</span>=head[x]; i; <span class="hljs-attribute">i</span>=edge[i].next)<br></code></pre></td></tr></table></figure><p>这个循环的结束条件是i等于0，因为最后一条边，也就是存边时第一条边，在把head值存进next时，head还没有更新过，也就是0。所以当next返回0时，就说明这些边遍历完毕了。</p><h2 id="优势与特点">优势与特点</h2><p>既可以存图，也可以存树，比起邻接矩阵，链式前向星的空间复杂度是O（n），大大节省了存储空间，因为按边存储省掉了很多两点无边的空间。并且在遍历的时候，那些与起点无边相连的点也不需要进行处理，可以说时间和空间都占优势，这就是被OIer们广泛使用的原因。</p><h1>实践 —— 单源最短路径</h1><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> head[<span class="hljs-number">100000</span>],cnt;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans[<span class="hljs-number">1000000</span>];<br><span class="hljs-type">bool</span> vis[<span class="hljs-number">1000000</span>];<br><span class="hljs-type">int</span> m,n,s;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span><br>&#123;<br><span class="hljs-type">int</span> to;<br><span class="hljs-type">int</span> nextt;<br><span class="hljs-type">int</span> wei;<br>&#125;edge[<span class="hljs-number">1000000</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> z)</span></span><br><span class="hljs-function"></span>&#123;<br>edge[++cnt].to=y;<br>edge[cnt].wei=z;<br>edge[cnt].nextt=head[x];<br>head[x]=cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin&gt;&gt;m&gt;&gt;n&gt;&gt;s;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br>ans[i]=<span class="hljs-number">2147483647</span>;<br>&#125;<br>ans[s]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br><span class="hljs-built_in">addedge</span>(a,b,c);<br>&#125;<br><span class="hljs-type">int</span> pos=s;<br><span class="hljs-keyword">while</span>(vis[pos]==<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> minn=<span class="hljs-number">2147483647</span>;<br>vis[pos]=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[pos];i!=<span class="hljs-number">0</span>;i=edge[i].nextt)<br>&#123;<br><span class="hljs-keyword">if</span>(!vis[edge[i].to]&amp;&amp;ans[edge[i].to]&gt;ans[pos]+edge[i].wei)<br>&#123;<br>ans[edge[i].to]=ans[pos]+edge[i].wei;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(ans[i]&lt;minn&amp;&amp;vis[i]==<span class="hljs-number">0</span>)<br>&#123;<br>minn=ans[i];<br>pos=i;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br>cout&lt;&lt;ans[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法笔记】康托展开</title>
    <link href="/2025/01/11/OJ/CantorUnfolds/"/>
    <url>/2025/01/11/OJ/CantorUnfolds/</url>
    
    <content type="html"><![CDATA[<h1>康托展开</h1><h3 id="康托展开运算">康托展开运算</h3><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>X</mi><mo>=</mo><msub><mi>a</mi><mi>n</mi></msub><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo><mo>+</mo><msub><mi>a</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>a</mi><mn>1</mn></msub><mo>⋅</mo><mn>0</mn><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">X = a_n (n-1)! + a_{n-1} (n-2)! + \cdots + a_1 \cdot 0!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)!</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)!</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5945em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">0</span><span class="mclose">!</span></span></span></span></span></p><p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 为整数, 并且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><msub><mi>a</mi><mi>i</mi></msub><mo>&lt;</mo><mi>i</mi><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">0 \leq a_i &lt; i, 1 \leq i \leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>。</p><h3 id="康托展开举例">康托展开举例</h3><p>再举个例子说明。</p><p>在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo separator="true">,</mo><mn>5</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1, 2, 3, 4, 5)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">5</span><span class="mclose">)</span></span></span></span> 5 个数的排列组合中，计算 34152 的康托展开值。</p><p>首先是 3，则小于 3 的数有两个，为 1 和 2，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mn>5</mn><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">a[5] = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord">5</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，则首位小于 3 的所有排列组合为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mn>5</mn><mo stretchy="false">]</mo><mo>×</mo><mo stretchy="false">(</mo><mn>5</mn><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo></mrow><annotation encoding="application/x-tex">a[5] \times (5 - 1)!</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord">5</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)!</span></span></span></span>。</p><p>第二位是 4，由于第一位小于 4，1、2、3 中一定会有 1 个充当第一位，所以排在 4 之下的只剩 2 个，所以其计算的是在第二位之后小于 4 的个数。因此 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mn>4</mn><mo stretchy="false">]</mo><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">a[4] = 2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord">4</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>。</p><p>第三位是 1，则在其之后小于 1 的数有 0 个，所以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">a[3] = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord">3</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。</p><p>第四位是 5，则在其之后小于 5 的数有 1 个，为 2，所以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mn>2</mn><mo stretchy="false">]</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">a[2] = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。</p><p>最后一位就不用计算了，因为在它之后已经没有数了，所以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">a[1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span></span></span></span> 固定为 0。</p><p>根据公式：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>X</mi><mo>=</mo><mn>2</mn><mo>×</mo><mn>4</mn><mo stretchy="false">!</mo><mo>+</mo><mn>2</mn><mo>×</mo><mn>3</mn><mo stretchy="false">!</mo><mo>+</mo><mn>0</mn><mo>×</mo><mn>2</mn><mo stretchy="false">!</mo><mo>+</mo><mn>1</mn><mo>×</mo><mn>1</mn><mo stretchy="false">!</mo><mo>+</mo><mn>0</mn><mo>×</mo><mn>0</mn><mo stretchy="false">!</mo><mo>=</mo><mn>61</mn></mrow><annotation encoding="application/x-tex">X = 2 \times 4! + 2 \times 3! + 0 \times 2! + 1 \times 1! + 0 \times 0! = 61</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">3</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord">0</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">61</span></span></span></span></span></p><p>所以比 34152 小的组合有 61 个，即 34152 是第 62。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cantor</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a[], <span class="hljs-type">long</span> <span class="hljs-type">long</span> len)</span> </span>&#123; <br>    <span class="hljs-comment">//cantor展开,n表示是n位的全排列，a[]表示全排列的数（用数组表示） </span><br><br><span class="hljs-comment">//1-100阶乘 </span><br><span class="hljs-type">int</span> factorial[<span class="hljs-number">101</span>];<br>factorial[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++) &#123;<br>factorial[i] = factorial[i<span class="hljs-number">-1</span>]*i;<br>&#125;<br><br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) &#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i<span class="hljs-number">+1</span>; j &lt;= len; j++) &#123;<br><span class="hljs-keyword">if</span>(a[j] &lt; a[i]) &#123;<br>cnt ++;<br>&#125;<br>&#125;<br>ans += cnt*factorial[len-i];<span class="hljs-comment">//累积</span><br>cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">//计数器归零</span><br>&#125;<br><span class="hljs-keyword">return</span> ans<span class="hljs-number">+1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【常见算法问题】最大子序列和问题</title>
    <link href="/2025/01/11/OJ/MaxSubColumn/"/>
    <url>/2025/01/11/OJ/MaxSubColumn/</url>
    
    <content type="html"><![CDATA[<h1>最大子列和问题</h1><p>求解一个整数数组 A 的<strong>最大子序列和</strong>（Maximum Subsequence Sum），即在数组 A 中找到一个连续子序列，使得该子序列中所有元素的和最大。</p><h2 id="算法1：暴力枚举">算法1：暴力枚举</h2><p>逐一遍历数组中所有可能的连续子序列，计算其和并记录最大值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">MaxSubseqSum1</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> N)</span><br>&#123;<br> <span class="hljs-type">int</span> ThisSum, MaxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i, j, k;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; N; j++) &#123;<br>            ThisSum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(k = i; k &lt;= j; k++)<br>                ThisSum += A[k];<br>                <span class="hljs-keyword">if</span>(ThisSum &gt; MaxSum) <br>                    MaxSum = ThisSum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> MaxSum;<br>&#125;<br></code></pre></td></tr></table></figure><p>算法复杂度：O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>3</mn></msup></mrow><annotation encoding="application/x-tex">N^3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span>)</p><h2 id="算法2：暴力优化">算法2：暴力优化</h2><p>枚举所有可能的子序列求解最大子序列和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">MaxSubseqSum1</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> N)</span><br>&#123;<br> <span class="hljs-type">int</span> ThisSum, MaxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i, j, k;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        ThisSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(j = i; j &lt; N; j++) &#123;<br>ThisSum += A[j];<br>             <span class="hljs-keyword">if</span>(ThisSum &gt; MaxSum) <br>                 MaxSum = ThisSum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> MaxSum;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>N</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">N^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>)</p><h2 id="算法3：贪心">算法3：贪心</h2><p>通过一次遍历动态计算最大子序列和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">MaxSubseqSum1</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> N)</span> &#123;<br>    <span class="hljs-type">int</span> ThisSum, MaxSum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        ThisSum += A[i];<br>        <span class="hljs-keyword">if</span>(ThisSum &gt; MaxSum) &#123;<br>            MaxSum = ThisSum;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ThisSum &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果当前子序列小于0，则不可能使后面增大，抛弃</span><br>            ThisSum = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> MaxSum;<br>&#125;<br></code></pre></td></tr></table></figure><p>复杂度：O(N)</p>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【算法笔记】快速幂</title>
    <link href="/2025/01/11/OJ/QuickCount/"/>
    <url>/2025/01/11/OJ/QuickCount/</url>
    
    <content type="html"><![CDATA[<h1>快速幂运算</h1><p><strong>前置知识：复习一下数学知识：</strong></p><p>对于指数：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>X</mi><mi>A</mi></msup><mo>∗</mo><msup><mi>X</mi><mi>B</mi></msup><mo>=</mo><msup><mi>X</mi><mrow><mi>A</mi><mo>+</mo><mi>B</mi></mrow></msup></mrow><annotation encoding="application/x-tex">X^A*X^B = X^{A+B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mbin mtight">+</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mrow><mo fence="true">(</mo><msup><mi>X</mi><mi>A</mi></msup><mo fence="true">)</mo></mrow><mi>B</mi></msup><mo>=</mo><msup><mi>X</mi><mrow><mi>A</mi><mo>⋅</mo><mi>B</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\left(X^A\right)^B = X^{A \cdot B}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4726em;vertical-align:-0.35em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">A</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1226em;"><span style="top:-3.3442em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mbin mtight">⋅</span><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>下面我们开始上例题：</p><p><strong>接下来解决一道来自杭州电子科技大学OJ上的题目：</strong></p><p>问题描述：</p><p>求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>B</mi></msup></mrow><annotation encoding="application/x-tex">A^B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span></span></span></span> 的最后三位数表示的整数<br>说明：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mi>B</mi></msup></mrow><annotation encoding="application/x-tex">A^B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span></span></span></span></span></span></span></span> 的含义是&quot;A的B次方&quot;</p><p>链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2035">Problem - 2035 (hdu.edu.cn)</a></p><h2 id="初次思考">初次思考</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 普通的求幂函数</span><br><span class="hljs-comment"> * @param base 底数</span><br><span class="hljs-comment"> * @param power  指数</span><br><span class="hljs-comment"> * @return  求幂结果的最后3位数表示的整数</span><br><span class="hljs-comment">**/</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">normalPower</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span>, base, <span class="hljs-type">long</span> <span class="hljs-type">long</span> power)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>; i &lt;= power; i++) &#123;<br>        result = result * base;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result % <span class="hljs-number">1000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码只能首先数目较小的数字，当遇到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>100</mn></msup></mrow><annotation encoding="application/x-tex">2^{100}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">100</span></span></span></span></span></span></span></span></span></span></span></span>时，会因为数据太大而导致内存溢出。</p><p>那如何解决上述问题呢？</p><p><strong>别急，让我们在补充一下数学知识</strong></p><p>“取模”运算的运算法则如下：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mspace width="1em"/><mo stretchy="false">(</mo><mi>a</mi><mo>+</mo><mi>b</mi><mo stretchy="false">)</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo>=</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mo stretchy="false">(</mo><mi>a</mi><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>b</mi><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mspace width="1em"/><mo stretchy="false">(</mo><mi>a</mi><mo>−</mo><mi>b</mi><mo stretchy="false">)</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo>=</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mo stretchy="false">(</mo><mi>a</mi><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo><mo>−</mo><mo stretchy="false">(</mo><mi>b</mi><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mspace width="1em"/><mo stretchy="false">(</mo><mi>a</mi><mo>⋅</mo><mi>b</mi><mo stretchy="false">)</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo>=</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mo stretchy="false">(</mo><mi>a</mi><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mi>b</mi><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi><mo stretchy="false">)</mo><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo><mspace></mspace><mspace width="1em"/><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mi>p</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align} \quad (a + b) \mod p = \big((a \mod p) + (b \mod p)\big) \mod p  \\ \quad (a - b) \mod p = \big((a \mod p) - (b \mod p)\big) \mod p  \\ \quad (a \cdot b) \mod p = \big((a \mod p) \cdot (b \mod p)\big) \mod p \\\end{align}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.53em;vertical-align:-2.015em;"></span><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.515em;"><span style="top:-4.665em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span></span></span><span style="top:-3.155em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span></span></span><span style="top:-1.645em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">b</span><span class="mclose">)</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mclose">)</span><span class="mord"><span class="delimsizing size1">)</span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.015em;"><span></span></span></span></span></span></span></span><span class="tag"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.515em;"><span style="top:-4.515em;"><span class="pstrut" style="height:2.85em;"></span><span class="eqn-num"></span></span><span style="top:-3.005em;"><span class="pstrut" style="height:2.85em;"></span><span class="eqn-num"></span></span><span style="top:-1.495em;"><span class="pstrut" style="height:2.85em;"></span><span class="eqn-num"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.015em;"><span></span></span></span></span></span></span></span></span></p><p>在这里我们只需要注意第三条</p><p>因此，我们可以借助这个法则，在循环乘积的每一步都提前进行“取模”运算，而不是等到最后对结果直接取模，就能够解决上述问题。</p><p>所以我们将代码修改为这个样子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">normalPower</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span>, base, <span class="hljs-type">long</span> <span class="hljs-type">long</span> power)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= power; i++) &#123;<br>        result = result * base;<br>        result = result % <span class="hljs-number">1000</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result % <span class="hljs-number">1000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>诶这次代码就可以解决当数据太大溢出的问题了</p><p><strong>输出结果：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-number">2100</span><br><span class="hljs-attribute">base</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> power <span class="hljs-operator">=</span> <span class="hljs-number">100376</span><br></code></pre></td></tr></table></figure><h2 id="再次思考（-如何优化代码？）">再次思考（ 如何优化代码？）</h2><p>对于上述代码，当数据很大时，循环的次数随着数据的增大而线性增长，以至于上述算法的时间复杂O(N)太长，当遇到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>1000000</mn></msup></mrow><annotation encoding="application/x-tex">2^{1000000}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1000000</span></span></span></span></span></span></span></span></span></span></span></span>类似的数据时，程序会运行很长时间，下面我们来测试一下代码的运行速率。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br> <br>using namespace <span class="hljs-built_in">std</span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 普通的求幂函数</span><br><span class="hljs-comment"> * @param base 底数</span><br><span class="hljs-comment"> * @param power  指数</span><br><span class="hljs-comment"> * @return  求幂结果的最后3位数表示的整数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">normalPower</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> base, <span class="hljs-type">long</span> <span class="hljs-type">long</span> power)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= power; i++) &#123;<br>        result = result * base;<br>        result = result % <span class="hljs-number">1000</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result % <span class="hljs-number">1000</span>;<br>&#125;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">clock_t</span> start, finish;<br>    <span class="hljs-comment">//clock_t为CPU时钟计时单元数</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> base, power;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; base &gt;&gt; power;<br>    start = clock();<br>    <span class="hljs-comment">//clock()函数返回此时CPU时钟计时单元数</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; normalPower(base, power) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    finish = clock();<br>    <span class="hljs-comment">//clock()函数返回此时CPU时钟计时单元数</span><br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;the time cost is&quot;</span> &lt;&lt; <span class="hljs-type">double</span>(finish - start) / CLOCKS_PER_SEC;<br>    <span class="hljs-comment">//finish与start的差值即为程序运行花费的CPU时钟单元数量，再除每秒CPU有多少个时钟单元，即为程序耗时</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果：</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">2</span> <span class="hljs-number">1000000000</span><br><span class="hljs-number">376</span><br>the time cost is <span class="hljs-number">17.61</span><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>竟然要了17.61秒！！！！</strong></p><p>为了优化算法，提高算法效率，我们引出了——<strong>快速幂算法</strong></p><h2 id="快速幂算法初入门：">快速幂算法初入门：</h2><p>快速幂算法能帮我们算出指数非常大的幂，传统的求幂算法之所以时间复杂度非常高（为O(指数n)），就是因为当指数n非常大的时候，需要执行的循环操作次数也非常大。所以我们快速幂算法的核心思想就是<strong>每一步都把指数分成两半，而相应的底数做平方运算</strong>。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。让我们先来看一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">3</span>^<span class="hljs-number">10</span>=<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span>*<span class="hljs-number">3</span><br><br><span class="hljs-comment">//尽量想办法把指数变小来，这里的指数为10</span><br><br><span class="hljs-number">3</span>^<span class="hljs-number">10</span>=(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>)*(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>)*(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>)*(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>)*(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>)<br><br><span class="hljs-number">3</span>^<span class="hljs-number">10</span>=(<span class="hljs-number">3</span>*<span class="hljs-number">3</span>)^<span class="hljs-number">5</span><br><br><span class="hljs-number">3</span>^<span class="hljs-number">10</span>=<span class="hljs-number">9</span>^<span class="hljs-number">5</span><br><br><span class="hljs-comment">//此时指数由10缩减一半变成了5，而底数变成了原来的平方，求3^10原本需要执行10次循环操作，求9^5却只需要执行5次循环操作，但是3^10却等于9^5,我们用一次（底数做平方操作）的操作减少了原本一半的循环量，特别是在幂特别大的时候效果非常好，例如2^10000=4^5000,底数只是做了一个小小的平方操作，而指数就从10000变成了5000，减少了5000次的循环操作。</span><br><br><span class="hljs-comment">//现在我们的问题是如何把指数5变成原来的一半，5是一个奇数，5的一半是2.5，但是我们知道，指数不能为小数，因此我们不能这么简单粗暴的直接执行5/2，然而，这里还有另一种方法能表示9^5</span><br><br><span class="hljs-number">9</span>^<span class="hljs-number">5</span>=（<span class="hljs-number">9</span>^<span class="hljs-number">4</span>）*（<span class="hljs-number">9</span>^<span class="hljs-number">1</span>）<br><br><span class="hljs-comment">//此时我们抽出了一个底数的一次方，这里即为9^1，这个9^1我们先单独移出来,剩下的9^4又能够在执行“缩指数”操作了，把指数缩小一半，底数执行平方操作</span><br><br><span class="hljs-number">9</span>^<span class="hljs-number">5</span>=（<span class="hljs-number">81</span>^<span class="hljs-number">2</span>）*(<span class="hljs-number">9</span>^<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">//把指数缩小一半，底数执行平方操作</span><br><br><span class="hljs-number">9</span>^<span class="hljs-number">5</span>=（<span class="hljs-number">6561</span>^<span class="hljs-number">1</span>）*(<span class="hljs-number">9</span>^<span class="hljs-number">1</span>)<br><br><span class="hljs-comment">//此时，我们发现指数又变成了一个奇数1，按照上面对指数为奇数的操作方法，应该抽出了一个底数的一次方，这里即为6561^1，这个6561^1我们先单独移出来，但是此时指数却变成了0，也就意味着我们无法再进行“缩指数”操作了。</span><br><br><span class="hljs-number">9</span>^<span class="hljs-number">5</span>=（<span class="hljs-number">6561</span>^<span class="hljs-number">0</span>）*(<span class="hljs-number">9</span>^<span class="hljs-number">1</span>)*(<span class="hljs-number">6561</span>^<span class="hljs-number">1</span>)=<span class="hljs-number">1</span>*(<span class="hljs-number">9</span>^<span class="hljs-number">1</span>)*(<span class="hljs-number">6561</span>^<span class="hljs-number">1</span>)=(<span class="hljs-number">9</span>^<span class="hljs-number">1</span>)*(<span class="hljs-number">6561</span>^<span class="hljs-number">1</span>)=<span class="hljs-number">9</span>*<span class="hljs-number">6561</span>=<span class="hljs-number">59049</span><br><br>我们能够发现，最后的结果是<span class="hljs-number">9</span>*<span class="hljs-number">6561</span>，而<span class="hljs-number">9</span>是怎么产生的？是不是当指数为奇数<span class="hljs-number">5</span>时，此时底数为<span class="hljs-number">9</span>。那<span class="hljs-number">6561</span>又是怎么产生的呢？是不是当指数为奇数<span class="hljs-number">1</span>时，此时的底数为<span class="hljs-number">6561</span>。所以我们能发现一个规律：最后求出的幂结果实际上就是在变化过程中所有当指数为奇数时底数的乘积。<br></code></pre></td></tr></table></figure><h3 id="1-初步优化：">1. 初步优化：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">normalPower</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> base, <span class="hljs-type">long</span> <span class="hljs-type">long</span> power)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(power &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span>(power % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//如果指数为偶数</span><br>            power = power / <span class="hljs-number">2</span>; <span class="hljs-comment">//让指数减半</span><br>            base = base * base % <span class="hljs-number">1000</span>; <span class="hljs-comment">// 底数变大为原来的平方</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//若指数为奇数</span><br>            power --; <span class="hljs-comment">// 让指数减一变为偶数</span><br>            power = power / <span class="hljs-number">2</span>; <span class="hljs-comment">// 执行上述操作</span><br>            result = result * base % <span class="hljs-number">1000</span>; <span class="hljs-comment">// 不要忘记记录单独分离出来的底数</span><br>            base = base * base % <span class="hljs-number">1000</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure><p>神奇的事情发生了：</p><p>输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">2</span> <span class="hljs-number">1000000000</span><br><span class="hljs-number">376</span><br>the time cost is <span class="hljs-number">0.002</span><br>Processfinished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>竟然只花了0.002秒就求出了结果，而且结果也是正确的！</p><h3 id="2-进阶优化">2. 进阶优化</h3><p>虽然上述代码效率已经很高了，但是我们能对其再次进行压榨。</p><p>我们看到上述代码其实是有重复部分的，比如这里：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">power</span> <span class="hljs-operator">=</span> power / <span class="hljs-number">2</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">base</span> <span class="hljs-operator">=</span> base * base % <span class="hljs-number">1000</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>和这里</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">power</span> <span class="hljs-operator">=</span> power - <span class="hljs-number">1</span><span class="hljs-comment">;</span><br><span class="hljs-attribute">power</span> <span class="hljs-operator">=</span> power / <span class="hljs-number">2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>可以压缩成一句话</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">power</span> <span class="hljs-operator">=</span> power / <span class="hljs-number">2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>因为power是一个整数 power / 2 后还是一个整数，遵循的法则是向下取整，例如：5 / 2 = 2 。因此我们可以吧代码压缩成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">fastPower</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> base, <span class="hljs-type">long</span> <span class="hljs-type">long</span> power)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(power &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span>(power % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            result = result * base % <span class="hljs-number">1000</span>;<br>        &#125;<br>        power = power / <span class="hljs-number">2</span>;<br>        base = base * base % <span class="hljs-number">1000</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>依旧是测试性能时间：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">2</span> <span class="hljs-number">1000000000</span><br><span class="hljs-number">376</span><br>the time cost is <span class="hljs-number">0.001</span><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>惊喜吧 又减少了0.001s awa！</p><h3 id="3-终极优化">3. 终极优化</h3><p>在C语言中，power % 2 ==  1可以用更快的“<strong>位运算</strong>”来代替。</p><p>例如：power &amp; 1</p><p>因为如果power为偶数，则其二进制表示的最后一位一定是0</p><p>如果power是奇数，则其二进制表示的最后一位一定是1。</p><p>将他们分别与 1 的二进制做“与”运算，得到的就是power二进制最后一位的数字了。</p><p>结果是 0 则为偶数，是 1 则为奇数。</p><p>例如5是奇数，则 5 &amp; 1 = 1；而 6 是偶数，则 6 &amp; 1 = 0；因此奇偶数的判断就可以用“位运算”来替换了。</p><p><strong>下面是图解：</strong></p><p><img src="/img/OJ/Qcounting.png" alt="快速幂"></p><p>同样，对于power = power / 2 来说，也可以用更快的“位运算”进行替代，我们只要把power的二进制表示向右移动1位（相当于原数除以2）就能变成原来的一半了。</p><p>因此代码修改为下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">fastPower</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> base, <span class="hljs-type">long</span> <span class="hljs-type">long</span> power)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(power &gt; <span class="hljs-number">0</span>) &#123; <br>        <span class="hljs-keyword">if</span>(power &amp; <span class="hljs-number">1</span>) &#123;<br>            result = result * base % <span class="hljs-number">1000</span>;<br>        &#125;<br>        power &gt;&gt;= <span class="hljs-number">1</span>;<br>        base = (base * base) % <span class="hljs-number">1000</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">2</span> <span class="hljs-number">1000000000</span><br><span class="hljs-number">376</span><br>the timee cost is <span class="hljs-number">0</span><br>Process ffinished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>简直可怕，时间花费竟然接近于0秒！！</strong></p><p><strong>想象一下，如果同样两家公司，采用不同的算法，给用户带来的体验区别将是质的改变！</strong></p><p><strong>这就是算法的魅力！</strong></p><h2 id="参考文献">参考文献</h2><ul><li><p><a href="https://blog.csdn.net/m0_52072919/article/details/116400820">https://blog.csdn.net/m0_52072919/article/details/116400820</a></p></li><li><p><a href="https://oi-wiki.org/math/binary-exponentiation/">https://oi-wiki.org/math/binary-exponentiation/</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷】P3916 —— 反向建边 + dfs</title>
    <link href="/2025/01/11/OJ/TraverseGraph/"/>
    <url>/2025/01/11/OJ/TraverseGraph/</url>
    
    <content type="html"><![CDATA[<h1>图的遍历(反向建边+dfs)</h1><p><a href="https://www.luogu.com.cn/problem/P3916">https://www.luogu.com.cn/problem/P3916</a></p><p>按题目来每次考虑每个点可以到达点编号最大的点，不如考虑较大的点可以反向到达哪些点</p><p>循环从N到1，则每个点i能访问到的结点的A值都是i</p><p>每个点访问一次，这个A值就是最优的，因为之后如果再访问到这个结点那么答案肯定没当前大了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXL 100010</span><br><br><span class="hljs-type">int</span> N, M, A[MAXL];<br>vector&lt;<span class="hljs-type">int</span>&gt; G[MAXL]; <span class="hljs-comment">//vector存图 </span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> d)</span> </span>&#123;<br><span class="hljs-keyword">if</span>(A[x]) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//访问过 </span><br>A[x] = d;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;G[x].<span class="hljs-built_in">size</span>(); i++)<br><span class="hljs-built_in">dfs</span>(G[x][i], d);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> u, v;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;N, &amp;M);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=M; i++) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);<br>G[v].<span class="hljs-built_in">push_back</span>(u); <span class="hljs-comment">//反向建边 </span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=N; i; i--) <span class="hljs-built_in">dfs</span>(i, i); <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;=N; i++) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, A[i]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OJ</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机视觉】多目标追踪——匈牙利算法与KM算法</title>
    <link href="/2025/01/10/DeepLearning/Hungarian/"/>
    <url>/2025/01/10/DeepLearning/Hungarian/</url>
    
    <content type="html"><![CDATA[<h1>多目标追踪——匈牙利算法与KM算法</h1><h2 id="一、基本概念">一、基本概念</h2><ul><li><strong>匈牙利算法</strong>（Hungarian Algorithm）是一种用于解决 <strong>二分图最大匹配</strong> 或 <strong>最小权重匹配</strong> 问题的算法，常用于优化分配问题。该算法的核心目标是通过优化一个矩阵的方式，找到最优的匹配方案，最常见的应用是任务分配问题，比如将n个任务分配给n个人，使得任务的总成本最小或总效益最大。</li><li>此算法之所以被称作匈牙利算法，是因为算法很大一部分是基于以前匈牙利数学家 Dénes Kőnig 和 Jenő Egerváry 的工作之上创建起来的。</li><li>匈牙利算法有很多的用途，但在本文中，我们主要讨论匈牙利算法在目标追踪中的作用。</li></ul><ol><li><p><strong>二分图</strong></p><ul><li><p>二分图是一种特殊的图，它的节点可以分成两个互不重叠的集合，使得图中每条边都连接这两个集合中的节点。换句话说，二分图的所有边都跨越这两个集合，图中的每一条边都连接一个集合中的节点与另一个集合中的节点。</p><p>以下是一个典型的二分图</p></li></ul><p><img src="/img/DeepLearning/Hungarian/bcad61ec6ee23b6fd1175da36b086bc.png" alt="图1"></p></li><li><p>匹配</p><ul><li><strong>匹配（Matching）</strong> 是图论中的一个基本概念，指的是在图中选择一组边，使得每条边的两个端点都不相同（即不重复）。具体来说，匹配问题要求选择一些边，使得这些边没有共享的顶点。</li></ul><p><img src="/img/DeepLearning/Hungarian/image-20250110171824278.png" alt="图2"></p><ul><li>如果存在一组边，使得图中的大部分节点都与其他节点有匹配关系（而不是全部），称为 <strong>近似匹配（Near Perfect Matching）</strong> 或 <strong>最大匹配（Maximum Matching）</strong>。</li></ul></li></ol><p>因此，匈牙利算法适用于求解 <strong>二分图的最大匹配</strong> 或 <strong>最小权重匹配</strong> 问题，时间复杂度通常为O (n3)</p><h2 id="二、匈牙利算法">二、匈牙利算法</h2><h3 id="为什么需要匈牙利算法？">为什么需要匈牙利算法？</h3><p>在目标跟踪中，随着时间的推移，物体的位置会不断变化，特别是在动态环境下，物体可能会发生遮挡、交叉、或快速移动。因此，我们不仅需要对物体进行准确的检测，还需要在不同的帧之间保持对同一物体的追踪，以确保物体在整个视频序列中始终保持相同的ID。这是目标跟踪中的 <strong>数据关联问题</strong>，也就是在每一帧中，如何将当前帧检测到的目标与上一帧的目标进行匹配，保持物体的身份一致性。</p><p>为了实现这一点，我们通常使用 <strong>匈牙利算法</strong> 来解决这个匹配问题。</p><h3 id="Example">Example</h3><p>我们来用一个实际的例子说明匈牙利算法的步骤：</p><p>以下图为例，假设左边的四张图是我们在第N帧检测到的目标（U），右边四张图是我们在第N+1帧检测到的目标（V）。红线连起来的图，是我们的算法认为是同一行人可能性较大的目标。但由于算法并不是绝对理想的，因此并不一定会保证每张图都有一对一的匹配，可能每张图有一对二甚至一对多的情况发生。</p><p><img src="/img/DeepLearning/Hungarian/image-20200227185052525.png" alt="图3"></p><ul><li><p>第一步</p><p>给图片1进行匹配，发现此时与其相连的右1还未匹配，于是将其配对，连上一条蓝线。</p></li></ul><p><img src="/img/DeepLearning/Hungarian/image-20200227185149106.png" alt="图4"></p><ul><li><p>第二步</p><p>接着匹配左2，发现此时与其相连的右二还未匹配，于是将其配对，连上一条蓝线。</p></li></ul><p><img src="/img/DeepLearning/Hungarian/image-20200227185228250.png" alt="图5"></p><ul><li><p>第三步</p><p>接着匹配 左3 ，我们发现，左3 与其相连接的 右1 和 右2 都已经预先被匹配完毕了。</p><p>但为了完成 左3 的匹配任务，我们想到可以给之前 右1 的匹配的对象—— 左1，重新分配一个新的对象 ——即与 左1 相连的另一张图 右2。</p><p>但我们又发现，右2 也已经被匹配出去了。</p><p>于是我们可以用同样的思想，给之前 右2 匹配的对象—— 左2，重新分配一张图——即与左2相连的另一张图 右3。（后面再遇到类似的情况也是同样的操作，这是一个递归的过程）</p><p>此时的匹配结果分别如下：（黄色的线表示临时被拆除的线）</p><p><img src="/img/DeepLearning/Hungarian/image-20250110174112528.png" alt="图6"></p><p>这时，问题就迎刃而解了，左3完美匹配上了右1！</p><p><img src="/img/DeepLearning/Hungarian/image-20200227185430170.png" alt="图7"></p></li><li><p>第四步：</p><p>最后匹配左4，很遗憾，按照第三步无法给左4腾出来一个匹配对象，无奈放弃。匈牙利算法至此结束。</p></li></ul><p>可以看到，由于在候选匹配中包含了许多错误的匹配红线，所以按照算法流程下来匹配准确率并不高。可见匈牙利算法预先红线连接的准确率依赖度较高，也就是说要求我们事先必须要进行一个精准的预测，比如设定一个阈值（置信度），把较高置信度的边送入匈牙利算法进行匹配，才能够得到更好的结果。</p><p><strong>为了更好的解决上述问题，我们可以采取KM算法</strong></p><h2 id="三、KM算法">三、KM算法</h2><p>KM算法的应用背景可以是一个 <strong>带权二分图</strong>，其中每一条边都有一个代价。目标是找到一个最优匹配，使得所选边的总代价最小。</p><h3 id="算法步骤">算法步骤</h3><ol><li><p>首先对每个顶点赋值，将左边的顶点赋值为最大权重，右边的顶点赋值为0。</p><p>如图，我们将左1赋值为其两边中较大的0.8。</p><p><img src="/img/DeepLearning/Hungarian/image-20200227185713197.png" alt="图8"></p></li><li><p>进行匹配。</p><p>匹配的原则是：<strong>只与权重相同的边进行匹配</strong>。</p><p>若找不到匹配的边，则对此条路径的所有左图权重-0.1，右图权重+0.1。（加减的值不唯一，视情况而定）</p><p>例如对左1进行匹配，符合匹配条件的只有：左1 —— 右1</p><p><img src="/img/DeepLearning/Hungarian/image-20200227185802547.png" alt="图9"></p><p>同理：接下来对左2进行匹配。</p><p><img src="/img/DeepLearning/Hungarian/image-20200227185829028.png" alt="图10"></p><p>然后是左3，注意此时左3想匹配的对象（右1）已经被左1匹配了，而左1又无法重新匹配一个新的对象（因为开始匹配的边权最大）。那应该怎么办呢？</p><p>我们不妨可以用给员工分配工作的角度思考：其实我们寻找<strong>最优匹配</strong>的过程，也就是<strong>帮每个员工找到他们工作效率最高的工作</strong>，但有些工作会冲突，员工A和员工B对工作C的工作效率都是最高的，这是我们应该让A或者B换一份工作，但如果真这么做了，那么我们只能换到<strong>降低总体效率值的工作</strong>。</p><p>但我们现在只要求最优匹配，所以<strong>如果员工A换一份工作效率稍微低一些的工作的话，我们是可以接受的（对员工B也是如此）</strong></p><p><img src="/img/DeepLearning/Hungarian/image-20250110185620992.png" alt="图11"></p><p>那么在KM算法中的体现就是：<strong>对所有冲突的边的顶点做加减操作</strong>，令左边顶点值减0.1，右边顶点值加0.1。结果如下图所示。</p><p><img src="/img/DeepLearning/Hungarian/image-20200227185854835.png" alt="图12"></p><p>经过此操作后，再重新进行匹配操作。</p><p>恭喜！左3多了一条可匹配的边，因为此时左3对右2的匹配要求只需权重大于等于0.8+0即可，所以左3与右2匹配成功！</p><p><img src="/img/DeepLearning/Hungarian/image-20200227185923170.png" alt="图13"></p><p>最后进行左4的匹配。由于左4唯一的匹配对象右3已被左2匹配，发生冲突。进行一轮加减操作重新匹配后发现左四还是匹配失败。再经过两轮以后左4期望值降为0，放弃匹配。</p><p>至此KM算法结束。成功匹配三对，可以发现采用KM算法的匹配结果比之前采用匈牙利算法匹配的结果更加精准可靠。</p></li></ol><h2 id="四、代码实现">四、代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将yolo模型的检测框和卡尔曼滤波的跟踪框进行匹配</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">associate_detections_to_trackers</span>(<span class="hljs-params">detections, trackers, iou_threshold = <span class="hljs-number">0.3</span></span>):<br>    <span class="hljs-comment"># 检测框数</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(trackers) == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> np.empty((<span class="hljs-number">0</span>, <span class="hljs-number">2</span>), dtype = <span class="hljs-built_in">int</span>), np.arange(<span class="hljs-built_in">len</span>(detections)), np.empty((<span class="hljs-number">0</span>, <span class="hljs-number">5</span>), dtype = <span class="hljs-built_in">int</span>)<br>    <span class="hljs-comment"># 跟踪框数</span><br>    iou_matrix = np.zeros((<span class="hljs-built_in">len</span>(detections), <span class="hljs-built_in">len</span>(trackers)), dtype = np.float32)<br>    <span class="hljs-comment"># 计算检测框和跟踪框之间的IOU</span><br>    <span class="hljs-keyword">for</span> d, det <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(detections):<br>        <span class="hljs-keyword">for</span> t, trk <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(trackers):<br>            iou_matrix[d, t] = IOU(det, trk)<br>    <span class="hljs-comment"># 匈牙利算法进行匹配</span><br>    matched_indices = linear_sum_assignment(-iou_matrix)<br>    <span class="hljs-comment"># 未匹配的检测框</span><br>    unmatched_detections = []<br>    <span class="hljs-keyword">for</span> d, det <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(detections):<br>        <span class="hljs-keyword">if</span> d <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> matched_indices[<span class="hljs-number">0</span>]:<br>            unmatched_detections.append(d)<br>    <span class="hljs-comment"># 未匹配的跟踪框</span><br>    unmatched_trackers = []<br>    <span class="hljs-keyword">for</span> t, trk <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(trackers):<br>        <span class="hljs-keyword">if</span> t <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> matched_indices[<span class="hljs-number">1</span>]:<br>            unmatched_trackers.append(t)<br>    <span class="hljs-comment"># 未匹配的跟踪框</span><br>    matches = []<br>    <span class="hljs-keyword">for</span> d, t <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(matched_indices[<span class="hljs-number">0</span>], matched_indices[<span class="hljs-number">1</span>]):<br>        <span class="hljs-keyword">if</span> iou_matrix[d, t] &lt; iou_threshold:<br>            unmatched_detections.append(d)<br>            unmatched_trackers.append(t)<br>        <span class="hljs-keyword">else</span>:<br>            matches.append((d, t))<br>    <span class="hljs-comment"># 返回匹配结果</span><br>    <span class="hljs-keyword">return</span> np.array(matches), np.array(unmatched_detections), np.array(unmatched_trackers)<br></code></pre></td></tr></table></figure><h2 id="参考文献">参考文献</h2><ul><li><a href="https://www.cnblogs.com/ariel-dreamland/p/13522590.html">https://www.cnblogs.com/ariel-dreamland/p/13522590.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/459758723">https://zhuanlan.zhihu.com/p/459758723</a></li><li><a href="https://zhuanlan.zhihu.com/p/62981901">https://zhuanlan.zhihu.com/p/62981901</a></li><li><a href="https://blog.csdn.net/lemonxiaoxiao/article/details/108704280">https://blog.csdn.net/lemonxiaoxiao/article/details/108704280</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>DeepLearning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepLearning</tag>
      
      <tag>OpenCV</tag>
      
      <tag>目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【SEO方向】Google抓取网页流程和搜索算法</title>
    <link href="/2025/01/09/SEO/GoogleSearch/"/>
    <url>/2025/01/09/SEO/GoogleSearch/</url>
    
    <content type="html"><![CDATA[<h1>2. Google抓取网页流程和搜索算法</h1><h2 id="一、Google-搜索的基本流程">一、Google 搜索的基本流程</h2><p>从视频中可以看到Google抓取和输出一个网页在搜索结果的流程大概是：</p><ol><li>用户在 Google 搜索框中输入关键词或查询短语，发起搜索请求。</li><li>Google 的搜索引擎蜘蛛（Googlebot）会遍历互联网上的网页，收集它们的内容（<strong>抓取</strong>）并加入到Google的索引库中（<strong>索引</strong>）。</li><li>当用户发起查询时，Google 会根据多个排名因素（如页面内容、关键词相关性、网站质量等）对索引中的网页进行排序。Google 会使用算法评估哪个页面最符合用户查询的需求，在自己的索引库中找到合适的网页展示给用户</li></ol><p><img src="/img/SEO/image-20250109203925071.png" alt=""></p><p>想要Google发现你的网站并且加入索引，我们可以通过：</p><ul><li><p>提交<strong>站点地图（Sitemap）</strong>—— 一个包含你网站所有重要页面的文件，可以帮助搜索引擎更容易地发现并抓取你的内容。</p></li><li><p>通过 <strong>Google Search Console</strong> 提交网站地图 —— 确保 Googlebot 能更快地抓取和索引你的页面。</p></li></ul><p>以上两种方式来告诉Google你的网站链接。</p><p>Google为你网页计算内容排名的时候，就会考虑你页面的标题、描述、url或者内容等地方是否会出现对应的关键词，或者关键词的近义词。</p><p><img src="/img/SEO/image-20250109204435550.png" alt=""></p><h2 id="二、Google搜索排名算法">二、Google搜索排名算法</h2><p>假如你的网站允许被Google抓取，那么Google机器人就会把你的网站内容收录到索引库中，但索引库中必然会有千亿级别的网页。Google搜索排名算法就是对这些索引进行整理和排序，以最快的速度把用户所需要的内容呈现出来。</p><p><strong>Google的排名系统由多个算法共同运作，而不是单一的算法。为了提供最相关的信息，Google的搜索算法会综合考虑多种因素，包括查询的关键词、网页的相关性和可用性、信息来源的权威性，以及用户的位置和个人设置。每个因素的权重会根据查询的不同而有所变化。例如，对于查询字典定义类的信息，网页的相关性更为重要；而在查询时事新闻时，内容的新鲜度则会被赋予更高的权重。</strong></p><h3 id="1-分析关键词">1. 分析关键词</h3><p>Google有一套完整的语言模型，会根据你输入的关键词进行一系列的分析。</p><p>例如：</p><ul><li>搜索“如何换灯泡” —— 这里“换”的意思是“替换”</li><li>搜索“如何换货币” —— 这里“换”的意思是“兑换”</li></ul><h3 id="2-挑选与搜索内容相符合的页面">2. 挑选与搜索内容相符合的页面</h3><p>当Google了解你的搜索意图后，Google会从自己的索引库中寻找与查询信息相匹配的网页。</p><p><img src="/img/SEO/image-20250109205828224.png" alt=""></p><p>也就是说，在搜索时，Google算法会在索引中查询您的搜索关键词以找到合适的网页，算法分析的内容包括但不限于在某个网页上的<strong>关键字或者相关信息</strong>的<strong>出现频率</strong>。</p><p><strong>这也给我们在做SEO时提供了启发</strong>——想要获得某个关键词的排名，那么你的文章标题和内容应该包含一定的关键词，帮助Google算法了解你的网页内容从而推荐给相关用户。但是一定不能为了排名而乱插入关键词。</p><h3 id="3-为网页排名">3. 为网页排名</h3><p><img src="/img/SEO/image-20250109205808224.png" alt=""></p><p>网页排名是搜索引擎根据一系列因素决定特定网页在搜索结果中显示位置的过程。Google 的排名系统基于复杂的算法，通过评估网页的相关性、质量、权威性等来确定排名。</p><p>这个排名过程中，会根据用户在网页的停留时间，PageRank，或者内链接等因素多方面考虑。因此网页的排名是在不断变化当中的。</p><p>Google 对站长提出了基本要求：</p><ul><li>在设计网站时，应该首先关注用户的需求，而不是单纯为了迎合搜索引擎。</li><li>避免做出任何欺骗用户的行为。</li><li>不要采用不正当手段来提升搜索引擎排名。衡量自己做法是否合适的一种方式是，想象自己需要向竞争对手或 Google 的员工解释这些做法时，是否能心安理得。另一个自我测试的方法是，问自己：“这是否能真正为用户提供价值？如果没有搜索引擎的存在，我是否还会这么做？”</li><li>思考怎样才能让自己的网站在行业中独树一帜，具有独特性、价值或者吸引力，从而在同类网站中脱颖而出。</li></ul><h3 id="4-返回最佳结果">4. 返回最佳结果</h3><p>在第三步为网页排名中，Google对索引库的页面有一个基础排名后，并不一定在实际显示出来的结果排名中就一定位于第一名。真正的第一名，Google还会根据一些其他因素来考虑。</p><p><img src="/img/SEO/image-20250109210121782.png" alt=""></p><p>假设用户搜索“如何选择适合的跑步鞋”。</p><p>Google会首先根据关键词匹配和页面相关性对多个网页进行基础排名。然而，如果其中一篇文章刚刚更新，包含了2025年最新款的跑步鞋推荐，而另一篇文章发布于几个月前没有最新信息，那么即使后者在基础排名中较高，Google可能会优先显示更新的页面，因为它提供了更具时效性的内容。</p><p>此外，页面的加载速度和移动端体验也会影响最终排名，哪怕基础排名较低的页面提供了更好的用户体验，Google也可能将其排在前面。</p><h3 id="5-搜索环境和地理位置">5. 搜索环境和地理位置</h3><p>Google 在搜索结果排序时，会根据你的地理位置和个人搜索历史来调整显示内容。</p><p>这意味着，不同国家和地区的用户搜索相同的关键词时，得到的搜索结果可能会有所不同。</p><p><img src="/img/SEO/image-20250109210508669.png" alt=""></p><p>例如，假设你搜索“最佳餐厅”。如果你位于纽约，Google会优先显示你所在城市的餐厅推荐，而不是全球或其他城市的餐厅。即使其他地方的餐厅排名很高，Google会根据你的位置提供更相关的本地搜索结果。此外，如果你过去经常搜索过某些餐厅或餐饮相关的内容，Google可能会根据你的搜索历史推荐你可能感兴趣的餐厅，进一步个性化你的搜索结果。</p><h2 id="参考文献">参考文献</h2><ul><li><a href="https://www.google.com/intl/zh-CN/search/howsearchworks/crawling-indexing/">https://www.google.com/intl/zh-CN/search/howsearchworks/crawling-indexing/</a></li><li><a href="https://www.google.com/intl/zh-CN/search/howsearchworks/algorithms/">https://www.google.com/intl/zh-CN/search/howsearchworks/algorithms/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>SEO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SEO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【小白笔记】Google SEO 初探</title>
    <link href="/2025/01/09/SEO/SeoExplore/"/>
    <url>/2025/01/09/SEO/SeoExplore/</url>
    
    <content type="html"><![CDATA[<h1>1. Google SEO——从搜索引擎优化中获得更多免费流量</h1><h2 id="一、什么是Google-SEO？">一、什么是Google SEO？</h2><p>SEO是搜索引擎优化的缩写，Google SEO就是针对Google的搜索引擎优化。</p><p>是在符合Google优化规则的前提下对网站进行一系列的设置和优化，让网站获得更好的搜索排名，从而获得更多的免费流量。</p><h2 id="二、为什么SEO很重要？">二、为什么SEO很重要？</h2><p>每天都有很多人通过Google搜索找到自己需要的东西，而我们做SEO优化就是为了获得更好的搜索排名，从而让更多潜在用户访问你的网站，进而产生成交，带来收益。</p><h2 id="三、如何做SEO？">三、如何做SEO？</h2><p>Google的建议是你应该搭建一个对用户有用的网站，任何优化都是用于改善用户体验。简单理解就是以用户体验为首位，发布有价值的文章内容，文章的标题和内容部分包含有意义的搜索关键词。</p><p>PS：<a href="https://www.by928.com/guizhou/502.html">外贸网站SEO不是给钱就能成的</a></p><h3 id="第一步：关键词研究">第一步：关键词研究</h3><p><strong>关键词</strong>，英文名叫<strong>Keywords</strong>，简单来说就是你这个网站希望别人通过什么词语搜索到你。</p><p>选取关键词是第一步也是最重要的一步。如果选错了关键词，那么在整个SEO过程中都会走很多的弯路。假如最开始的定位并非做现在的内容，就会导致定位更换几次，如果关键词没定好，内容规划起来就很麻烦。</p><p>很多外贸网站在设置标题时，仅仅使用公司名称，或者干脆不设置标题，这样做不利于SEO优化。除非你是全球知名品牌，否则很少有人会通过你的品牌名来寻找你的网站。为了提升曝光率和流量，你的标题应该<strong>包含与你的产品和服务相关的关键词</strong>。比如，你可以将标题设置为：“XXX – 手机配件批发, 手机壳, 数据线, 手机充电器制造商”。这样，潜在客户在搜索“手机配件”、“手机壳”、“数据线”或“手机充电器制造商”等相关关键词时，就有更高的机会找到你的网站，提升网站的可见性和搜索排名。</p><h3 id="第二步：编写友好内容">第二步：编写友好内容</h3><p>简单来说就是站在用户的角度来写文章，确保内容不仅对搜索引擎有利，更能解决用户的实际问题，提升用户体验。</p><p>例如，香水网站在编写文章时，想着的就是提供香水选购的全面指南，同时也有人搜索“男士香水推荐”、“女士香水品牌”、“香水购买指南”等词汇，因此你看到的这个页面标题叫“香水购买指南_ 男士香水推荐 _女士香水品牌推荐 | 香水之家”。</p><p>满足SEO基本要求：</p><ol><li>内容满足用户需要</li><li>内容有价值</li></ol><p>内容优化还有很多细节要做，例如标题标签优化，Meta描述优化，URL优化，内容优化，内部链接，移动端优化等等可以操作的地方。</p><h3 id="第三步：内部链接优化">第三步：内部链接优化</h3><p><img src="/img/SEO/%E5%86%85%E9%93%BE%E5%9B%BE.png" alt="内链"></p><p>如上图，把网站的文章页面串联起来。</p><p>简单来说，就是那些在文本里可以点击的链接，点进去同样是该网站下的文章或者页面，这就是内链。</p><p>内链建设时要保证顺其自然，不要刻意添加，否则会导致网页结构紊乱，劝退用户的阅读意愿。应该是文章写到那个地方，在合适的地方添加一个对用户有帮助的链接。</p><h3 id="第四步：外部链接建设">第四步：外部链接建设</h3><p>SEO界有一句俗话——“内容为王，外链为皇”，所谓外部链接就是其他网站指向你网站的链接。</p><p>作为商业网站，外联是提高网站可信度和排名的关键因素。</p><p>具体来说有以下几种方式（其实就是蹭流量）：</p><ul><li><p><strong>获得高质量的外部链接</strong>：从相关领域的网站或博客获取高质量的反向链接。</p></li><li><p><strong>客座博客</strong>：写一些与自己业务相关的文章，发布在其他高流量网站或博客上，获得链接。</p></li><li><p><strong>社交媒体</strong>：通过社交媒体渠道吸引流量，提升品牌曝光，并间接影响SEO。</p></li></ul><p>但有一点一定要注意：<strong>不要花钱买低质量外链！</strong></p><h2 id="四、Google-SEO优化工具">四、Google SEO优化工具</h2><p>一些很好用的工具可以来帮助我们更加高效的进行SEO工作，提升可行度。</p><h4 id="Google-Search-Console"><a href="https://developers.google.cn/search/docs/monitor-debug/search-console-start?hl=zh-cn">Google Search Console</a></h4><p>Google Search Console又称谷歌搜索控制台、谷歌管理员工具、谷歌站长工具，是Google官方推出的站点管理工具，<strong>如果Google的搜索蜘蛛发现你网站有任何问题了，就会通知你</strong>。你也可以在上面看到很多网站在Google上面的数据。</p><h4 id="Google-Analytics"><a href="https://developers.google.cn/analytics?hl=zh-cn">Google Analytics</a></h4><p><strong>Google Analytics</strong> 是一款由 Google 提供的免费网页分析工具，<strong>添加到网站后可以告诉你网站每天的流量信息</strong>。</p><p><strong>主要功能：</strong></p><ol><li><strong>访问量分析</strong>：查看网站的访问次数、页面浏览量、访客来源等。</li><li><strong>用户行为追踪</strong>：分析用户在网站上的行为，如浏览的页面、停留时间、跳出率等。</li><li><strong>流量来源</strong>：分析访客是通过搜索引擎、社交媒体、广告还是直接访问来到网站。</li><li><strong>受众分析</strong>：查看访客的地理位置、设备、浏览器等信息，帮助你优化用户体验。</li></ol><p>这些数据可以用来分析网站的用户访问情况，然后进行对应的SEO调整，是很重要的一项工作。</p><p>当然，SEO工具只是辅助，关键还是网站内容和基础的SEO优化。</p>]]></content>
    
    
    <categories>
      
      <category>SEO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SEO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【计算机视觉】目标追踪检测——卡尔曼滤波</title>
    <link href="/2025/01/09/DeepLearning/kalman/"/>
    <url>/2025/01/09/DeepLearning/kalman/</url>
    
    <content type="html"><![CDATA[<h1>卡尔曼滤波——目标追踪检测</h1><p>最近在做毕设时涉及了卡尔曼滤波的学习，以此篇文章来记录我的探索之旅。</p><h2 id="一、背景介绍">一、背景介绍</h2><p>卡尔曼滤波（Kalman）是一种在单目标和多目标检测领域中的常用算法，卡尔曼滤波可以看做一种<strong>运动模型</strong>，用来对目标的位置进行预测，并且利用<strong>预测结果对跟踪的目标进行修正</strong>。它能在存在诸多不确定性情况的组合信息中<strong>估计动态系统的状态</strong>，是一种强大的、通用性极强的工具。</p><p>只要是存在不确定信息的动态系统，卡尔曼滤波(Kalman)就可以对系统下一步要做什么做出有根据的推测。即使有噪声信息干扰，卡尔曼滤波通常也能很好的弄清楚究竟发生了什么，找出现象间不易察觉的相关性。因此卡尔曼滤波(Kalman)非常适合不断变化的系统。</p><p>它的优点还有内存占用较小（只需保留前一个状态）、速度快，是实时问题和嵌入式系统的理想选择。</p><h2 id="二、卡尔曼滤波的原理">二、卡尔曼滤波的原理</h2><p>目标的位置，速度，加速度的测量值往往在任何时候都有噪声。卡尔曼滤波利用目标的动态信息，设法去掉噪声的影响，得到一个关于目标位置的好的估计。这个估计可以实对<strong>当前目标位置</strong>的估计，也可以是对<strong>将来位置</strong>的估计，同时也可以是<strong>对过去位置</strong>的估计。</p><ul><li><strong>场景描述</strong></li></ul><p>我们假设一个简单的场景，有一辆小车在行驶，它的速度是v，可以通过观测得到它的位置p,也就是说我们可以实时的观测小车的状态。</p><p>假设小车在某一时刻的状态可以表示为如下向量：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>x</mi><mo>⃗</mo></mover><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>p</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>v</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">\vec{x} =  \begin{bmatrix} p \\ v \\ \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.714em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.714em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal">x</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2077em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg xmlns="http://www.w3.org/2000/svg" width="0.471em" height="0.714em" style="width:0.471em" viewBox="0 0 471 714" preserveAspectRatio="xMinYMin"><path d="M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z"/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4em;vertical-align:-0.95em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">p</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span></span></span></span></p><p>虽然我们比较确定小车此时的状态，无论是计算还是检测都会存在一定的误差，所以我们只能认为当前状态是其真实状态的一个<strong>最优估计</strong>。那么我们不妨认为当前状态服从一个高斯分布，如下图所示：</p><p><img src="/img/DeepLearning/kalman/image-20250109112459878.png" alt="图1"></p><p>高斯分布的中心 <code>μ</code> 就是图中的 X<sub>k</sub></p><ul><li><p><strong>预测下一时刻的状态</strong></p><p>通过一些物理学知识来预测小车的下一个状态，即通过k-1时刻的位置和速度，可以推测下一个时刻的状态为：</p></li></ul><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>p</mi><mi>k</mi></msub><mo>=</mo><msub><mi>p</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>v</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mi mathvariant="normal">Δ</mi><mi>t</mi><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>a</mi><mi mathvariant="normal">Δ</mi><msup><mi>t</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">p_k = p_{k-1} + v_{k-1}Δt + \frac{1}{2}aΔt^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord">Δ</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathnormal">a</span><span class="mord">Δ</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>v</mi><mi>k</mi></msub><mo>=</mo><msub><mi>v</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>a</mi><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">v_k = v_{k-1} + aΔt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">a</span><span class="mord">Δ</span><span class="mord mathnormal">t</span></span></span></span></span></p><p>​写成矩阵的形式：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msub><mover accent="true"><mi mathvariant="bold">x</mi><mo>^</mo></mover><mi>k</mi></msub></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><msub><mover accent="true"><mi mathvariant="bold">x</mi><mo>^</mo></mover><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mfrac><mrow><mi mathvariant="normal">Δ</mi><msup><mi>t</mi><mn>2</mn></msup></mrow><mn>2</mn></mfrac></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">Δ</mi><mi>t</mi></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mi>a</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi mathvariant="bold">F</mi><mi>k</mi></msub><msub><mover accent="true"><mi mathvariant="bold">x</mi><mo>^</mo></mover><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi mathvariant="bold">B</mi><mi>k</mi></msub><msub><mi mathvariant="bold">u</mi><mi>k</mi></msub></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}\hat{\mathbf{x}}_{k} &amp; =\begin{bmatrix}  1 &amp; Δt\\  0 &amp; 1\end{bmatrix} \hat{\mathbf{x}}_{k-1}+\left[\begin{array}{c}\frac{\Delta t^{2}}{2} \\\Delta t\end{array}\right] a \\&amp; =\mathbf{F}_{k} \hat{\mathbf{x}}_{k-1}+\mathbf{B}_{k} \mathbf{u}_{k}\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.3779em;vertical-align:-1.939em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.439em;"><span style="top:-4.439em;"><span class="pstrut" style="height:3.539em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf">x</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-2.26em;"><span class="pstrut" style="height:3.539em;"></span><span class="mord"></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.939em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.439em;"><span style="top:-4.439em;"><span class="pstrut" style="height:3.539em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Δ</span><span class="mord mathnormal">t</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.95em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf">x</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.539em;"><span style="top:-3.539em;"><span class="pstrut" style="height:3.0179em;"></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0179em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Δ</span><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.339em;"><span class="pstrut" style="height:3.0179em;"></span><span class="mord"><span class="mord">Δ</span><span class="mord mathnormal">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.039em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span></span></span><span style="top:-2.26em;"><span class="pstrut" style="height:3.539em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathbf">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf">x</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.939em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>​F<sub>k</sub> 称为状态转移矩阵，表明如何从当前状态推算到下一个状态</p><p>​B<sub>k</sub> 称为状态控制矩阵，表明加速减速如何改变小车的状态</p><p>​u<sub>k</sub> 称为状态控制向量，表明控制的力度大小和方向</p><ul><li><p><strong>考虑系统外部影响</strong></p><p>由于外界有很多因素（比如风速，障碍物等）会对小车的状态产生影响。假设外部的不确定性因素对小车造成的系统状态误差服从高斯分布 <strong>w<sub>k</sub> ~ N(0, Q<sub>k</sub>)</strong>，我们就可以得到卡尔曼滤波中完整的状态预测方程：</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mover accent="true"><mi mathvariant="bold">x</mi><mo>^</mo></mover><mi>k</mi></msub><mo>=</mo><msub><mi mathvariant="bold">F</mi><mi>k</mi></msub><msub><mover accent="true"><mi mathvariant="bold">x</mi><mo>^</mo></mover><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi mathvariant="bold">B</mi><mi>k</mi></msub><msub><mi mathvariant="bold">u</mi><mi>k</mi></msub></mrow></mstyle></mtd></mtr></mtable><mo>+</mo><msub><mi>w</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">\begin{aligned}\hat{\mathbf{x}}_{k}=\mathbf{F}_{k} \hat{\mathbf{x}}_{k-1}+\mathbf{B}_{k} \mathbf{u}_{k}\end{aligned} + w_k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5em;vertical-align:-0.5em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf">x</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathbf">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7079em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf">x</span></span><span style="top:-3.0134em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2222em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathbf">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mover accent="true"><mi mathvariant="bold">P</mi><mo>^</mo></mover><mi>k</mi></msub><mo>=</mo><msub><mi mathvariant="bold">F</mi><mi>k</mi></msub><msub><mi mathvariant="bold">P</mi><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msub><msubsup><mi mathvariant="bold">F</mi><mi>k</mi><mi>T</mi></msubsup><mo>+</mo><msub><mi mathvariant="bold">Q</mi><mi>k</mi></msub></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}\hat{\mathbf{P}}_{k}=\mathbf{F}_{k} {\mathbf{P}}_{k-1} {\mathbf{F}}^T_{k}+\mathbf{Q}_{k}\end{aligned} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6096em;vertical-align:-0.5548em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0548em;"><span style="top:-3.1052em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9495em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathbf">P</span></span><span style="top:-3.2551em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.1667em;"><span class="mord">^</span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord"><span class="mord mathbf">F</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">P</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mord mathbf">F</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-2.453em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5548em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>一般情况下，假设 w<sub>k</sub> 为 0。</p></li><li><p><strong>基于观测值进行最优估计</strong></p><p>在上述中，我们可以通过小车的上一个状态，对当前状态做出预测；但与此同时，我们也需要考虑小车的观测状态。</p><p>例如下图中，x<sub>k-1</sub>是小车前一个时刻的估计值，服从高斯分布，其中方差（variance）可以作为不确定性。</p><p><img src="/img/DeepLearning/kalman/image-20250109120834141.png" alt="图2"></p><p>x<sub>k</sub>是<strong>下一个时刻的估计</strong>，可以看到——分布变“胖”了。显然下一个时刻的估计相比于前一个时刻的估计会更加的不准确（因为上一时刻本身就是估计值，根据估计值估计下一时刻，相当于在递推的过程中又加了一层噪声，显然误差会越来越大）。</p><p>y<sub>k</sub>是一个<strong>观测值</strong>，是传感器定位的结果，但传感器对小车距离的测量也会受到种种因素的影响，所以这个结果同样不准确。</p><p>现在，我们知道了下一个时刻的估计结果，也知道了传感器返回的观测值结果。那么问题就来了，到底应该相信谁？</p><p>科学家们做出了一个解释，<strong>用x<sub>k</sub>分布乘上y<sub>k</sub>的分布，会得到一个更加精确的位置的分布</strong>（实际上这就是卡尔曼滤波器需要做的事情）</p></li></ul><p><img src="/img/DeepLearning/kalman/image-20250109122741224.png" alt="图3"></p><p>可以看到，新的分布不仅保证了在给定的蓝色和红色条件下，小车位于该点的概率最大。并且还是一个正态分布，这意味着可以把它当做初值继续往下算了！这就是Kalman滤波能够<strong>迭代</strong>的关键！</p><p>接下来，把灰色分布当做第一张图中的蓝色分布对k+1时刻进行预测，算法就可以开始循环往复了</p><ul><li><p><strong>实际中的计算方法</strong></p><p>在实际使用卡尔曼滤波的时候，计算的步骤一般为：</p><ol><li><p>预测阶段：使用模型来预测下一个时间点的状态和协方差</p><p><strong>a. 通过状态转移矩阵和控制输入预测下一个时间步的状态。</strong></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi mathvariant="bold">x</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi mathvariant="bold">F</mi><mo>⋅</mo><mi mathvariant="bold">x</mi><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi mathvariant="bold">B</mi><mo>⋅</mo><mi mathvariant="bold">u</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}\mathbf{x} &amp;= (\mathbf{F} \cdot \mathbf{x}) + (\mathbf{B} \cdot \mathbf{u}) \\\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5em;vertical-align:-0.5em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord mathbf">F</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathbf">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">u</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><p><code>x</code> 是当前的状态向量（位置、速度等）。</p></li><li><p><code>F</code> 是状态转移矩阵，它描述了如何从当前状态推算到下一个状态。</p></li><li><p><code>Bu</code> 是控制输入项，其中 <code>B</code> 是控制输入矩阵，<code>u</code> 是控制输入向量。例如，在某些应用中，控制输入可能是加速度、外部力等。</p></li></ul><p><strong>b. 通过状态转移矩阵和过程噪声来预测下一个时间步的协方差。</strong></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi mathvariant="bold">P</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">(</mo><mi mathvariant="bold">F</mi><mo>⋅</mo><mi mathvariant="bold">P</mi><mo>⋅</mo><msup><mi mathvariant="bold">F</mi><mi mathvariant="normal">⊤</mi></msup><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="bold">Q</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}\mathbf{P} &amp;= (\mathbf{F} \cdot \mathbf{P} \cdot \mathbf{F}^\top) + \mathbf{Q}\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5591em;vertical-align:-0.5296em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0296em;"><span style="top:-3.1304em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5296em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0296em;"><span style="top:-3.1304em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mopen">(</span><span class="mord mathbf">F</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">P</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">F</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">Q</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5296em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><p><code>P</code> 是协方差矩阵，表示状态的不确定性。</p></li><li><p><code>F</code> 是状态转移矩阵，<code>P</code> 是当前的协方差矩阵。</p></li><li><p><code>Q</code> 是过程噪声协方差矩阵，表示系统本身的模型误差或噪声。</p></li></ul></li><li><p>更新阶段：通过新的测量值来调整预测的状态。</p><p><strong>a. 通过卡尔曼增益公式计算增益 <code>K</code>，它决定了如何将预测结果和测量值结合。</strong></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi mathvariant="bold">K</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi mathvariant="bold">P</mi><mo>⋅</mo><msup><mi mathvariant="bold">H</mi><mi mathvariant="normal">⊤</mi></msup><mo>⋅</mo><msup><mrow><mo fence="true">(</mo><mrow><mo fence="true">(</mo><mi mathvariant="bold">H</mi><mo>⋅</mo><mi mathvariant="bold">P</mi><mo>⋅</mo><msup><mi mathvariant="bold">H</mi><mi mathvariant="normal">⊤</mi></msup><mo fence="true">)</mo></mrow><mo>+</mo><mi mathvariant="bold">R</mi><mo fence="true">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}\mathbf{K} &amp;= \mathbf{P} \cdot \mathbf{H}^\top \cdot \left( \left( \mathbf{H} \cdot \mathbf{P} \cdot \mathbf{H}^\top \right) + \mathbf{R} \right)^{-1} \\\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.7631em;vertical-align:-0.6316em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1316em;"><span style="top:-3.1316em;"><span class="pstrut" style="height:3.1031em;"></span><span class="mord"><span class="mord mathbf">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6316em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1316em;"><span style="top:-3.1316em;"><span class="pstrut" style="height:3.1031em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathbf">P</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mord mathbf">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">P</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathbf">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">⊤</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">R</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.1031em;"><span style="top:-3.352em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6316em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><p><code>K</code>是 <strong>卡尔曼增益</strong>，它表示我们对新测量值的信任程度。</p></li><li><p><code>P</code> 是预测的协方差矩阵。</p></li><li><p><code>H</code> 是观测矩阵，它将状态空间映射到测量空间。</p></li><li><p><code>R</code> 是测量噪声协方差矩阵，表示测量值的不确定性。</p></li></ul><p><strong>b. 计算当前测量值和预测测量值之间的差异</strong></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi mathvariant="bold">y</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi mathvariant="bold">z</mi><mo>−</mo><mi mathvariant="bold">H</mi><mo>⋅</mo><mi mathvariant="bold">x</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}\mathbf{y} &amp;= \mathbf{z} -  \mathbf{H} \cdot \mathbf{x} \\\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5em;vertical-align:-0.5em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathbf">z</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">H</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><code>y</code> 是 <strong>创新</strong>（或者称为测量残差），表示测量值 <code>z</code> 与预测值 <code>Hx</code> 之间的差异。</li><li><code>z</code> 是实际的测量值。</li><li><code>Hx</code> 是根据当前预测状态 <code>x</code> 计算的测量值。</li></ul><p><strong>c. 通过将创新值 <code>y</code> 和卡尔曼增益 <code>K</code> 结合来更新预测的状态，目的是修正状态估计，使其更加接近实际的测量值。</strong></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi mathvariant="bold">x</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi mathvariant="bold">x</mi><mo>+</mo><mi mathvariant="bold">K</mi><mo>⋅</mo><mi mathvariant="bold">y</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}\mathbf{x} &amp;= \mathbf{x} + \mathbf{K} \cdot \mathbf{y} \\\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5em;vertical-align:-0.5em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathbf">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">K</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf" style="margin-right:0.01597em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><code>x</code> 是更新后的状态向量。</li><li><code>K</code> 是卡尔曼增益，<code>y</code> 是创新。</li></ul><p><strong>d. 更新协方差矩阵</strong></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi mathvariant="bold">P</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mi mathvariant="bold">I</mi><mo>−</mo><mrow><mo fence="true">(</mo><mi mathvariant="bold">K</mi><mo>⋅</mo><mi mathvariant="bold">H</mi><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow><mo>⋅</mo><mi mathvariant="bold">P</mi></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*}\mathbf{P} &amp;= \left( \mathbf{I} - \left( \mathbf{K} \cdot \mathbf{H} \right) \right) \cdot \mathbf{P}\end{align*}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.5em;vertical-align:-0.5em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1em;"><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathbf">I</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathbf">K</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">H</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.5em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li><p><code>P</code> 是更新后的协方差矩阵。</p></li><li><p><code>I</code> 是单位矩阵。</p></li><li><p><code>(I - KH)</code> 是卡尔曼增益对协方差的修正因子。这个操作是用来减小更新后的协方差，表示我们对更新后的状态估计更有信心。</p></li></ul><p><strong>e. 计算创新协方差，用于后续的卡尔曼增益计算</strong></p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mo>=</mo><mi>H</mi><mi>P</mi><msup><mi>H</mi><mi>T</mi></msup><mo>+</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">S = H P H^T + R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9747em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span></span></p><ul><li><p><code>S</code> 是创新协方差，</p></li><li><p><code>H</code> 是观测矩阵，</p></li><li><p><code>P</code> 是预测的协方差矩阵，</p></li><li><p><code>R</code> 是测量噪声协方差矩阵。</p></li></ul></li></ol><p>简单来说就是通过不断的预测和更新，使得卡尔曼滤波器能够精确地估计目标的状态，并且在实际应用中适应测量噪声和系统噪声的变化。</p><p><strong>注意：</strong></p><ol><li>时刻关注不断迭代的系统变量，分别是<strong>系统的状态x，误差协方差矩阵P，卡尔曼增益K</strong></li><li>在实际使用时，对Q和R的选择要依据实际情况，可以不断调试来试图寻找一个最优解。</li></ol></li></ul><h2 id="三、代码实践">三、代码实践</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> filterpy.kalman <span class="hljs-keyword">import</span> KalmanFilter<br><br><span class="hljs-comment"># 生成1000个位置，从1到1000，是小车的实际位置</span><br>z = np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">1000</span>)<br><span class="hljs-comment"># 添加噪声</span><br>mu,sigma = <span class="hljs-number">0</span>,<span class="hljs-number">1</span><br>noise = np.random.normal(mu,sigma,<span class="hljs-number">1000</span>)<br><span class="hljs-comment"># 小车位置的观测值</span><br>z_nosie = z+noise<br><br><span class="hljs-comment"># dim_x 状态向量size,在该例中为[p,v]，即位置和速度,size=2</span><br><span class="hljs-comment"># dim_z 测量向量size，假设小车为匀速，速度为1，测量向量只观测位置，size=1</span><br>my_filter = KalmanFilter(dim_x=<span class="hljs-number">2</span>, dim_z=<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 定义卡尔曼滤波中所需的参数</span><br><span class="hljs-comment"># x 初始状态为[0,0],即初始位置为0，速度为0.</span><br><span class="hljs-comment"># 这个初始值不是非常重要，在利用观测值进行更新迭代后会接近于真实值</span><br>my_filter.x = np.array([[<span class="hljs-number">0.</span>], [<span class="hljs-number">0.</span>]])<br><br><span class="hljs-comment"># p 协方差矩阵，表示状态向量内位置与速度的相关性</span><br><span class="hljs-comment"># 假设速度与位置没关系，协方差矩阵为[[1,0],[0,1]]</span><br>my_filter.P = np.array([[<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>], [<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>]])<br><br><span class="hljs-comment"># F 初始的状态转移矩阵，假设为匀速运动模型，可将其设为如下所示</span><br>my_filter.F = np.array([[<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>], [<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>]])<br><br><span class="hljs-comment"># Q 状态转移协方差矩阵，也就是外界噪声，</span><br><span class="hljs-comment"># 在该例中假设小车匀速，外界干扰小，所以我们对F非常确定，觉得F一定不会出错，所以Q设的很小</span><br>my_filter.Q = np.array([[<span class="hljs-number">0.0001</span>, <span class="hljs-number">0.</span>], [<span class="hljs-number">0.</span>, <span class="hljs-number">0.0001</span>]])<br><br><span class="hljs-comment"># 观测矩阵 Hx = p</span><br><span class="hljs-comment"># 利用观测数据对预测进行更新，观测矩阵的左边一项不能设置成0</span><br>my_filter.H = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]])<br><span class="hljs-comment"># R 测量噪声，方差为1</span><br>my_filter.R = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 保存卡尔曼滤波过程中的位置和速度</span><br>z_new_list = []<br>v_new_list = []<br><span class="hljs-comment"># 对于每一个观测值，进行一次卡尔曼滤波</span><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(z_nosie)):<br>    <span class="hljs-comment"># 预测过程</span><br>    my_filter.predict()<br>    <span class="hljs-comment"># 利用观测值进行更新</span><br>    my_filter.update(z_nosie[k])<br>    <span class="hljs-comment"># do something with the output</span><br>    x = my_filter.x<br>    <span class="hljs-comment"># 收集卡尔曼滤波后的速度和位置信息</span><br>    z_new_list.append(x[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])<br>    v_new_list.append(x[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])<br><br><span class="hljs-comment"># 位移的偏差</span><br>dif_list = []<br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(z)):<br>    dif_list.append(z_new_list[k]-z[k])<br><span class="hljs-comment"># 速度的偏差</span><br>v_dif_list = []<br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(z)):<br>    v_dif_list.append(v_new_list[k]-<span class="hljs-number">1</span>)<br>plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">9</span>))<br>plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>plt.xlim(-<span class="hljs-number">50</span>,<span class="hljs-number">1050</span>)<br>plt.ylim(-<span class="hljs-number">3.0</span>,<span class="hljs-number">3.0</span>)<br>plt.scatter(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(z)),dif_list,color =<span class="hljs-string">&#x27;b&#x27;</span>,label = <span class="hljs-string">&quot;位置偏差&quot;</span>)<br>plt.scatter(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(z)),v_dif_list,color =<span class="hljs-string">&#x27;y&#x27;</span>,label = <span class="hljs-string">&quot;速度偏差&quot;</span>)<br>plt.legend(loc = <span class="hljs-string">&#x27;upper right&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><strong>结果演示：</strong></p><p><img src="/img/DeepLearning/kalman/image-20250109140421419.png" alt="图4"></p><h2 id="参考文献">参考文献</h2><p><a href="http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/">http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/</a></p><p><a href="https://blog.csdn.net/m0_46339652/article/details/119221972">https://blog.csdn.net/m0_46339652/article/details/119221972</a></p>]]></content>
    
    
    <categories>
      
      <category>DeepLearning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepLearning</tag>
      
      <tag>OpenCV</tag>
      
      <tag>目标检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
